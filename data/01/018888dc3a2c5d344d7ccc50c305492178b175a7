<p>[Equations in this post may not look right (or appear at all) in your RSS reader. Go to <a href="https://leancrew.com/all-this/2025/06/in-defense-of-floating-point/">the original article</a> to see them rendered properly.]</p>
  <hr />
  <p>I’ve noticed that many programmers have a phobia about floating point numbers. They see something like this (a Python interactive session, but a similar thing could be done in many languages),</p>
<pre><code>python:
&gt;&gt;&gt; sum = 0.0
&gt;&gt;&gt; for i in range(10):
...     sum += 0.1
...
&gt;&gt;&gt; sum
0.9999999999999999
</code></pre>
<p>and decide never to trust floating point numbers again. Web pages with titles like <a href="https://www.baeldung.com/cs/floating-point-numbers-inaccuracy">“Why Are Floating Point Numbers Inaccurate?”</a> and <a href="https://riskledger.com/resources/floating-point-numbers">“What is a floating point number, and why do they suck”</a> help promote the mistrust.<sup id="fnref:question"><a href="#fn:question" rel="footnote">1</a></sup> I fear <a href="https://www.johndcook.com/blog/2025/06/27/most-ints-are-not-floats/">this post</a> published yesterday by John D. Cook will do the same.</p>
<p>The gist of Cook’s article, which is perfectly correct, is that the overwhelming majority of 32-bit integers cannot be represented exactly by a 32-bit float. And an even greater majority of 64-bit integers cannot be represented exactly by a 64-bit float.</p>
<p>If your response to the previous paragraph is “Well, duh!” you’re my kind of people. The mantissa of a <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">32-bit float</a> is only 24 bits wide (one of the bits is implicit), so of course you can only represent a small percentage of the 32-bit integers. After accounting for the sign bit, you have a 7-bit deficit.</p>
<p>But here’s the thing: a 32-bit float <em>can</em> represent exactly every integer from -16,777,216 to 16,777,216 (<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>−</mi><msup><mn>2</mn><mn>24</mn></msup></mrow></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mn>24</mn></msup></math>). Here’s a quick demonstration in an interactive Python session:</p>
<pre><code>python:
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n = 2**24
&gt;&gt;&gt; ai = np.linspace(-n, n, 2*n+1, dtype=np.int32)
&gt;&gt;&gt; af = np.linspace(-n, n, 2*n+1, dtype=np.float32)
&gt;&gt;&gt; np.array_equal(af.astype(np.int32), ai)
True
</code></pre>
<div class="sidebar">
<p><strong>Aside</strong><br/>
I’m using <a href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html#numpy.linspace"><code>linspace</code></a> instead of <a href="https://numpy.org/doc/stable/reference/generated/numpy.arange.html"><code>arange</code></a> because of this warning in the <code>arange</code> docs:</p>
<blockquote>
<p>The actual step value used to populate the array is <code>dtype(start + step) - dtype(start)</code> and not <code>step</code>. Precision loss can occur here, due to casting or due to using floating points when <code>start</code> is much larger than <code>step</code>.</p>
</blockquote>
<p>In our case the <code>start</code> value is much larger (in absolute value) than the <code>step</code>, so I followed the docs’ recommendation:</p>
<blockquote>
<p>In such cases, the use of <code>numpy.linspace</code> should be preferred.</p>
</blockquote>
</div>
<p>As Cook explains, there are actually many more integers that can be represented exactly by a <code>float32</code>, but there are gaps between them. The run from -16,777,216 to 16,777,216 has no gaps.</p>
<p>That’s a big range, possibly bigger than you need. And you’re more likely to be using <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">double precision</a> floats than single precision. For <code>float64</code>s, the mantissa is 53 bits (again, one bit is implicit), so they can exactly represent every integer from -9,007,199,254,740,992 to 9,007,199,254,740,992. Yes, as Cook says, that’s a very small percentage of 64-bit integers, but it’s still damned big.</p>
<p>JavaScript programmers understand the practical implications of this. By default, JavaScript stores numbers internally as 64-bit floats, so you’ll run into problems if you need an integer greater than 9 quadrillion. That’s why JavaScript has the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger"><code>isSafeInteger</code></a> function and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a> type.</p>
<p>I guess the main point is <em>understand the data types you’re using</em>. You wouldn’t use an 8-bit integer to handle values in the thousands, but it’s fine if the values stay under one hundred. The same rules apply to floating point. You just have to know how they work.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:question">
<p>The author of the second piece apparently doesn’t trust question marks, either. <a href="#fnref:question" rev="footnote">↩</a></p>
</li>
</ol>
</div>
  
