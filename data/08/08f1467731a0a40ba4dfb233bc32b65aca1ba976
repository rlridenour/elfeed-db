<p>At times, basic prints/logs are just about the right debugging strategy. Sure, we have debuggers and <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPLs</a> which are super useful, but sometimes you just know that sprinkling your code with a handful of temporary prints/logs will get you enough info to fix an issue.</p>
<p>I must confess, my temporary print statements are fairly uninspiring. Sometimes I log the name of the method/function, but I also resort to less creative options like <code>print(&quot;Yay&quot;)</code> or <code>print(&quot;Got here&quot;)</code>.</p>
<p>My laziness and lack of creativity knows no boundaries, so if I need multiple unique entries, I often copy, paste, and append numbers to my entries: <code>print(&quot;Yay 2&quot;)</code>, <code>print(&quot;Yay 3&quot;)</code>, <code>print(&quot;Yay 4&quot;)</code>â€¦ I know, are you judging yet?</p>
<p>So rather than develop the creative muscle, I've decided to lean on laziness and old habits, so let's make old habit more efficient :) I no longer want to copy, paste, and increment my uncreative log statements. Instead, I'll let Emacs do it for me!</p>
<p><img src="https://xenodium.github.io/images/sprinkle-me-logs/log-elisp.gif" alt=""></p>
<p>There isn't a whole lot to the implementation. It searches the current buffer for other instances of the same logging string and captures the largest counter found. It subsequently prints the same string with the counter incremented. This can be done in a few lines of elisp, but I figure I wanted some additional features like auto indenting and changing the logging string when using a prefix.</p>
<pre><code class="language-{.commonlisp">(defvar ar/unique-log-word &quot;Yay&quot;)

(defun ar/insert-unique-log-word (prefix)
  &quot;Inserts `ar/unique-log-word' incrementing counter.

With PREFIX, change `ar/unique-log-word'.&quot;
  (interactive &quot;P&quot;)
  (let* ((word (cond (prefix
                      (setq ar/unique-log-word
                            (read-string &quot;Log word: &quot;)))
                     ((region-active-p)
                      (setq ar/unique-log-word
                            (buffer-substring (region-beginning)
                                              (region-end))))
                     (ar/unique-log-word
                      ar/unique-log-word)
                     (t
                      &quot;Reached&quot;)))
         (config
          (cond
           ((equal major-mode 'emacs-lisp-mode)
            (cons (format &quot;(message \&quot;%s: \\([0-9]+\\)\&quot;)&quot; word)
                  (format &quot;(message \&quot;%s: %%s\&quot;)&quot; word)))
           ((equal major-mode 'swift-mode)
            (cons (format &quot;print(\&quot;%s: \\([0-9]+\\)\&quot;)&quot; word)
                  (format &quot;print(\&quot;%s: %%s\&quot;)&quot; word)))
           ((equal major-mode 'ada-mode)
            (cons (format &quot;Ada.Text_Io.Put_Line (\&quot;%s: \\([0-9]+\\)\&quot;);&quot; word)
                  (format &quot;Ada.Text_Io.Put_Line (\&quot;%s: %%s\&quot;);&quot; word)))
           ((equal major-mode 'c++-mode)
            (cons (format &quot;std::cout &lt;&lt; \&quot;%s: \\([0-9]+\\)\&quot; &lt;&lt; std::endl;&quot; word)
                  (format &quot;std::cout &lt;&lt; \&quot;%s: %%s\&quot; &lt;&lt; std::endl;&quot; word)))
           (t
            (error &quot;%s not supported&quot; major-mode))))
         (match-regexp (car config))
         (format-string (cdr config))
         (max-num 0)
         (case-fold-search nil))
    (when ar/unique-log-word
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward match-regexp nil t)
          (when (&gt; (string-to-number (match-string 1)) max-num)
            (setq max-num (string-to-number (match-string 1))))))
      (setq max-num (1+ max-num)))
    (unless (looking-at-p &quot;^ *$&quot;)
      (end-of-line))
    (insert (concat
             (if (looking-at-p &quot;^ *$&quot;) &quot;&quot; &quot;\n&quot;)
             (format format-string
                     (if ar/unique-log-word
                         (number-to-string (1+ max-num))
                       (string-trim
                        (shell-command-to-string
                         &quot;grep -E '^[a-z]{6}$' /usr/share/dict/words | shuf -n 1&quot;))))))
    (call-interactively 'indent-for-tab-command)))
</code></pre>
<p>Note: This snippet may evolve independently of this post. For the latest, chech my <a href="https://github.com/xenodium/dotsies">Emacs config</a>'s <a href="https://github.com/xenodium/dotsies/blob/main/emacs/features/fe-prog.el">fe-prog.el</a>.</p>
<p>I want to be lazy in other languages, so the function can now be extended to support other languages. Here's the Swift counterpart.</p>
<p><img src="https://xenodium.github.io/images/sprinkle-me-logs/log-swift.gif" alt=""></p>
<p>Since I sometimes log function names, I figured making it region-aware would help with that.</p>
<p><img src="https://xenodium.github.io/images/sprinkle-me-logs/log-selection.gif" alt=""></p>
<p>I'm sure there's a package out there that does something similar, but I figure this would be a fun little elisp hack.</p>
<p>Happy logging!</p>
<h2>Update 1</h2>
<p>Set <code>ar/unique-log-word</code> to nil and let it generate a random word. Maybe I get to learn new words as I debug ;)</p>
<p><img src="https://xenodium.github.io/images/sprinkle-me-logs/word.gif" alt=""></p>
<h2>Update 2</h2>
<p>Added Ada and C++ support, thanks to <a href="https://www.emacs.dyerdwelling.family/emacs/20230523204523-emacs--insert-unique-log-message/">James Dyer's post</a>.</p>
