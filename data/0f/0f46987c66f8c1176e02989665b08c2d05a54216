<p>This is the eighteenth post in the <a href="/blog/fastmail-advent-2024/">Fastmail Advent 2024</a> series. The previous post was <a href="/blog/offline-architecture/">Dec 17: Building offline: general architecture</a>. The next post is <a href="/blog/offline-mail-storage/">Dec 19: Building offline: mail storage</a>.</p><p>Yesterday, we looked at <a href="/blog/offline-architecture/">how our offline caching layer fits into our app</a>, and the way it stores data to efficiently respond to JMAP requests. Today, we’ll dive into how it keeps track of changes the user makes while offline, so it can reconcile this with the server.</p><h2 id="keeping-track-of-changes" tabindex="-1">Keeping track of changes</h2><p>When a client makes a change offline, we update our local cache and have to keep track of it so we can sync that change back to the server when we come online. There are two main approaches you could take:</p><ol> <li>You keep a time-ordered log of every change, then replay the log against the server. One record may appear multiple times in the log if it has multiple modifications applied.</li> <li>You keep a set of created/updated/destroyed records, along with the current server value. Each record can only appear once, in at most one of these categories. You calculate the difference between the server state and the current state to update the server.</li> </ol><p>The benefit of the first approach is it ensures we maintain any ordering dependencies. The benefit of the second approach is it’s more efficient in terms of both storage and synchronisation speed when there are multiple changes made to the same record.</p><p>The Fastmail offline cache uses a hybrid of these approaches to try to get the best of both worlds:</p><ul> <li>A log stores (in order) the <code>[data type, account id, id]</code> of any changes, along with what type of change this is (create/update/destroy).</li> <li>The record itself stores the last known server state if it’s been updated, stored efficiently as a patch to get back to the server state from the updated state.</li> <li>If the record is updated a second time, it: <ul> <li>stays in its current position in the log if not yet present on the server (this is a create); or</li> <li>moves to the end of the log (remove the old entry and add a new one) if it already exists on the server (this is an update/destroy); or</li> <li>is removed entirely from the log if the change reverted it back to the last-known server state.</li> </ul> </li> </ul><p>If we’re updating a record that’s not yet been created on the server, we may have to do an update as well as a create, due to an ordering problem. For example, suppose you do the following:</p><ol type="a"> <li>Create Mailbox X</li> <li>Create Emails A &amp; B in Mailbox X</li> <li>Create Mailbox Y</li> <li>Move Mailbox X to be a child of Y</li> <li>Move Email A to be in Mailbox Y</li> </ol><p>You can’t move (a) later because (b) depends on it. You can’t move (d) earlier because it depends on (c). So if we update a record that’s not yet been created on the server, and we set a property that includes a local id (i.e., it references another object that’s been created locally but not yet synced to the server), we add it as a patch and apply it as an update later.</p><p>When loading data from the server, we do not need to look for an entry in the log of changes still to sync. We can just update the server state in the record. If the change is now inert, we’ll delete it from the log when we go to sync it.</p><p>For example, suppose we have a mailbox, id <code>1</code>, with two messages in it, ids <code>A</code> &amp; <code>B</code>, and the user does the following (contrived) actions:</p><ul> <li>Creates a new mailbox: <code>2</code></li> <li>Creates a new child mailbox of that: <code>3</code></li> <li>Moves A and B into mailbox <code>3</code></li> <li>Marks B as read</li> <li>Moves A back to its original mailbox.</li> <li>Renames mailbox <code>2</code>.</li> </ul><p>Our log will end up looking like this:</p><pre><code>    [Mailbox, &quot;#2&quot;, CREATE]
    [Mailbox, &quot;#3&quot;, CREATE]
    [Email, &quot;B&quot;, UPDATE]
</code></pre><p>Because <code>A</code> is back to its original state, we’ve eliminated it entirely from the log, and do not need to send anything to the server. Because <code>#2</code> was a create in the log, we do not move it when we renamed it at the end, which is good because otherwise the other changes in the log would both fail as they depend on it. Despite making two changes to <code>B</code>, we only have to send a single update to the server for it.</p><h2 id="conflicts" tabindex="-1">Conflicts</h2><p>Suppose you have a shared contact, let’s call him Joe Bloggs. While offline you edit to add his phone number. Meanwhile, a colleague updates his email address. This means when your client comes back online and synchronises the changes, the object it is updating has already changed. This is called a conflict.</p><p>For the data types we have to handle, we believe automatic resolution (rather than presenting the conflict to the user and asking them to choose what should happen) is the right way to go. We follow these simple rules:</p><ul> <li>Last write wins.</li> <li>All updates are patches.</li> </ul><p>This means if the same object is updated by two different people, whichever client writes second will overwrite the data of the one that wrote first. (The first client will then sync this change back so you get a consistent state.) However, since all updates are patches, it will merge the changes unless they apply to the same property on the object. So in the case above, although there were two writes to the same contact, they were updating different properties. One user was updating the “<a href="https://www.rfc-editor.org/rfc/rfc9553.html#name-emails" target="_blank" rel="noopener">emails</a>”, the other the “<a href="https://www.rfc-editor.org/rfc/rfc9553.html#name-phones" target="_blank" rel="noopener">phones</a>”. So in this case, both changes would be preserved.</p><h2 id="next-up-mail-storage" tabindex="-1">Next up, mail storage</h2><p>In this post we looked at how we store changes you make offline so we can accurately and efficiently sync them back to the server when you come online. Like our discussion of data storage yesterday, everything here applies generically to all data types.</p><p>Tomorrow, we’ll discuss <a href="/blog/offline-mail-storage/">why email is special</a>, and what else we do to make this super fast in our offline store.</p>