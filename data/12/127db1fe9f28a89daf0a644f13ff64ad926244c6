<div>  <p>When I started making generative art, I was excited to share the art I made. I took screenshots and manually cropped them to only the part of the desktop containing the art. As you might imagine, this process <a href="https://twitter.com/zckzck/status/951342454074216448">was completely foolproof</a>, not to mention quick and easy.</p>  <p>No, wait. It was error-prone, boring and repetitive. But computers can do boring repetitive tasks for us! And whenever my computer starts to complain about having to play the <a href="https://www.youtube.com/watch?v=-AtUvHJT1xI&amp;t=4m17s">same video over and over</a>, I just unplug it.</p>  <p>Point being: I'm using <a href="http://quil.info/">Quil</a>, a Clojure library based on <a href="https://processing.org/">Processing</a>. Quil has a function <a href="http://quil.info/api/output/image#save-frame">save-frame</a>:</p>  <figure>    <blockquote>      <p><code>save-frame</code>: Saves an image identical to the current display window as a file.</p>    </blockquote>  </figure>  <p>We <em>could</em> call that function at the end of generating the art. That would work, but I render my art a few times with different random values, and manually pick some to keep. Like a child's drawings, some art is better thrown away. Luckily, Quil's <code>sketch</code> function has a parameter that runs a passed-in function any time <a href="http://quil.info/api/environment#defsketch">a key is pressed</a>.</p>  <figure>    <blockquote>      <p><code>:key-pressed</code> - Called every time any key is pressed.</p>    </blockquote>  </figure>  <p>So we write a function that saves the current artwork as a picture when the <code>s</code> key is pressed.</p>  <pre><code class="code-clojure">(fn [] (when (= \s (q/raw-key))         (q/save-frame "/path/to/save/to.png")))</code></pre>  <p>And use it in a sketch:</p>  <pre><code class="code-clojure">(q/sketch :size [width height] :draw my-draw-function :key-pressed (fn [] (when (= \s (q/raw-key))                       (q/save-frame "/path/to/save/to.png"))))</code></pre>  <p>Now, anytime the <code>s</code> key is pressed, the current sketch is saved to the path <code>/path/to/save/to.png</code>.</p>  <p>That's fine, but we can do better. Let's make a function to generate this function. This way, we can call it from different artworks without having to copy and paste the body around. This is a common pattern I have with helper methods &ndash; start by making them in one work, then move them to a common library. It's satisfying to build your own package of useful functions.</p>  <pre><code class="code-clojure">(defn key-press-fn-creator  []  (fn []    (when (= \s (q/raw-key))      (q/save-frame "/path/to/save/to.png"))))</code></pre>  <p>Now, rather than always saving to the same path, let's save to a better location.</p>  <ol>    <li><p>Save pictures inside a base folder specified in a variable <code>base-output-folder</code>.</p></li>    <li><p>Inside that folder, use a folder for the current year. This means that once we've been making art for a while, we'll have an idea when we created each specific file.</p></li>    <li><p>Take the name of the work as an argument to the function, and use that as the next folder.</p></li>    <li><p>Explicitly save the random seed at the beginning of my work. We can reuse the seed to regenerate the same artwork, and lets us save more than one screenshot from the same code. We can use the seed as the filename to differentiate different saved versions of the same work.</p></li>  </ol>  <pre><code class="code-clojure">(def base-output-folder "/path/containing/art/screenshots")(defn key-press-fn-creator  [work-name]  (fn []    (when (= \s (q/raw-key))      (let [file-path (format "%s/%s/%s/opus-%s.png"                              base-output-folder                              (q/year)                              work-name                              (q/state :seed))]        (q/save-frame file-path)))))</code></pre>  <p>Because Quil doesn't expose the seed it uses, we generate a new one, store it in the <a href="http://quil.info/api/state#state-atom">state atom</a>, and tell Quil to use it instead of the default seed.</p>  <pre><code class="code-clojure">;; in the setup function.(swap! (q/state-atom)       assoc       :seed       (q/random (Math/pow 10 9)))(q/random-seed (q/state :seed))</code></pre>  <p>This function is used in the <code>sketch</code> call:</p>  <pre><code class="code-clojure">(q/sketch ;;; other code elided :key-pressed (key-press-fn-creator "bubbling-brook"))</code></pre>  <p>Finally, pressing ESC to quit the sketch is too much work. Let's close the sketch when <code>q</code> is pressed.</p>  <pre><code class="code-clojure">(defn key-press-fn-creator  [work-name]  (let [actions {\s (fn []                      (let [file-path (format "%s/%s/%s/opus-%s.png"                                              base-output-folder                                              (q/year)                                              work-name                                              (q/state :seed))]                        (q/save-frame file-path)))                 \q (fn []                      (q/exit))}]    (fn []      (when-let [action (actions (q/raw-key))]        (action)))))</code></pre>  <p>There's more that could be done, but this post is long enough. Maybe I'll make a tool so I don't have to automatically crop blog posts.</p></div>