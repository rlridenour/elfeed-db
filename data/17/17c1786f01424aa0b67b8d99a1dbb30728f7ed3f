<p>TL;DR: Complete multiplayer game in the browser made of 270 lines of Python and 0 lines of JavaScript running on Django thanks to <a href="https://django-liveview.andros.dev/">Django LiveView</a>.</p>
<p>After my adventure in <a href="https://en.andros.dev/blog/7b1b607b/doom-in-django-testing-the-limits-of-liveview-at-600000-divsseconds/">Doom</a>, I asked myself a question. Could I build a simple multiplayer game in Django? Similar to working with tools like Pygame, except the result would be rendered on a web page. Django LiveView could save me from having to write JavaScript and manage WebSockets. All game state would live on the server and rendered HTML is sent to clients via WebSockets. Let's play!</p>
<p>My goal was to create the Snake game, but multiplayer, with multiple players competing on the same board. Each player controls their own snake, trying to eat food and avoid crashing into other snakes or walls. The game lives in a 20x20 cell space, or 400 divs, and updates 10 times per second. That's a total of 4000 divs/second. Pretty easy for a modern browser.</p>
<h2 id="blog-single-content__title--step-1-game-loop-in-background-thread" class="blog-single__content-title">Step 1: Game Loop in Background Thread</h2>
<p>Every proper game has a <em>game loop</em> that updates the game state and renders the output. In this case, the loop runs in a separate thread to avoid blocking the main web server:</p>
<pre class="highlight"><code class="language-python">def loop():
    """Main game loop"""
    while True:
        sleep(0.1)
        update()  # Update positions, detect collisions
        render()  # Broadcast HTML to all clients

def start():
    thread = threading.Thread(target=loop, daemon=True)
    thread.start()</code></pre>
<h2 id="blog-single-content__title--step-2-broadcasting-to-all-clients" class="blog-single__content-title">Step 2: Broadcasting to All Clients</h2>
<p>The magic is in sending the rendered HTML grid to all connected clients. Specifically, it would update 10 times per second (10 FPS) since the game doesn't need more fluidity.</p>
<pre class="highlight"><code class="language-python">def render():
    html = render_to_string("components/canvas.html", {
        "canvas": game_state["canvas"],
    })
    data = {
        "target": "#canvas",
        "html": html,
    }
    async_to_sync(my_channel_layer.group_send)(
        "broadcast", {"type": "broadcast_message", "message": data}
    )</code></pre>
<h2 id="blog-single-content__title--step-3-capturing-keyboard-events" class="blog-single__content-title">Step 3: Capturing Keyboard Events</h2>
<p>With Django LiveView, keyboard events can be handled directly in Python. The keyboard mapping uses WASD keys for movement:</p>
<pre class="highlight"><code class="language-html">&lt;section data-liveview-keyboard-map='{"w":"key_up","a":"key_left","s":"key_down","d":"key_right"}'
         data-liveview-focus="true"&gt;</code></pre>
<p>Or you can add a button:</p>
<pre class="highlight"><code class="language-html">&lt;button data-liveview-function="key_up" data-action="click-&gt;page#run"&gt;☝️&lt;/button&gt;</code></pre>
<p>In both cases, the event is handled in Python:</p>
<pre class="highlight"><code class="language-python">@liveview_handler("key_up")
def key_up(consumer, content):
    room_id = getattr(consumer, "room_id", None) or content.get("room")
    set_direction(room_id, "up")</code></pre>
<p>Technically speaking, who captures the events is JavaScript (there's no other way), specifically Stimulus or LiveView JS, but all event handling and game logic is done in Python. Django LiveView works with HTML attributes and Python decorators. It would be similar to using htmx except here there's no REST API in between and a single WebSocket connection is used all the time.</p>
<h2 id="blog-single-content__title--step-4-player-identification" class="blog-single__content-title">Step 4: Player Identification</h2>
<p>Now we get into the logic part. How do we identify each player? Every page has a unique UUID generated by LiveView accessible via the template:</p>
<pre class="highlight"><code class="language-html">{% load liveview %}
&lt;html lang="en" data-room="{% liveview_room_uuid %}"&gt;</code></pre>
<p>Which is also accessible in Python since it's assigned to the consumer. The game uses a global shared state accessed by all handlers:</p>
<pre class="highlight"><code class="language-python"># Global game state (shared by all players)
game_state = {
    "canvas": [],
    "target": {"x": 10, "y": 10},
    "players": {},  # {room_id: {direction, body, color, last_activity}}
}

@liveview_handler("key_up")
def key_up(consumer, content):
    room_id = getattr(consumer, "room_id", None) or content.get("room")
    set_direction(room_id, "up")

def set_direction(room_id, new_direction):
    """Set the direction for a specific player"""
    with game_lock:
        if room_id not in game_state["players"]:
            _create_player(room_id)

        player = game_state["players"][room_id]
        # Prevent reverse direction to avoid instant death
        opposite = {"up": "down", "down": "up", "left": "right", "right": "left"}

        if opposite.get(player["direction"]) != new_direction:
            player["direction"] = new_direction
        player["last_activity"] = time()</code></pre>
<p>An elegant solution integrated with the framework. Each player is identified by their unique <code>room_id</code>, and the game automatically handles player cleanup.</p>
<h2 id="blog-single-content__title--step-5-the-game-logic-update-function" class="blog-single__content-title">Step 5: The Game Logic - Update Function</h2>
<p>The heart of the game is the <code>update()</code> function, called 10 times per second by the game loop. It handles movement, collisions, food consumption, and inactive player cleanup:</p>
<pre class="highlight"><code class="language-python">def update():
    """Update all players' positions"""
    with game_lock:
        # Clean up inactive players (30 second timeout)
        current_time = time()
        inactive_players = [
            room_id for room_id, player in game_state["players"].items()
            if current_time - player["last_activity"] &gt; 30
        ]
        for room_id in inactive_players:
            del game_state["players"][room_id]

        # Move each player's snake
        for room_id, player in game_state["players"].items():
            head = player["body"][0]

            # Calculate new head position (with wrap-around)
            if player["direction"] == "left":
                new_head = {"x": head["x"], "y": (head["y"] - 1) % HEIGHT}
            elif player["direction"] == "right":
                new_head = {"x": head["x"], "y": (head["y"] + 1) % HEIGHT}
            # ... similar for up/down

            # Check if eating food
            will_eat = (new_head["x"] == game_state["target"]["x"] and
                       new_head["y"] == game_state["target"]["y"])

            # Move snake: add new head, remove tail (unless eating)
            player["body"].insert(0, new_head)
            if not will_eat:
                player["body"].pop()
            else:
                game_state["target"] = search_random_free_space()

        # Detect collisions (self-collision and with other snakes)
        players_to_reset = []
        for room_id, player in game_state["players"].items():
            new_head = player["body"][0]

            # Self-collision
            if new_head in player["body"][1:]:
                players_to_reset.append(room_id)

            # Collision with other snakes
            for other_room_id, other_player in game_state["players"].items():
                if room_id != other_room_id and new_head in other_player["body"]:
                    players_to_reset.append(room_id)
                    break

        # Reset collided snakes to random position
        for room_id in players_to_reset:
            game_state["players"][room_id]["body"] = [search_random_free_space()]</code></pre>
<p>Notice how inactive players are automatically removed after 30 seconds of no activity. This prevents the game from filling up with disconnected players.</p>
<h2 id="blog-single-content__title--step-6-dynamic-rendering-with-inline-styles" class="blog-single__content-title">Step 6: Dynamic Rendering with Inline Styles</h2>
<p>Each canvas cell is represented with a different color, depending on whether it's part of a player's body, food, or empty space. The trick is to use inline styles to define the background and border color of each cell directly in the rendered HTML.</p>
<pre class="highlight"><code class="language-html">&lt;div style="background-color: {{ col.color }}; border-color: {{ col.color }};"&gt;&lt;/div&gt;</code></pre>
<p>My complete canvas template looks like this:</p>
<pre class="highlight"><code class="language-html">{% for rows in canvas %}
{% for col in rows %}
{% if col == "floor" %}
&lt;div class="canvas__cell canvas__floor"&gt;&lt;/div&gt;
{% elif col.type == "target" %}
&lt;div class="canvas__cell canvas__cell--target"&gt;&lt;/div&gt;
{% elif col.type == "player" %}
&lt;div class="canvas__cell canvas__cell--player-1" style="background-color: {{ col.color }}; border-color: {{ col.color }};"&gt;&lt;/div&gt;
{% elif col.type == "player_head" %}
&lt;div class="canvas__cell canvas__cell--head" style="background-color: {{ col.color }}; border-color: {{ col.color }};"&gt;&lt;/div&gt;
{% endif %}
{% endfor %}
{% endfor %}</code></pre>
<h2 id="blog-single-content__title--step-7-testing-locally-and-deployment" class="blog-single__content-title">Step 7: Testing Locally and Deployment</h2>
<p>The first step is to test if it works locally, against myself. I launch 2 instances of my browser and start playing against myself.</p>
<video src="/media/blog/2026/01/snake-local.mp4" autoplay loop muted playsinline></video>

<p>It seems to work well. However, it's an unrealistic situation.</p>
<ul>
<li>My machine is powerful.</li>
<li>I have no latency.</li>
<li>There are only 2 players.</li>
</ul>
<p>The next step is to deploy it on a humble machine, a Raspberry Pi 3, and play with several friends each from their own home. One of them was on a continent more than 9,700 km away.</p>
<video src="/media/blog/2026/01/snake-multiplayer.mp4" autoplay loop muted playsinline></video>

<p>One of them played from a mobile with 4G connection.</p>
<p>And despite everything, it worked! The game was perfectly playable.</p>
<h2 id="blog-single-content__title--performance-metrics" class="blog-single__content-title">Performance Metrics</h2>
<p>Let's talk numbers. Each broadcast sends the entire 20x20 grid (400 cells) as HTML to all connected clients:</p>
<p>Payload size per update:</p>
<ul>
<li>Empty cell: <code>~47 bytes</code> (<code>&lt;div class="canvas__cell canvas__floor"&gt;&lt;/div&gt;</code>)</li>
<li>Player cell: <code>~125 bytes</code> (includes inline styles for color)</li>
<li>Food cell: <code>~48 bytes</code></li>
</ul>
<p>With a mostly empty board, each update sends approximately 18-20 KB of HTML. At 10 FPS, that's 180-200 KB/s per client for broadcast updates.</p>
<h2 id="blog-single-content__title--conclusions" class="blog-single__content-title">Conclusions</h2>
<p>I'm left with more questions than certainties, I would have loved to play with 10 or 20 simultaneous players to see how the server behaves. But overall, I'm very satisfied with the result. Browsers are just a mirror of the game state that lives on the server, their only job is to render and send new events. This makes it not only easy to maintain but also scalable. I can add new features to the game without having to touch the WebSocket handler code or worry about synchronizing state between client and server.</p>
<p>For me, the successes of using this approach are:</p>
<ul>
<li>I don't need to write JavaScript.</li>
<li>The game state is centralized on the server and is individual per player.</li>
<li>I only have to work with Django templates.</li>
<li>WebSocket connections and DOM synchronization are automated.</li>
</ul>
<p>But not everything is advantages:</p>
<ul>
<li>There's no client-side prediction or interpolation, which can be a problem for games that require low latency.</li>
<li>Broadcasting HTML is heavier than sending JSON with data.</li>
<li>Poor server performance affects all players.</li>
</ul>
<p>My intention is not to create games with Django LiveView, but to experiment with realtime capabilities. It's a good tool to add interactivity without complications. And apparently, it can also handle simple multiplayer games.</p>
<ul>
<li><a href="https://django-liveview-demo-snake.andros.dev/">Online demo</a>: You can use W D S A to control the snake, but you must first press a direction button. And you'll have to guess what colors you are, sorry!</li>
<li><a href="https://github.com/Django-LiveView/demo-snake">Source code</a></li>
</ul>