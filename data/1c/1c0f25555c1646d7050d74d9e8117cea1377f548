<p>Someone asked me what the rationale is for the decision, in my <a href="https://scottlburson2.blogspot.com/2025/10/fset-20-is-coming.html">FSet 2.0 release candidate</a>, to have no default default for maps and seqs, so that an out-of-domain lookup will signal an error.&nbsp; I started to write an answer, but after putting the arguments for and against this change down on the page and mulling them over for a few days, I concluded it was a mistake and decided to reverse it.</p><p>So in FSet 2.0, it will still be the case, unless you specify otherwise, that an out-of-domain lookup on a map, or an out-of-bounds lookup on a seq, will simply return <span style="font-family: Inconsolata;">nil</span> (with a <span style="font-family: Inconsolata;">nil</span> second value).&nbsp; You do, as before, have the option to specify a different default, and now you also have the option to specify no default, if you want out-of-domain/bounds lookups to signal an error.</p><p>I have tagged v2.0.0-rc1.&nbsp;</p><p>This has been a difficult decision that I have changed my mind about a few times.&nbsp; Let me summarize the arguments for and against the change.&nbsp; I'll start with some in favor of not having a default default:</p><ul style="text-align: left;"><li>It will be simpler to explain to new FSet users that the map or seq has a default only if explicitly given one.</li><li>Users will supply a default of <span style="font-family: Inconsolata;">nil</span> only for those maps and seqs which actually have out-of-domain/bounds lookups done on them.&nbsp; More maps and seqs will have no default, which will surface cases when an intended invariant, that the lookups are all in-domain, is violated; this will improve the overall robustness of their code.</li><li>Some operations, primarily <span style="font-family: Inconsolata;">map-union</span>, <span style="font-family: Inconsolata;">map-intersection</span>, and <span style="font-family: Inconsolata;">compose</span>, are easier to use when their arguments have no defaults; if they have nil defaults, the function passed in to combine or map values (often specified as a lambda expression) must explicitly handle <span style="font-family: Inconsolata;">nil</span>, which is often inelegant.&nbsp; If there is no default default, fewer people will trip over this speed bump.</li></ul><p>Some arguments in favor of a nil default default:</p><ul style="text-align: left;"><li>It's consistent with FSet past practice; having no default default will require migration effort on the part of FSet users.</li><li>It's consistent with the majority of CL collection accessors (<span style="font-family: Inconsolata;">assoc</span>, <span style="font-family: Inconsolata;">gethash</span>, <span style="font-family: Inconsolata;">nth</span>).</li><li>It's consistent with other FSet behaviors, such as that of <span style="font-family: Inconsolata;">arb</span> on an empty set, which returns two <span style="font-family: Inconsolata;">nil</span> values.</li></ul><p>Minimizing migration effort is somewhat desirable, of course, but I try not to overweight it.&nbsp; There's an old story I once heard about Stu Feldman, the original author of <span style="font-family: Inconsolata;">make</span>.&nbsp; He wrote it and passed it around to his colleagues at Bell Labs.&nbsp; Pretty soon he realized that the syntax was a dumpster fire, but he didn't want to fix it, the story goes, because he already had ten users.&nbsp; And now millions of us have to live with it.</p><p>So I'm willing to impose some migration pain on existing users, as long as it doesn't seem excessive, if I believe they themselves will be happier in the long run.&nbsp; &nbsp;It's not that their interests don't count; it's just that future benefits can outweigh present pain.&nbsp; And in this case, I think the amount of present pain would not have been large; I did the conversion on some of my own code that uses FSet, and it didn't seem very hard.&nbsp; So all told, the migration argument carried a little weight, but not a huge amount.</p><p>As for the CL collection accessors, there is some inconsistency there already.&nbsp; Sequence accessors &mdash; <span style="font-family: Inconsolata;">svref</span>, <span style="font-family: Inconsolata;">elt</span>, and <span style="font-family: Inconsolata;">aref</span> &mdash; do signal an error on an out-of-bounds index, except perhaps at safety 0.&nbsp; (Surprisingly, at least to me, of these only <span style="font-family: Inconsolata;">elt</span> is <i>specified</i> to signal an error, but the other two do so also in all the implementations I've tried.)&nbsp; <span style="font-family: Inconsolata;">nth</span> is a funny case; at least in the major implementations, on a positive index greater than or equal to the length of the list, it just returns nil, but on a negative index it signals an error.&nbsp; The consistency-with-CL argument is thus not quite as strong as it may sound, when CL isn't even completely self-consistent.&nbsp; Of course, the map accessors <span style="font-family: Inconsolata;">assoc</span> and <span style="font-family: Inconsolata;">gethash</span> do return <span style="font-family: Inconsolata;">nil</span> on an out-of-domain lookup.&nbsp; All told, again, this argument carries somewhat more weight for me than the migration argument, but it's not overwhelming.</p><p>The argument from internal consistency of FSet was the one that tipped the balance for me.&nbsp; There are other access operations besides <span style="font-family: Inconsolata;">lookup</span> that indicate failure by returning a second (or sometimes third) value which is false.&nbsp; I suppose I could have changed these to signal errors also, but this seemed a bridge too far; in the cases of set and bag operations, there isn't currently a way you could select between the error behavior and the return-nil behavior, the way that the choice of defaults allows you to do for maps and seqs.</p><p>I also tried to estimate the frequency of the following two cases:</p><ul style="text-align: left;"><li>In a no-default-default FSet, how often would users have to add an explicit <span style="font-family: Inconsolata;">:default nil</span>&nbsp;to prevent undesired lookup errors?</li><li>In a <span style="font-family: Inconsolata;">nil</span>-default-default FSet,&nbsp; how often would users have to add an explicit <span style="font-family: Inconsolata;">:no-default</span> or <span style="font-family: Inconsolata;">:no-default? t</span> to cause errors on out-of-domain lookups, or for reasons having to do with <span style="font-family: Inconsolata;">map-union</span> etc?</li></ul><p>Although it's hard to be extremely confident about my estimates without seeing a lot of code others have written against FSet, my experience suggests that the former would be several times as frequent as the latter.&nbsp; This argument also helps tip the balance toward a <span style="font-family: Inconsolata;">nil</span> default default.</p>