<p>Now I have ditched <code>save-desktop</code> for <code>recentf</code> which gives me a faster startup time but still being able to quickly access my most common files (i.e. those I have most recently opened) I have realised that I would like to have quick access to other Emacs resources after a startup.</p>
<figure><img src="https://emacs.dyerdwelling.family/ox-hugo/20240305160708-emacs--Unified-Interface-For-Switching-Contexts.jpg" width="100%">
</figure>

<p>This has led me to creating a unified interface of sorts to switch to different contexts through a single keybinding.  If you think that sounds vague, well you are correct!, I shall try and explain myself.</p>
<hr>
<p><code>save-desktop</code> has served me well for many many years as a quick method to call up my last session including recreating buffers in their last positions and thus repopulating the ibuffer list and re-enabling the default Emacs <code>switch-to-buffer</code> mechanism.</p>
<p>Unfortunately as I am now fiddling around with elisp it means that restarting Emacs has become much more commonplace and I don&rsquo;t really want to wait around for <code>save-desktop</code> to recreate itself after each reload.  In addition there were the odd peculiarities that I could never seem to resolve.</p>
<p>Out of the box <code>recentf</code> has its own basic opening mechanism not tied into anything particularly modern with a list of files populated for selection in a separate buffer, but <code>consult-recent-file</code> solves this by giving me a nice completing-read experience.</p>
<p>So now I can recall my most recent files in a nice completing-read way how about preserving a familiar switching experience, I could bind <code>consult-recent-file</code> to <code>C-x b</code>, hence <code>switch-to-buffer</code> for continuity, but then of course I can&rsquo;t switch to buffer!  should I have separate keybinding for <code>consult-recent-file</code>?, well maybe, but what else would I like to quickly switch to?</p>
<p>Well of course buffers! I shouldn&rsquo;t get carried away without forgetting the Emacs staple switching mechanism and in fact <code>switch-to-buffer</code> is perfectly fine and is completing-read enabled (I could also use <code>consult-buffer</code>)</p>
<p>Bookmarks! (can I start a sentence like that?).  This is a very underrated feature that I have become more accustomed to using and of course the USP being that a bookmark can reference a file, info page, directory, or pretty much anything you would want to access in Emacs.  Well that has a separate selection mechanism too via <code>bookmark-bmenu-list</code> which displays a list of existing bookmarks in a separate buffer.  Again the brilliant <code>consult-bookmark</code> comes to the rescue converting the bookmark mechanism into a completing-read, but how do I access this list?, another keybinding?, well maybe.</p>
<p>I am also one of those people that switches themes very often, like several times a day, well how do I do this?, <code>load-theme</code>, <code>customize-themes</code>?.  Out of the box theme selecting has a separate selection mechanism too which displays a list of existing themes in a separate buffer.  Again the brilliant <code>consult-theme</code> comes to the rescue giving a nice completing-read selection mechanism, but how do I access this list?, another keybinding?, well maybe.</p>
<p>So I have four contexts to switch to and I don&rsquo;t want a single keybinding for each one so can I merge all of these contexts into a single completing-read under a single keybinding, with the completion mechanism of choice performing the heavy lifting to give me a fast unified method of quick switching? (and breathe! üòµ‚Äçüí´), the answer of course is - <em>&ldquo;this is Emacs dummy, of course you can!&rdquo;</em>.</p>
<p>I thought this would also be a perfect opportunity to further my understanding of elisp by tackling this problem myself, which is how I came up with <code>my/switch-to-thing</code>, which is described below:</p>
<hr>
<h2 id="my-switch-to-thing">my/switch-to-thing</h2>
<p>The provided Emacs Lisp function `my/switch-to-thing` offers a unified interface within Emacs to quickly switch contexts. It enables a user to perform one of several actions based on the user&rsquo;s selection from a prompted completion list. The specific actions that can be taken are:</p>
<ol>
<li>
<p><strong><strong>Switching to an Open Buffer</strong></strong>: If the selection matches the name of an open buffer, the function switches the current window to display that buffer.</p>
</li>
<li>
<p><strong><strong>Opening a Recent File</strong></strong>: If the selection matches an entry in the list of recently opened files, that file is opened in the current window.</p>
</li>
<li>
<p><strong><strong>Jumping to a Bookmark</strong></strong>: If the selection matches a bookmark&rsquo;s name, Emacs navigates to that bookmark.</p>
</li>
<li>
<p><strong><strong>Changing the Emacs Theme</strong></strong>: If the selection starts with the prefix &ldquo;Theme: &ldquo;, the function interprets the rest of the selection as the name of a theme. It then loads and applies that theme.</p>
</li>
</ol>
<p>Here is a break down of its behavior:</p>
<ul>
<li>
<p><strong><strong>Initialization</strong></strong>: It first creates lists of current buffer names (`buffers`), recent files (`recent-files`), bookmark names (`bookmarks`), and available themes formatted with a &ldquo;Theme: &quot; prefix (`themes`). These lists are then concatenated into `all-options`, forming a comprehensive list of choices for the user.</p>
</li>
<li>
<p><strong><strong>User Input</strong></strong>: It prompts the user with a &ldquo;`Switch to:`&rdquo; message using `completing-read`, offering autocomplete functionality based on the `all-options` list. This prompt also integrates with Emacs&rsquo; `file-name-history` for enhanced usability.</p>
</li>
<li>
<p><strong><strong>Action Selection</strong></strong>: Based on the user&rsquo;s choice (`selection`), the function uses `pcase` to pattern-match and decide the action:</p>
<ul>
<li>If the selection is an open buffer, it switches to that buffer (`switch-to-buffer`).</li>
<li>If the selection is a bookmark, it jumps to that bookmark (`bookmark-jump`).</li>
<li>If the selection is prefixed with &ldquo;Theme: &ldquo;, it extracts the theme name, converts it back to a symbol, and loads that theme (`load-theme`).</li>
<li>If none of the above conditions are met, it interprets the selection as a file path/name and attempts to open it (`find-file`).</li>
</ul>
</li>
</ul>
<p>This function effectively encapsulates multiple navigation and customization actions within Emacs into a single command, streamlining the user&rsquo;s workflow by providing a centralized interface for common tasks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elisp" data-lang="elisp"><span style="display:flex;"><span>(defun my/switch-to-thing ()
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Switch to a buffer, open a recent file, jump to a bookmark, or change the theme from a unified interface.&#34;</span>
</span></span><span style="display:flex;"><span>  (interactive)
</span></span><span style="display:flex;"><span>  (let* ((buffers (<span style="color:#a6e22e">mapcar</span> <span style="color:#a6e22e">#&#39;buffer-name</span> (<span style="color:#a6e22e">buffer-list</span>)))
</span></span><span style="display:flex;"><span>          (recent-files recentf-list)
</span></span><span style="display:flex;"><span>          (bookmarks (bookmark-all-names))
</span></span><span style="display:flex;"><span>          (themes (custom-available-themes))
</span></span><span style="display:flex;"><span>          (all-options (<span style="color:#a6e22e">append</span> buffers recent-files bookmarks
</span></span><span style="display:flex;"><span>                         (<span style="color:#a6e22e">mapcar</span> (lambda (theme) (<span style="color:#a6e22e">concat</span> <span style="color:#e6db74">&#34;Theme: &#34;</span> (<span style="color:#a6e22e">symbol-name</span> theme))) themes)))
</span></span><span style="display:flex;"><span>          (selection (<span style="color:#a6e22e">completing-read</span> <span style="color:#e6db74">&#34;Switch to: &#34;</span>
</span></span><span style="display:flex;"><span>                       (lambda (str pred action)
</span></span><span style="display:flex;"><span>                         (if (<span style="color:#a6e22e">eq</span> action <span style="color:#e6db74">&#39;metadata</span>)
</span></span><span style="display:flex;"><span>                           <span style="color:#f92672">&#39;</span>(metadata <span style="color:#f92672">.</span> ((category <span style="color:#f92672">.</span> file)))
</span></span><span style="display:flex;"><span>                           (complete-with-action action all-options str pred)))
</span></span><span style="display:flex;"><span>                       <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">t</span> <span style="color:#66d9ef">nil</span> <span style="color:#e6db74">&#39;file-name-history</span>)))
</span></span><span style="display:flex;"><span>    (pcase selection
</span></span><span style="display:flex;"><span>      ((pred (lambda (sel) (<span style="color:#a6e22e">member</span> sel buffers))) (switch-to-buffer selection))
</span></span><span style="display:flex;"><span>      ((pred (lambda (sel) (<span style="color:#a6e22e">member</span> sel bookmarks))) (bookmark-jump selection))
</span></span><span style="display:flex;"><span>      ((pred (lambda (sel) (string-prefix-p <span style="color:#e6db74">&#34;Theme: &#34;</span> sel)))
</span></span><span style="display:flex;"><span>        (load-theme (<span style="color:#a6e22e">intern</span> (<span style="color:#a6e22e">substring</span> selection (<span style="color:#a6e22e">length</span> <span style="color:#e6db74">&#34;Theme: &#34;</span>))) <span style="color:#66d9ef">t</span>))
</span></span><span style="display:flex;"><span>      (_ (find-file selection)))))
</span></span></code></pre></div>