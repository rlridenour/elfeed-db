<p>Computers are funny things. At the lowest level they&rsquo;re just a pile of ones and zeros that we assign meaning to. It&rsquo;s something you can easily take for granted, but there&rsquo;s a disconnect with how we talk about how things operate at the hardware level and then again at the software level.</p>
<p>Since writing a compiler, I&rsquo;ve been able to bridge that gap in part. The fundamental idea is that we represent some meaning in a concrete, though still high-level form. Example: we might represent an entry in a contact book with a struct.</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">defstruct</span> <span style="color:#eceff4">[</span><span style="color:#a3be8c">name</span><span style="color:#eceff4">:</span> <span style="color:#a3be8c">:string</span><span style="color:#eceff4">,</span> <span style="color:#a3be8c">age</span><span style="color:#eceff4">:</span> <span style="color:#a3be8c">:integer</span><span style="color:#eceff4">]</span>
</span></span></code></pre></div><p>The critical step is this: we find a way to <em>consistently represent that entity in the physical realm</em>. We pack up a bunch of ones and zeros next to each other that are spaced apart at the right distances. Operations on bits in that neighborhood have to obey the rules we put in place. (E.g. treat the bits representing the age as a single thing, the bits representing the name can be broken up along character boundaries, etc.) Once our operations are complete, assuming our rules—our invariants—were never violated, then we can ascribe new meaning to the resulting mass of ones and zeros.</p>
<p>Perhaps this isn&rsquo;t that profound. Or maybe it&rsquo;s more profound than my attempt to talk about it shoes. I&rsquo;m sure I&rsquo;ll gain more insight about this phenomenon as time goes on.</p>
