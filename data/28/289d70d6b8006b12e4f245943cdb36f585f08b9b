<p>Sometimes I like to have a short function call to make a lookup table
with arbitrary keys and values. Something like this:</p>

<pre><code>(table "name" "Alice" "age" 42) =&gt; #&lt;TABLE ...&gt;
</code></pre>

<p>This is easy enough to define like so:</p>

<pre><code>(defun table (&amp;rest keys-and-values)
   ;;; loop over keys and values to construct a table
   ...)
</code></pre>

<p>But there&rsquo;s another option that works:</p>

<pre><code>(defun table (&amp;rest keys-and-values &amp;key &amp;allow-other-keys)
  ...)
</code></pre>

<p>This version has the advantage that missing arguments (e.g. <code>(table
"name")</code>) are caught at compile-time!</p>

<p>I&rsquo;ve been using this construct for a few years, but recently found out
about <a href="http://l1sp.org/cl/3.5.1.5">3.5.1.5</a>, which says:</p>

<blockquote>
  <p>It is not permitted to supply a keyword argument to a function using
  a name that is not a symbol.</p>
</blockquote>

<p>Yikes! That seems simple and straightforward: what I&rsquo;m doing is not
permitted. However! Every implementation I&rsquo;ve tried (only three,
admittedly) actually <em>allows</em> my not-symbol keywords without
complaint!</p>

<p>I&rsquo;m too old to think that &ldquo;it works everywhere today&rdquo; means &ldquo;it will
continue to work in SBCL tomorrow&rdquo;, so I&rsquo;m trying to figure out where
I stand. 3.5.1.5 also says this:</p>

<blockquote>
  <p>If this situation occurs in a safe call, an error of type
  program-error must be signaled unless keyword argument checking is
  suppressed as described in Section
  <a href="http://l1sp.org/cl/3.4.1.4.1">3.4.1.4.1</a> (Suppressing Keyword
  Argument Checking); and in an unsafe call the situation has
  undefined consequences.</p>
</blockquote>

<p>So does that mean my code is:</p>

<ul>
<li>a safe call with suppressed keyword argument checking?</li>
<li>&hellip;and is that good to use now and forever?</li>
<li>an unsafe call with undefined consequences?</li>
<li>something else?</li>
</ul>

<p>I know the same effect could be achieved with a compiler macro, but
I&rsquo;d like to know if I can use this simpler option safely.</p>