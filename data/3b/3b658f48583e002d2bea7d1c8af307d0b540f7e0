<p>This is the seventeenth post in the <a href="/blog/fastmail-advent-2024/">Fastmail Advent 2024</a> series. The previous post was <a href="/blog/offline-in-beta/">Dec 16: Offline support now in public beta</a>. The next post is <a href="/blog/offline-sync/">Dec 18: Building offline: syncing changes back to the server</a>.</p><p>Yesterday <a href="/blog/offline-in-beta/">we announced full offline support for Fastmail</a> is now available in public beta, both in our app and on the web. Today, and over the next few days, I’ll dive into some of the technical aspects about how we’re making this work.</p><p>Making Fastmail work offline has been our most popular feature request for some time (ever since <a href="/blog/more-swipe-options-on-mobile-let-you-work-faster/">we added support for custom swipe actions</a>, our previous top request!), and we wanted to make sure our support was done <em>right</em>. It should just work, seamlessly, and as far as possible you should be able to do everything you can do online. Open your calendar and update an event, perhaps inviting someone using autocomplete from your contacts. Search your mail and triage it. Write a new note. Add a memo. We want it all to <em>just work</em>.</p><p>When you come online it should seamlessly sync these changes back to the server, and fetch any new mail and other changes.</p><h2 id="general-architecture" tabindex="-1">General architecture</h2><p>The Fastmail app is very cleanly separated from our server, which was a huge benefit when adding offline support. All data in the app is loaded via a <a href="https://jmap.io/" target="_blank" rel="noopener">JMAP</a> API, with all UI rendering and routing happening in the app. This means the data flow looks a bit like this:</p><pre><code>[App] ← JMAP → [Server]
</code></pre><p>This gave us a really well defined boundary on which to build the offline support. If we built something that could handle and respond to the JMAP requests directly on your device then the app would work offline, and we wouldn’t really have to change anything else in it. So the architecture we came up with looks like this:</p><pre><code>[App] ← JMAP → [Caching layer] ← JMAP → [Server]
</code></pre><p>Looking at our new diagram, we can see that we are building two things:</p><ol> <li>A JMAP server that can understand the requests the client makes, fetch and write the data from/to a local store, and return a JMAP response.</li> <li>A JMAP client that can fetch data it doesn’t have from the server, and write back changes made while we were offline.</li> </ol><p>This is actually quite a lot harder than just building a JMAP server! We will often only have partial information, and we have to transparently pass through requests for data we don’t have to the server, and gracefully handle a fallback if we are offline.</p><p>The core function our caching layer needs to perform is handling a JMAP request from the client. Each JMAP request is a sequence of method calls. Once we have locally cached data, we may be able to handle the method call entirely locally, but we may always run into one or more that we can’t.</p><p>For performance, we want to batch our method calls into a single database transaction where possible. But we can’t hold open a transaction over a network request, so we divide up the execution into phases.</p><p>First, we attempt to execute the method calls locally. If all complete, we’re done! If any require us to fallback to the server, we stop and send it everything from that point on, as we want to avoid making multiple HTTP requests, which would be slow.</p><p>If the request completed successfully, we process the responses to save any new data into our local datastore. If the request failed, we call the offline fallback methods, which may be able to still return a response to the UI.</p><h2 id="a-separate-thread-for-the-caching-layer" tabindex="-1">A separate thread for the caching layer</h2><p>The caching layer runs on your device, just like the rest of the app. Because JMAP requests are already asynchronous network calls from the UI, we can easily run the caching layer in a separate OS thread so it never blocks the UI thread, which could cause <a href="https://en.wiktionary.org/wiki/jank" target="_blank" rel="noopener">jank</a>.</p><p>Our app is built using web technology, which allows us, as a small company, to build an app that runs everywhere our users are, with a single code base and feature parity across all platforms. Separate threads are represented as <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">workers</a> in the web API. There are three types of worker:</p><ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="noopener">Dedicated worker</a> — this is a worker that is tied to a particular window or tab in your browser. If you have Fastmail open in multiple tabs, each would have to create its own worker.</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">Shared worker</a> — this is a worker that’s shared between tabs or windows, so no matter how many you have there’s only a single instance of this worker.</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service worker</a> — this is a special type of shared worker that can intercept network requests and change their response.</li> </ul><p>At first glance, a service worker seems the place to handle all of this, and this is what we tried first. However, we soon switched over to using a shared worker instead:</p><ul> <li>The service worker is designed to be short lived and only spun up when needed, but we wanted to hold open a persistent <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">EventSource push connection</a> while the app is open, for instant updates. The shared worker is a better conceptual fit for this.</li> <li>We don’t need to intercept network requests, as we can just pass the JMAP request object directly to the worker using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" target="_blank" rel="noopener">postMessage</a> API, avoiding some serialisation overhead.</li> <li>We ran into a bug in iOS where network requests would sometimes not be intercepted even though the service worker was registered when the app was running in the background. This meant we <em>had</em> to pass the request directly to the worker anyway instead of intercepting it at the network level to ensure we didn’t hit this bug.</li> </ul><p>We wanted to use a shared worker rather than a dedicated worker for more efficiency when there were multiple tabs open — we can avoid some contention and locking issues, and ensure we have a single push connection open to the server.</p><h2 id="storing-data-indexed-db" tabindex="-1">Storing data: IndexedDB</h2><p>The web API for storing large volumes of structured data is <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a>. This lets you create multiple <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore" target="_blank" rel="noopener">object stores</a> (the equivalent of SQL tables), which offer simple key-value storage with ordered keys. Indexes can be automatically built based on properties in the object being stored. Transactions ensure data consistency.</p><p>The IndexedDB API was unfortunately designed just before promises became ubiquitous in the web world. This means just fetching a record from a store requires code a bit like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="keyword token">const</span> request <span class="operator token">=</span> store<span class="punctuation token">.</span><span class="function token">get</span><span class="punctuation token">(</span>id<span class="punctuation token">)</span><span class="punctuation token">;</span>
request<span class="punctuation token">.</span><span class="function function-variable token">onerror</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="function token">callErrorHandler</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
request<span class="punctuation token">.</span><span class="function function-variable token">onsuccess</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span>
    <span class="keyword token">const</span> record <span class="operator token">=</span> request<span class="punctuation token">.</span>result<span class="punctuation token">;</span>
    <span class="comment token">// Do something</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span></code></pre><p>This is clunky and becomes hard to read and follow. However, we wrote one tiny little wrapper function that converts it into a promise-based API:</p><pre class="language-javascript"><code class="language-javascript"><span class="keyword token">const</span> <span class="function function-variable token">_</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">request</span><span class="punctuation token">)</span> <span class="operator token">=></span>
    <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve<span class="punctuation token">,</span> reject</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span>
        request<span class="punctuation token">.</span><span class="function function-variable token">onsuccess</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="function token">resolve</span><span class="punctuation token">(</span>request<span class="punctuation token">.</span>result<span class="punctuation token">)</span><span class="punctuation token">;</span>
        request<span class="punctuation token">.</span><span class="function function-variable token">onerror</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="function token">reject</span><span class="punctuation token">(</span>request<span class="punctuation token">.</span>error<span class="punctuation token">)</span><span class="punctuation token">;</span>
    <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre><p>Using this function, we can rewrite the above fetch like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="keyword token">const</span> record <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">_</span><span class="punctuation token">(</span>store<span class="punctuation token">.</span><span class="function token">get</span><span class="punctuation token">(</span>id<span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="comment token">// Do something</span></code></pre><p>(Note, if the fetch has an error this will result in an exception being thrown, which is generally handled at a higher layer, so avoids that cluttering our code here at all!)</p><p>With this simple addition, I found the IndexedDB API consistent and easy to work with.</p><h2 id="the-standard-object-store-structure" tabindex="-1">The standard object store structure</h2><p>The consistency of JMAP means we can write one generic implementation and then use it to provide offline support for all our data types. For each data type (such as Calendar, Email, Contact, etc.) we create an object store to store the instances of that type.</p><p>When we create the object store we also store a single metadata object in it, using a special key (a zero-byte <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a>). This stores some important bookkeeping information, in particular the following properties:</p><pre class="language-javascript"><code class="language-javascript"><span class="comment token">// Do we have the full set of data from the server for this data</span>
<span class="comment token">// type?</span>
<span class="literal-property property token">hasAllRecords</span><span class="operator token">:</span> <span class="boolean token">false</span><span class="punctuation token">,</span>

<span class="comment token">// State string representing the current server state we have</span>
<span class="comment token">// synced with. The store may also contain newer information, but</span>
<span class="comment token">// that's ok as it will still get to the correct state when we</span>
<span class="comment token">// update from the old state.</span>
<span class="literal-property property token">serverState</span><span class="operator token">:</span> <span class="string token">''</span><span class="punctuation token">,</span>

<span class="comment token">// This is the highest modseq of a record in the store.</span>
<span class="literal-property property token">lastModSeq</span><span class="operator token">:</span> <span class="number token">0</span><span class="punctuation token">,</span>

<span class="comment token">// This is the highest modseq of a record that was destroyed that's</span>
<span class="comment token">// now been removed entirely from the store; we can only calculate</span>
<span class="comment token">// changes accurately from this point on.</span>
<span class="literal-property property token">highestPurgedModSeq</span><span class="operator token">:</span> <span class="number token">0</span><span class="punctuation token">,</span>

<span class="comment token">// This is the number of records currently marked destroyed in the</span>
<span class="comment token">// store. We keep them there so we can calculate changes. Once we</span>
<span class="comment token">// cross a threshold, we'll clean up old ones.</span>
<span class="literal-property property token">numDestroyed</span><span class="operator token">:</span> <span class="number token">0</span><span class="punctuation token">,</span></code></pre><p>A key concept here is <em>modseq</em>, which stands for “modification sequence”. It’s a counter we keep per account, per data type. Every time we make a change to a record in our local store we bump the sequence number and assign that as the new “updated” modseq for that record. We also store a “created” modseq on each record, which is the same as the “updated” modseq when the record is first created. These simple bookkeeping properties allow us to efficiently calculate changes, as needed for <a href="https://www.rfc-editor.org/rfc/rfc8620.html#section-5.2" target="_blank" rel="noopener">the JMAP “/changes” method</a>.</p><p>Aside from the metadata object, every other entry in the object store is a record — an instance of that data type.</p><p>The key for each record is <code>[account id, id]</code>, because some data types exist in multiple accounts (e.g. shared contacts and your personal contacts) and ids are only unique within an account. As far as I could see from inspecting the source, string keys are stored as <a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a> in all major IndexedDB implementations. This is a fairly inefficient encoding, especially as we know JMAP ids can only use the <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-5" target="_blank" rel="noopener">base64url characters</a>, so for efficiency we encode this data into an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a>, making use of this fact.</p><p>The value associated with the key is the record itself — an object representing an instance of that data type, as fetched from the server. In addition, we add a few bookkeeping properties, as discussed above:</p><ul> <li>The created modseq</li> <li>The updated modseq</li> <li>Is the record destroyed?</li> </ul><p>Each object store has an index built automatically based on the updated modseq of the records.</p><p>The modseq is used as the “state” string over JMAP. When asked for what’s changed since a particular state, we know:</p><ul> <li>Only records with a higher modseq have changed (which we can efficiently get from the index).</li> <li>If the record’s <code>created</code> modseq is higher than <code>lastModSeq</code>, it’s new. Otherwise it’s been updated or destroyed (depending on whether the record is now destroyed). If it’s new and also destroyed, we can ignore it entirely.</li> </ul><h2 id="next-up-local-changes" tabindex="-1">Next up, local changes</h2><p>In this post we looked at the basic overview of how our offline caching layer fits into our app, and the way it stores data to efficiently respond to JMAP requests. Tomorrow, we’ll dive into <a href="/blog/offline-sync/">how it keeps track of changes the user makes while offline</a>, so it can reconcile this with the server.</p>