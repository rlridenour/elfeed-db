<p>My job recently had a code golf challenge: the shortest code wins. The task was to write <a href="https://en.wikipedia.org/wiki/K-means_clustering">k-means</a>: take a set of data and reduce it to <em>k</em> points. There are many algorithms to do this, but the specific algorithm for this challenge was to, until you had few enough data points, find the two closest points and merge them. First, my winning 227-character entry:</p><pre><code class="code-arc">(def d(p q)(apply +(map(fn(m n)(expt(- m n)2))p q)))(def m(k s)(if(len&gt; s k)(m k(let(r t)(best(fn(p q)(&lt;(d p.0 p.1)(d q.0 q.1)))(apply join(map[map(fn(l)`(,_,l))(cdr(mem _ s))]s)))(cons(map(fn e avg.e)r t)(rem r(rem t s)))))s))</code></pre><p>Ok, that's unreadable. I get it. The code, as I started with it:</p><pre><code class="code-arc">(def distance (p1 p2)     (apply +            (map (fn (d1 d2)                     (expt (- d1 d2)                           2))                 p1                 p2)))(def k-means (k points)     (if (len&gt; points               k)         (k-means k                  (collapse-nearest points))       points))(def collapse-nearest (points)     (let (rem1 rem2) (closest points)          (cons (map (fn dimensions                         avg.dimensions)                     rem1                     rem2)                (rem rem1                     (rem rem2                          points)))))(def closest (points)     (best (fn (p1 p2)               (&lt; (distance p1.0 p1.1)                  (distance p2.0 p2.1)))           (cartesian points)))(def cartesian (elements)     (apply join            (map [map (fn (ele) (cons _ ele))                      (cdr (mem _                                elements))]                 elements)))</code></pre><p>To get from the readable code to the golfed code, I did some standard minification techniques: making all names one-character, inlining functions, and removing extra whitespace. Nothing too fancy.</p><h3>The good:</h3><ul><li>Minimal syntax in lisp. less whitespace needed. This leads to incredibly ugly, unreadable, but short code.</li><li>Arc's intra-symbol syntax. I only used one example: instead of writing <span class="code">(x y)</span> , Arc lets me write <span class="code">x.y</span> . This cuts down on the parentheses, so if the tokens before or after this function call were going to be parentheses anyway, I was able to drop one or two characters each time I used it.</li><li>Quasiquote replacement lets data objects be constructed concisely.</li><li>Anonymous functions are a giant win.</li><li>Arc-specific functions (or lisp ones): <span class="code">best</span>, <span class="code">len&gt;</span></li><li>Higher-order functions make the code work for any number of dimensions</li><li>A repl makes for really simple testing and development.</li></ul><h3>The bad:</h3><ul><li>Readability, obviously, dropped incredibly. The second-place entry was Python, but it was somewhat readable.</li><li>Why does <span class="code">avg</span> take a single argument: a list of nums? Seems like it should be variadic.</li><li>On lists, <span class="code">+</span> isn't join. It creates new conses. This is frustrating, and confusing:  <pre><code class="code-arc">arc&gt; (def check-cars (join-fun)          (let x (list (list 1))               (is (car (join-fun x))                   (car x))))#&lt;procedure: check-cars&gt;arc&gt; (check-cars +)nilarc&gt; (check-cars join)t</code></pre></li><li>Similarly, <span class="code">(mappend f seq)</span> isn't <span class="code">(apply join (map f seq))</span>, when <span class="code">f</span> returns lists.</li><li>If <span class="code">+</span> is similar to <span class="code">join</span> on lists, why not define <span class="code">(* seq1 seq2)</span> as the cartesian product of the two sequences, when seq1 is a list? It somewhat mirrors <span class="code">+</span>.</li></ul><h3>notes:</h3><ul><li>You don't have to calculate everything properly, as long as you get the results you want. My <span class="code">distance</span> function doesn't take the square root of the result. Because the distance between two points is only used is to compare two distances, you can compare the squared distances instead. The relationships are the same, which is all that matters.</li><li>I thought of no simple way to do this but functionally, using recursion. The second place winner, who wrote in Python, approached this imperitively, using mutable state. We actually had to explain our solutions to each other, as the minified versions were not easy to gather the algorithm from. Programming styles can be restrictive.</li></ul>