<h2 id="the-problem">The problem</h2>
<p>Clearing the screen on the terminal is quite finicky. The behaviour on some emulators (<a href="https://ghostty.org">Ghostty</a>, <a href="https://sw.kovidgoyal.net/kitty/">Kitty</a> &amp; co.) is massively different than say on <a href="https://iterm2.com">iTerm2</a> or the macOS built-in Terminal.app.</p>
<p>You see, I tend to use the command <code>clear</code>, which is aliased to <code>c</code> in my case. Now, I like to keep the <code>scrollback buffer</code> intact.</p>
<p>Using <code>clear</code>, the scrollback is only preserved so far by iTerm2 and the Terminal.app. In all the other emulators that I’ve tried so far, the scrollback gets cut off – from the bottom ¯\_(ツ)_/¯.</p>
<p>But listen&hellip; when I use <code>Ctrl+l</code> (<code>clear-screen</code>), I do not get the issue. But I want to keep using <code>c+return</code> because I am used to it. Stubbornness, I guess. I want what I want.</p>
<p>So how do I essentially bind <code>c+return</code> to <code>clear-screen</code> at the prompt?</p>
<h2 id="the-solution">The solution</h2>
<p>Turns out that one can create a function to call a readline command, and doing so circumvents a keybinding like <code>Ctrl+l</code>.</p>
<p><strong>Function:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">c_clear_screen<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$BUFFER</span> <span class="o">==</span> <span class="s2">&#34;c&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        zle clear-screen         <span class="c1"># Perform the clear-screen action</span>
</span></span><span class="line"><span class="cl">        <span class="nv">BUFFER</span><span class="o">=</span><span class="s2">&#34;&#34;</span>                <span class="c1"># Clear the input buffer (remove &#34;c&#34;)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        zle accept-line          <span class="c1"># Execute the default &#34;Return&#34; behavior</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Register the widget</span>
</span></span><span class="line"><span class="cl">zle -N c_clear_screen
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Bind &#34;Return&#34; to the custom function</span>
</span></span><span class="line"><span class="cl">bindkey <span class="s1">&#39;^M&#39;</span> c_clear_screen
</span></span></code></pre></div><p>The function is conditional since I don&rsquo;t want to trap <code>return</code> for all other commands.</p>
<p><strong>Extra mile:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">c</span><span class="o">=</span><span class="s1">&#39;true&#39;</span>
</span></span></code></pre></div><p>Since <code>c</code> is not recognised as a command, now plugins like <code>zsh-syntax-highlighting</code> get confused. The last little snippet in the <code>.zshrc</code> remediates this.</p>
<h2 id="the-conclusion">The conclusion</h2>
<p>There are a bunch of <a href="https://manpage.me/?readline">readline commands</a>. And for whatever reason – if you want to create a function, you can do this. Ain&rsquo;t that fantastic!?</p>
