<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy">Wikipedia</a> cites a few different sources on what &ldquo;Unix Philosophy&rdquo; is. Peter Salus summarizes it as:</p>
<blockquote>
<ul>
<li>Write programs that do one thing and do it well.</li>
<li>Write programs to work together.</li>
<li>Write programs to handle text streams, because that is a universal interface.</li>
</ul></blockquote>
<p>That second bullet point is my favorite: making <em>composable</em> programs rather than monolithic systems. In this way, Unix is designed to be a forge for easily building new tools. The first rule—writing programs that do one thing well—is largely a means to the second. When you have building blocks that take simple shapes, you can compose them easily like Lego pieces.</p>
<p>I think that second goal is what makes Unix win: instead of providing you with every tool under the sun, you get a set of composable tools that allow you to construct better tools perfectly tailored to your problem. No one hacking on a PDP-11 thought to make an easy way to publish a blog like this one, but they put the framework in place to let <em>me</em> put together the tools I need to deploy this very post with a single command.</p>
<h3 id="how-emacs-fits-inside-of-unix-philosophy">
  How Emacs fits inside of Unix philosophy
  <a class="anchor" href="#how-emacs-fits-inside-of-unix-philosophy">#</a>
</h3>
<p>One might argue that Emacs goes against Unix philosophy, for it can quite literally do pretty much everything. But that only violates the first rule—if you consider Emacs to be a tool forge, then Emacs is quite in line with the Unix philosophy. Emacs provides functions that all work on the buffer or bits of text, and these can all be composed to craft a work environment to fit your needs. <a href="https://git.sr.ht/~ashton314/.dotfiles">I use</a> over 100 different packages, and they all play nice together!</p>
<div class="marginnote">
<p>Emacs once ran Germany&rsquo;s flight control software (<a href="https://www.reddit.com/r/emacs/comments/lly7po/comment/gnvzisy">source</a>). Please don&rsquo;t try this at home.</p>
</div>
<p>I have come to view Emacs as my primary forge. It&rsquo;s my layer on top of Unix, if you will. If I have Emacs customized how I like it, it doesn&rsquo;t matter too much what operating system lives underneath: I can get a lot of work done. I used to view Emacs just as a tool, and I used it exclusively as a text editor. As time went on, though, I began to value the extreme keyboard-centric control Emacs gave me over my system. That&rsquo;s why I <a href="https://lambdaland.org/posts/2020-07-22-gui-emacs/">moved from the terminal to the GUI</a> version of Emacs: I wanted to have more modifiers available to bind functions to.</p>
<p>Many people use Emacs exclusively as a text editor, and that&rsquo;s fine. Usually these people have gotten comfortable with the command line, which is just another kind of tool forge. The great thing is both places make building new tools easy. Whatever your toolkit (though I do recommend you add Emacs to it if it&rsquo;s not already there!) make sure you can build new tools with ease.</p>
<h2 id="further-reading">
  Further Reading
  <a class="anchor" href="#further-reading">#</a>
</h2>
<ul>
<li><a href="https://news.ycombinator.com/item?id=33522735">Discussion on Hacker News</a></li>
<li>A kind chap sent me a link to <a href="https://tilde.town/~ramin_hal9001/articles/emacs-fulfills-the-unix-philosophy.html">this blog post</a> as well as <a href="https://amodernist.com/texts/emacs-unix.html">their own thoughts</a>, which seemed like good things to link to.</li>
</ul>
