<p>[Equations in this post may not look right (or appear at all) in your RSS reader. Go to <a href="https://leancrew.com/all-this/2025/05/random-points-without-rejection/">the original article</a> to see them rendered properly.]</p>
  <hr />
  <p>A few days ago, John D. Cook wrote a post about <a href="https://www.johndcook.com/blog/2025/05/06/random-points-on-a-sphere/">generating random points on the surface of a sphere</a>. His approach was:</p>
<ol>
<li>Generate three independent uniformly distributed random variables in the range from <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>−</mi><mi>R</mi></mrow></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>+</mi><mi>R</mi></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi></math> is the radius of the sphere. These will represent a point in <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> space.</li>
<li>Calculate <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math> such that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>S</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup></math></li>
<li>If <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><mo>&gt;</mo><mi>R</mi></mrow></math>, which means the point is outside the sphere, reject the point and go back to Step 1.</li>
<li><p>Otherwise, return the point</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mo form="prefix" stretchy="true">(</mo><mspace width="0.167em"></mspace><mfrac><mi>x</mi><mi>S</mi></mfrac><mo>,</mo><mspace width="0.278em"></mspace><mfrac><mi>y</mi><mi>S</mi></mfrac><mo>,</mo><mspace width="0.278em"></mspace><mfrac><mi>z</mi><mi>S</mi></mfrac><mspace width="0.167em"></mspace><mo form="postfix" stretchy="true">)</mo></math>
<p>which is a projection of the point out onto the surface of the sphere.</p></li>
</ol>
<p>This works, of course, but you reject nearly half of the points you generate. All the points are in a cube of volume <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>8</mn><msup><mi>R</mi><mn>3</mn></msup></mrow></math>, but you’re keeping only those in a sphere of volume <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mn>4</mn><mn>3</mn></mfrac><mi>π</mi><msup><mi>R</mi><mn>3</mn></msup><mo>≈</mo><mn>4.19</mn><msup><mi>R</mi><mn>3</mn></msup></mrow></math></p>
<p>I wanted to come up with a way to generate points directly on the sphere without any rejections or projections. To start, I decided to reduce the problem by one dimension and think about circles.</p>
<p>Generating random points around the circumference of a circle is pretty easy. Just generate a series of uniformly distributed random variables from <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn><mi>π</mi></mrow></math> and treat them as angles, <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>θ</mi><mi>i</mi></msub></math>. Then the points <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo form="prefix" stretchy="false">(</mo><mi>R</mi><mo>,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></math> will be distributed around the circumference. Like this:</p>
<p><img alt="Random points on circle border" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Random%20points%20on%20circle%20border.png" title="Random points on circle border" width="80%"/></p>
<p>This is 500 points, and there are some gaps and clumps because that’s the nature of random number generation. But there’s no bias to the distribution of points.</p>
<p>Now let’s generate points within the circle. A naive way to go about this would be to generate values uniformly distributed between <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn><mi>π</mi></mrow></math> for the angle, as before, and to generate values uniformly distributed between <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi></math> for the radius. But if we do that, we’ll get a point cloud of <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo form="prefix" stretchy="false">(</mo><msub><mi>r</mi><mi>i</mi></msub><mo>,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></math> pairs that looks like this:</p>
<p><img alt="Random points in circle-uniform" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Random%20points%20in%20circle-uniform.png" title="Random points in circle-uniform" width="80%"/></p>
<p>Definitely biased toward the center of the circle.</p>
<p>Why did this happen? Consider this polar grid:</p>
<p><img alt="Polar grid" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Polar%20grid.png" title="Polar grid" width="80%"/></p>
<p>If we generate uniformly distributed <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>r</mi><mi>i</mi></msub></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>θ</mi><mi>i</mi></msub></math>, all the sectors in the grid will have about the same number of points. But because the sectors near the center are smaller, the points will be denser in those sectors and sparser in the sectors further out. Which is exactly what we see in the naive point cloud.</p>
<p>The size of the sectors grows linearly with <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math>, so we need to generate the <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>r</mi><mi>i</mi></msub></math> using a distribution that grows linearly with <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math>. That would be a <a href="https://mathworld.wolfram.com/TriangularDistribution.html">triangular distribution</a> with a <a href="https://mathworld.wolfram.com/ProbabilityDensityFunction.html">probability density function</a> that looks like this (for <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><mo>=</mo><mn>5</mn></mrow></math>):</p>
<p><img alt="PDF of triangular distribution" class="ss" src="https://leancrew.com/all-this/images2025/20250509-PDF%20of%20triangular%20distribution.pdf" title="PDF of triangular distribution" width="80%"/></p>
<p>The peak value of the PDF is <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mn>2</mn><mi>R</mi></mfrac></math> because the area under the PDF must be one.</p>
<p>Many math software packages have functions for generating random variables with a triangular distribution. Using that distribution instead of a uniform distribution for generating the <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>r</mi><mi>i</mi></msub></math> will give us a set of <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo form="prefix" stretchy="false">(</mo><msub><mi>r</mi><mi>i</mi></msub><mo>,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></math> that’s uniformly spread over the interior area of the circle:</p>
<p><img alt="Random points in circle-triangular" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Random%20points%20in%20circle-triangular.png" title="Random points in circle-triangular" width="80%"/></p>
<p>How did I know to use a triangular distribution for <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math>? The polar grid certainly shows that we need to generate more large <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math> values than small ones, but how did I know that a PDF with linear growth was the one to use? There are, I suppose, many ways to think about the problem, but I thought of it in terms of the <a href="https://mathworld.wolfram.com/Jacobian.html">Jacobian</a>, a topic you typically learn about in a multivariable calculus class.</p>
<p>We know that in Cartesian coordinates, a differential area element is the product of the two differential linear elements:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mi>A</mi><mo>=</mo><mi>d</mi><mi>x</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>y</mi></math>
<p>But in polar coordinates, the expression for differential area is a little more complicated:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mi>A</mi><mo>=</mo><mi>r</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>θ</mi></math>
<p>We can get this expression by considering the equations that convert between polar and Cartesian coordinates:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>x</mi><mo>=</mo><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>y</mi><mo>=</mo><mi>r</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr></mtable></math>
<p>The differentials are</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>d</mi><mi>x</mi><mo>=</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>r</mi><mo>−</mo><mi>r</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>d</mi><mi>y</mi><mo>=</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>r</mi><mo>+</mo><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable></math>
<p>which can also be expressed in matrix form:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo form="prefix" stretchy="true">{</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>x</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>y</mi></mtd></mtr></mtable><mo form="postfix" stretchy="true">}</mo></mrow><mo>=</mo><mrow><mo form="prefix" stretchy="true">[</mo><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>−</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr></mtable><mo form="postfix" stretchy="true">]</mo></mrow><mrow><mo form="prefix" stretchy="true">{</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>r</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>θ</mi></mtd></mtr></mtable><mo form="postfix" stretchy="true">}</mo></mrow></mrow></math>
<p>The determinant of the matrix (called the Jacobian) represents the ratio of the differential areas expressed in the two coordinate systems:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mi>x</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>y</mi><mo>=</mo><mrow><mo form="prefix" stretchy="true">|</mo><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>−</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr></mtable><mo form="postfix" stretchy="true">|</mo></mrow><mspace width="0.278em"></mspace><mi>d</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>θ</mi><mo>=</mo><mi>r</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>θ</mi></mrow></math>
<p>That <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math> in the expression tells us that we need to scale linearly with <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math>. Hence the triangular PDF with the shape given above.</p>
<p>OK, now it’s time to move from circles to spheres. Here’s our coordinate system:</p>
<p><img alt="Spherical coordinates" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Spherical%20coordinates.png" title="Spherical coordinates" width="80%"/></p>
<p>There are different ways to define the two angles. I’ve chosen a system where <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>θ</mi></math> is like longitude and <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>ϕ</mi></math> is like latitude. The relationship between the Cartesian and spherical coordinates is this:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>x</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>z</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>r</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi></mtd></mtr></mtable></math>
<p>Which means the differential relationship is</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo form="prefix" stretchy="true">{</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>x</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>z</mi></mtd></mtr></mtable><mo form="postfix" stretchy="true">}</mo></mrow><mo>=</mo><mrow><mo form="prefix" stretchy="true">[</mo><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>−</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>−</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>c</mi><mi>o</mi><mi>s</mi><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>−</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi></mtd><mtd columnalign="right" style="text-align: right"><mn>0</mn></mtd><mtd columnalign="right" style="text-align: right"><mi>r</mi><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi></mtd></mtr></mtable><mo form="postfix" stretchy="true">]</mo></mrow><mspace width="0.167em"></mspace><mrow><mo form="prefix" stretchy="true">{</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>r</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>θ</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mi>ϕ</mi></mtd></mtr></mtable><mo form="postfix" stretchy="true">}</mo></mrow></mrow></math>
<p>The determinant has lots of trig cancelation, and we end up with</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mi>V</mi><mo>=</mo><mi>d</mi><mi>x</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>y</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>z</mi><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>r</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>θ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>ϕ</mi></math>
<p>as the relationship between differential volumes in the two coordinate systems.</p>
<p>Of course, we’re interested in surface area, not volume, but this analysis is still helpful. To get the differential surface area in spherical coordinates, we drop the <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mi>r</mi></mrow></math> and set <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>r</mi><mo>=</mo><mi>R</mi></mrow></math>:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mi>A</mi><mo>=</mo><msup><mi>R</mi><mn>2</mn></msup><mspace width="0.167em"></mspace><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>θ</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>ϕ</mi></math>
<p>So to get points on a sphere’s surface that are uniformly distributed over the area, <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>θ</mi></math> is drawn from a uniform distribution from <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>−</mi><mi>π</mi></mrow></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>π</mi></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>ϕ</mi></math> is drawn from a distribution whose PDF follows a cosine curve from <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>−</mi><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow></math> to <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mi>π</mi><mn>2</mn></mfrac></math>:</p>
<p><img alt="Latitude PDF" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Latitude%20PDF.png" title="Latitude PDF" width="80%"/></p>
<p>To make this a legitimate PDF, the cosine has been scaled so the integral under the curve is one:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>ϕ</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi></mrow><mn>2</mn></mfrac></math>
<p>Unfortunately, this kind of distribution isn’t common. I don’t know of any math packages that include functions for a cosine distribution. No matter. There’s a procedure for generating random numbers from <em>any</em> distribution. We start by integrating the PDF to get the <a href="https://mathworld.wolfram.com/DistributionFunction.html">cumulative distribution function</a>:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo form="prefix" stretchy="false">(</mo><mi>ϕ</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mo>∫</mo><mfrac><mrow><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi></mrow><mn>2</mn></mfrac><mi>d</mi><mi>ϕ</mi><mo>=</mo><mfrac><mrow><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mi>C</mi></math>
<p>The constant of integration, <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math>, is determined by noting that <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>=</mo><mn>0</mn></mrow></math> at <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>ϕ</mi><mo>=</mo><mi>−</mi><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow></math>. That means <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></math> and</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo form="prefix" stretchy="false">(</mo><mi>ϕ</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi></mrow><mn>2</mn></mfrac></math>
<p>which looks like this:</p>
<p><img alt="Latitude CDF" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Latitude%20CDF.png" title="Latitude CDF" width="80%"/></p>
<p>Here’s the trick: CDFs always have a range from zero to one. So if we generate random numbers that are uniformly distributed from zero to one—which is the most common random number generator—and run them through the inverse of the CDF, we’ll get random numbers with the distribution of interest. In this case,</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>F</mi><mrow><mi>−</mi><mn>1</mn></mrow></msup><mo form="prefix" stretchy="false">(</mo><mi>u</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mi>sin</mi><msup><mi></mi><mrow><mi>−</mi><mn>1</mn></mrow></msup><mo form="prefix" stretchy="false">(</mo><mn>2</mn><mi>u</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></math>
<p>Here’s the Mathematica code for generating a list of 5000 random points on the surface of a sphere of radius 5:</p>
<pre><code>n = 5000;
R = 5;
\[Phi] = ArcSin[2*RandomReal[1, n] - 1];
\[Theta] = RandomReal[{-Pi, Pi}, n];
</code></pre>
<p>And here’s the conversion to Cartesian coordinates:</p>
<pre><code>x = R Cos[\[Phi]] Cos[\[Theta]] ;
y = R Cos[\[Phi]] Sin[\[Theta]];
z = R Sin[\[Phi]];
</code></pre>
<p>It actually looks nicer in a Mathematica notebook because the Greek letters are rendered properly:</p>
<p><img alt="Mathematica screenshot" class="ss" src="https://leancrew.com/all-this/images2025/20250510-Mathematica%20screenshot.png" title="Mathematica screenshot" width="70%"/></p>
<p>I did this in Mathematica to give me practice. Python code would be similar using <a href="https://numpy.org/">NumPy</a>.</p>
<p>Here’s the plot of the randomly generated points:</p>
<p><img alt="Random points on sphere surface" class="ss" src="https://leancrew.com/all-this/images2025/20250509-Random%20points%20on%20sphere%20surface.png" title="Random points on sphere surface" width="80%"/></p>
<p>It may not be obvious that the points are on the sphere’s surface. Here’s a video of the point cloud rotating slowly. If you look carefully, you’ll see clumps of points moving from the front surface to the rear and vice versa. There are no points within the sphere to block your view.</p>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="449" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/jK6hda48RIw?si=PLriRGtL1zpcJZ4H" title="YouTube video player" width="450"></iframe>
<p>Is this a better approach than Cook’s rejection/projection method? I guess that depends on your definition of <em>better</em>. To me, this is a cleaner approach because we’re generating the points on the sphere directly. But random number generation is an inherently numerical procedure, which means efficiency can’t be overlooked. Even though Cook is generating three random numbers for every two I generate—and then thows away nearly half of them—I suspect the simpler numerics of his method will win out. My technique uses a handful of trig functions, whereas his most complicated function is the square root.</p>
<p>But it was a fun problem to think about, and it’s the first time I’ve animated a graph in Mathematica.</p>
  
