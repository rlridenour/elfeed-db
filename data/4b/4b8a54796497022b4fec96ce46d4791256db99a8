
         
         <p><code class="language-plaintext highlighter-rouge">beframe</code> enables a frame-oriented Emacs workflow where each frame has
access only to the list of buffers visited therein. In the interest of
brevity, we call buffers that belong to frames “beframed”.</p>

<ul>
  <li>Package name (GNU ELPA): <code class="language-plaintext highlighter-rouge">beframe</code></li>
  <li>Official manual: <a href="https://protesilaos.com/emacs/beframe">https://protesilaos.com/emacs/beframe</a></li>
  <li>Change log: <a href="https://protesilaos.com/emacs/beframe-changelog">https://protesilaos.com/emacs/beframe-changelog</a></li>
  <li>Git repositories:
    <ul>
      <li>GitHub: <a href="https://github.com/protesilaos/beframe">https://github.com/protesilaos/beframe</a></li>
      <li>GitLab: <a href="https://gitlab.com/protesilaos/beframe">https://gitlab.com/protesilaos/beframe</a></li>
    </ul>
  </li>
  <li>Video demo: <a href="https://protesilaos.com/codelog/2023-02-28-emacs-beframe-demo/">https://protesilaos.com/codelog/2023-02-28-emacs-beframe-demo/</a></li>
  <li>Backronym: Buffers Encapsulated in Frames Realise Advanced
Management of Emacs.</li>
</ul>

<p>Below are the release notes</p>

<hr />

<h2>Version 1.3.0 on 2025-01-24</h2>

<p>This version contains quality-of-life refinements to an already stable
package.</p>

<h3>Make frame names unique, if needed</h3>

<p>We provide the user option <code class="language-plaintext highlighter-rouge">beframe-rename-function</code>, which will be
called with the new frame when <code class="language-plaintext highlighter-rouge">beframe-mode</code> is enabled. The idea is
to automatically apply a helpful name to the frame that was created.
The default function we use is <code class="language-plaintext highlighter-rouge">beframe-rename-frame</code>, which will do
the right thing to get a suitable name. To make this even more robust,
we now disambiguate equal frame names by appending a number to their
name. So instead of having two or more frames all named <code class="language-plaintext highlighter-rouge">hello</code>, you
get <code class="language-plaintext highlighter-rouge">hello</code>, <code class="language-plaintext highlighter-rouge">hello&lt;2&gt;</code>, and so on.</p>

<p>Thanks to Vedang Manerikar for the original contribution in pull
request 12: <a href="https://github.com/protesilaos/beframe/pull/12">https://github.com/protesilaos/beframe/pull/12</a>. The
change is within the ~15-line limit, meaning that Vedang does not need
to assign copyright to the Free Software Foundation (though I believe
the paperwork is done anyway). I made some further changes on top.</p>

<p>Remember that you can make certain commands automatically generate a
frame and run therein by adding them to the list of <code class="language-plaintext highlighter-rouge">beframe-functions-in-frames</code>.
A common use-case is to do this for switching to a new project, hence:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">setq</span> <span class="nv">beframe-functions-in-frames</span> <span class="o">'</span><span class="p">(</span><span class="nv">project-prompt-project-dir</span><span class="p">))</span>
</code></pre></div></div>

<h3>Use the optional <code class="language-plaintext highlighter-rouge">beframe-transient</code> instead of the prefix key map</h3>

<p>We provide a regular prefix key map where Beframe commands are bound
to. Users can access all the commands via a prefix key, such as with:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">define-key</span> <span class="nv">global-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">"C-c b"</span><span class="p">)</span> <span class="nf">#'</span><span class="nv">beframe-prefix-map</span><span class="p">)</span>
</code></pre></div></div>

<p>Users who prefer a more graphical interface can instead rely on the
new <code class="language-plaintext highlighter-rouge">beframe-transient</code>. It is the same principle as the prefix key
map:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">define-key</span> <span class="nv">global-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">"C-c b"</span><span class="p">)</span> <span class="nf">#'</span><span class="nv">beframe-transient</span><span class="p">)</span>
</code></pre></div></div>

<p>[ The difference between the two interfaces is small when using the
  <code class="language-plaintext highlighter-rouge">which-key</code> package. ]</p>

<h3>The buffer prompt clarifies that it is “Beframed”</h3>

<p>While using the <code class="language-plaintext highlighter-rouge">beframe-mode</code>, the standard <code class="language-plaintext highlighter-rouge">read-buffer-function</code> is
set to a Beframe function that prompts for a buffer. The idea is to
filter the list of buffers to only show those that are specific to the
current/given frame. To make this more clear, the text of the prompt
now has <code class="language-plaintext highlighter-rouge">[Beframed]</code> prepended to it.</p>

<p>I do not think we need a user option for this, though I am happy to
reconsider if there is a good reason for it.</p>

<h3>Miscellaneous</h3>

<ul>
  <li>
    <p>Fixed the function aliases of the “assume” and “unassume” commands
that take a regular expression as input to perform their operation.
The old aliases where written in the wrong way, such that they were
rendering the original function void.</p>
  </li>
  <li>
    <p>Bound a few more commands to the <code class="language-plaintext highlighter-rouge">beframe-prefix-map</code>. Everything
should now be there, to improve discoverability (remember that <code class="language-plaintext highlighter-rouge">C-h</code>
after an incomplete key sequence will produce a Help buffer that
lists all the keys+commands which extend the given key sequence).</p>
  </li>
  <li>
    <p>The name of the <code class="language-plaintext highlighter-rouge">beframe-buffer-menu</code> buffer is more descriptive.
The command <code class="language-plaintext highlighter-rouge">beframe-buffer-menu</code> puts the beframed list of buffers
in a buffer. Its old naming scheme was <code class="language-plaintext highlighter-rouge">*Buffer list for NAME*</code>,
where <code class="language-plaintext highlighter-rouge">NAME</code> is the name of the frame. Whereas now it is <code class="language-plaintext highlighter-rouge">*Buffer
  list for ‘NAME’ frame*</code>.</p>
  </li>
  <li>
    <p>Same as above for the frame-specific scratch buffers. Those are
generated for new frames when <code class="language-plaintext highlighter-rouge">beframe-create-frame-scratch-buffer</code>
is non-nil (the default) and <code class="language-plaintext highlighter-rouge">beframe-mode</code> is enabled.</p>
  </li>
</ul>
        
      