<p>With Emacs <code>eshell</code>, you can redirect the standard output of shell programs into buffers:</p>

<pre><code>echo "foo" &gt; #&lt;buffer my-buffer-name&gt;
</code></pre>

<p>That will use existing buffers and create new buffers as needed. For me, the new buffers would not be switched to automatically, but created in the background.</p>

<p>You don’t pipe into a buffer function, but redirect the output like you’d redirect file output. Instead of a file on disk, you specify a buffer with the special form:</p>

<pre><code>#&lt;buffer ...&gt;
</code></pre>

<p>This is the form you will see when you evaluate <code>(current-buffer)</code> and the buffer is converted to a string. So you may be used to reading, but not typing it.</p>

<h2 id="redirect-output-to-new-buffer-and-show-it">Redirect Output to New Buffer and Show It</h2>

<p>Writing and remembering that weird buffer naming form is not my cup of tea. And I usually want to see the result immediately. So here’s an alternative.</p>

<p>Redirecting the output also works similar to <code>(insert)</code>ing text into buffers. So you can redirect output to a buffer that is being returned from a function.</p>

<p>The <code>new-buffer</code> function name is not taken, so to make typing easier, I use that. Be advised that you should consider prefixing function names, though. I’ll personally take the risk.</p>

<p>This function will generate a new buffer called “untitled” – and thanks to <code>generate-new-buffer</code> will make sure to use an unused buffer name by appending “&lt;1&gt;”, “&lt;2&gt;”, … –, and switch to it immediately:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">new-buffer</span> <span class="p">()</span>
  <span class="s">"Create and switch to new empty buffer named “untitled”, “untitled&lt;2&gt;”, etc."</span>
  <span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nv">generate-new-buffer</span> <span class="s">"untitled"</span><span class="p">)))</span>
</code></pre></div></div>

<p>Then use it like this in eshell:</p>

<pre><code>echo "test" &gt; (new-buffer)
</code></pre>

<p>I still intuitively want to use <code>|</code> instead of <code>&gt;</code> to pipe to a function, not redirect the output, but that doesn’ work. You need to call the function to get the buffer object. Ah well; I still like it better than having to type the <code>#&lt;buffer ...&gt;</code> thing and type the buffer name, too!</p>

<h2 id="consider-using-shell-command">Consider using <code>shell-command</code></h2>

<p>All of this makes sense if you’re in an <code>eshell</code> anyway, or craft complicated program pipes.</p>

<p>If you just want to execute a program once, and then get the output into a buffer, you can instead use the <code>shell-command</code> or <code>async-shell-command</code> that do exactly that.</p>

<hr><p><small><a href="https://christiantietze.de/hire-me/">Hire me</a> for freelance macOS/iOS work and consulting.</small></p><p><small><a href="https://christiantietze.de/apps/">Buy</a> my apps.</small></p><p><small><a href="https://christiantietze.de/newsletter/">Receive</a> new posts via email.</small></p>