<p>
There are many arguments about the virtues and vices of functional programming.
But it can be difficult to find an agreed upon meaning of the phrase.
Here, I want to explore some of the most common characteristics of functional programming that I've seen floating around, and discuss each of them in turn, with the ultimate question in mind: how much should we care about them?
In particular, I want to see if there's really an argument to be made for preferring these characteristics absolutely over competing ones, if they are useful at all.
</p>
<div id="outline-container-org0a7cbf4" class="outline-3">
<h3 id="org0a7cbf4">TLDR<sub>0</sub></h3>
<div class="outline-text-3" id="text-org0a7cbf4">
<p>
I want to know what functional programming is, and if it's a good thing.
</p>

<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0bd9656">Programming with Functions</a></li>
<li><a href="#orgfd89a20">No Side Effects</a></li>
<li><a href="#org4e91076">Immutable Data</a></li>
<li><a href="#orgc4a6c4b">Pure Functions</a></li>
<li><a href="#org0c70bab">Conclusion</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org0bd9656" class="outline-2">
<h2 id="org0bd9656">Programming with Functions</h2>
<div class="outline-text-2" id="text-org0bd9656">
<p>
One of the oldest and most popular understandings of functional programming is that it's, well, programming with functions!
</p>

<blockquote>
<p>
In computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions.
</p>

<p>
&#x2014;Wikipedia
</p>
</blockquote>

<p>
Of course this statement is worthless on its own, as all computer programming "paradigms" with names involve applying and composing functions.
Instead, the key idea is to treat functions as proper data objects.
That is, as things that can be bound to variables, passed as arguments to other functions, and returned as values from other functions.
This is called treating <b>functions as first-class citizens</b>, and is the first real innovation in the tradition that would come to be known as functional programming, when it was first introduced by Lisp at MIT starting in the late 1950s.
</p>
</div>
<div id="outline-container-org6fdf3fa" class="outline-3">
<h3 id="org6fdf3fa">Functions as First-Class Citizens</h3>
<div class="outline-text-3" id="text-org6fdf3fa">
<p>
However, treating functions as first class citizens, like "programming with functions", is too broad!
There are two questions one could ask:
</p>

<ol class="org-ol">
<li>Am I <i>able</i> to treat functions as first-class citizens?</li>
<li>Do I <i>want</i> to treat functions as first-class citizens?</li>
</ol>
</div>
<div id="outline-container-org76fbb45" class="outline-4">
<h4 id="org76fbb45">Power</h4>
<div class="outline-text-4" id="text-org76fbb45">
<p>
For (1), the answer is entirely determined by the programming language one is using.
Although it was a novelty 60 years ago, many programming languages which are widely considered to be <i>not</i> functional have support for first class functions.
So while affirming (1) is almost certainly a necessary condition for functional programming, it is not sufficient.
</p>
</div>
</div>
<div id="outline-container-org7c91773" class="outline-4">
<h4 id="org7c91773">Desire</h4>
<div class="outline-text-4" id="text-org7c91773">
<p>
Perhaps then functional programming is about absolutely affirming (2).
To be doing functional programming is to be <i>always</i> either binding a function to a variable, or calling a function which returns a function, or passing a function in as an argument to another function, or some combination thereof.
But this is of course ridiculous, as there are many other things you do while programming which involve none of these things, even in the most pure functional programming languages.
The most obvious ones being either binding a non-function value to a variable, or returning a non-function value from a function.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<p>
All that's left then is not to affirm (2) absolutely, but rather <b>conditionally</b>.
That is, to be doing functional programming is to sometimes treat functions as values (including using a language which facilitates such).
But this is another widely held belief, which is evidenced by the widespread adoption of the capability at the language level in more recent years, again even in languages which are considered to be not functional, and utilized by those who don't consider themselves to be doing anything like "functional programming".
</p>
</div>
</div>
</div>
<div id="outline-container-org7b322d2" class="outline-3">
<h3 id="org7b322d2">TLDR<sub>1</sub></h3>
<div class="outline-text-3" id="text-org7b322d2">
<p>
Functional Programming as "<i>treating functions as first class citizens</i>" is at best something which is sometimes useful to do, and is a non-controversial practice.
</p>
</div>
</div>
</div>
<div id="outline-container-orgfd89a20" class="outline-2">
<h2 id="orgfd89a20">No Side Effects</h2>
<div class="outline-text-2" id="text-orgfd89a20">
<p>
Perhaps the most popular (yet least interesting) description of functional programming is that it is programming without side effects.
Here a "side effect", which should just be called an effect, is anything that a piece of code causes to happen.
Since the point of writing computer programs is to cause computers to do things, trying to write a computer program which does nothing is all but nonsensical.
I think that is enough that needs to be said about this idea, but since it is so widely discussed, I will say more.
</p>
</div>
<div id="outline-container-org6625b91" class="outline-3">
<h3 id="org6625b91">Alternatives</h3>
<div class="outline-text-3" id="text-org6625b91">
<p>
There is one slightly more reasonable, and two much more reasonable, opinions which people often mean when they talk about no side effects:
</p>

<ol class="org-ol">
<li>There are no references to side effects in the language specification
<ul class="org-ul">
<li>An implementation of that language may perform side effects when it processes certain expressions</li>
</ul></li>
<li>Side effects are dangerous and so we should be careful about how we use them</li>
<li>All data structures in the language are immutable</li>
</ol>

<p>
I will discuss (3) in the <a href="#org4e91076">next section.</a>
</p>
</div>
<div id="outline-container-org8f7298b" class="outline-4">
<h4 id="org8f7298b">Language Specification</h4>
<div class="outline-text-4" id="text-org8f7298b">
<p>
As for (1), it's hard for me to imagine why anyone would care about this.
All programs are free from side effects in the abstract, and all programs have side effects in reality when run on a computer.
The fact that a programming language spec doesn't allow you to express the idea of an effect doesn't change either of these facts.
You still have to deal with side effects when you actually run it, and you can still ignore side effects when abstractly reasoning about it.
There are perhaps some intellectually interesting properties of languages which don't reference side effects, but here I am discussing functional <i>programming</i> as a <b>paradigm</b>, not functional programming <i>language theory</i>.
</p>
</div>
</div>
<div id="outline-container-orgacc0f89" class="outline-4">
<h4 id="orgacc0f89">Caution</h4>
<div class="outline-text-4" id="text-orgacc0f89">
<p>
Finally for (2), this seems very reasonable, but again has become a widely held belief amongst programmers in general, not just functional advocates.
However here I do believe that there is still a gap, as the ramifications of <b>undisciplined</b> employment of effectful procedures is sometimes not fully appreciated by those with no exposure to functional programming.
</p>
</div>
</div>
</div>
<div id="outline-container-org3119b2e" class="outline-3">
<h3 id="org3119b2e">TLDR<sub>2</sub></h3>
<div class="outline-text-3" id="text-org3119b2e">
<p>
Functional programming as "<i>programming without side effects</i>" is nonsense, but recognizing the dangers of side effects is helpful, which is mostly non-controversial.
</p>
</div>
</div>
</div>
<div id="outline-container-org4e91076" class="outline-2">
<h2 id="org4e91076">Immutable Data</h2>
<div class="outline-text-2" id="text-org4e91076">
<p>
We have now arrived at what I consider to be the most reasonable and important sense in which functional programming is worth talking about.
The absolutist version of the idea is simple: <b>you should never mutate data</b>.
This usually means that the programming language itself should support this by offering no primitives for mutation, thus making all data structures immutable.
</p>

<p>
This is a genuinely controversial idea which actually has the promise of being worthwhile, as it is already the case in a few programming languages.
The only widely used languages for general purpose programming with this quality that I am aware of are Haskell and Erlang/Elixir.
</p>

<p>
The most obvious benefit of this is that it is easier to reason about code when you don't have to worry about the "current" state of any internal data.
</p>

<blockquote>
<p>
When I'm sitting down to do what I consider serious programming, it's still in C++, and it's really kind of a C flavored C++ at that. <br />
&#x2026; <br />
There is a lot of value [in functional programming] in the way you think about things&#x2026; the value that comes out of not having this random mutable state that you kind of lose track of.
</p>

<p>
&#x2014;John Carmack
</p>
</blockquote>
</div>
<div id="outline-container-org8be2a8a" class="outline-3">
<h3 id="org8be2a8a">The Rub</h3>
<div class="outline-text-3" id="text-org8be2a8a">
<p>
There are minor potential downsides, such as performance, which I won't discuss here.
Rather, I wish to discuss what I see as the only candidate for a fundamental downside.
</p>

<p>
When we write computer programs, we often want to model some part of the world.
Since part of our goal when writing computer programs is <i>always</i> to change the state of the world, it often seems useful to reify those mutable parts of the world in our program.
And the fact that they are mutable is not an incidental property we can ignore, but essential to the problem at hand.<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<p>
So it seems that we <b>lose a kind of expressive power with immutable data structures</b>.
This is especially evident in areas such as  graphical programming, where it can be difficult to imagine not modeling graphical objects as those with states that change over time.
But even here there has been work to come up with functional paradigms, albeit with no obvious grand success of which I am aware.
</p>
</div>
</div>
<div id="outline-container-org7b6b288" class="outline-3">
<h3 id="org7b6b288">TLDR<sub>3</sub></h3>
<div class="outline-text-3" id="text-org7b6b288">
<p>
Functional programming as "<i>programming exclusively with immutable data</i>" is an interesting and still yet-to-be widely accepted approach to programming which is worth talking about. The dangers of <i>undisciplined</i> data mutation is widely known and non-controversial.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc4a6c4b" class="outline-2">
<h2 id="orgc4a6c4b">Pure Functions</h2>
<div class="outline-text-2" id="text-orgc4a6c4b">
<p>
Finally we have by far the most complex idea in functional programming, yet also one of the most useless.
The idea is that all functions you write/use should be "pure" functions.
There are at least 4 different properties people tend to bring up when talking about pure functions:
</p>

<ol class="org-ol">
<li>No side effects</li>
<li>No mutation</li>
<li>Only looks at arguments</li>
<li>Same input &lt;&#x2014;&gt; Same output</li>
</ol>

<p>
We have already discussed (1) and (2).
</p>
</div>
<div id="outline-container-org3f06e3a" class="outline-3">
<h3 id="org3f06e3a">Only Arguments</h3>
<div class="outline-text-3" id="text-org3f06e3a">
<p>
(3) is terribly misleading, funnily because of not taking seriously the idea of functions as values.
It is virtually impossible to write a function which <i>only</i> looks at its arguments.
Consider the following function definition:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">square</span>
  (<span class="org-keyword">lambda</span> (x)
    (* x x)))
</pre>
</div>

<p>
There is a non-local reference here: <code>*</code>! <br />
<b>Every function consists of references to non-local data.</b>
What makes the above code actually "transparent" to reason about is <b>lexical scoping</b>.
That is, the fact that the value which is bound to <code>*</code> within the scope of the function cannot be changed outside the scope of the function after its definition.
Note that immutability also makes a difference here, because it ensures that there is no <i>time</i> attached to this definition.
If there were mutation in the language of the above code, mutating the value of <code>*</code> before the definition is made could cause confusion.
</p>
</div>
</div>
<div id="outline-container-orgb8d0c53" class="outline-3">
<h3 id="orgb8d0c53">Input &lt;&#x2014;&gt; Output</h3>
<div class="outline-text-3" id="text-orgb8d0c53">
<p>
That leaves us with (4).
But we obviously don't want <i>all</i> functions to return the same value given the same arguments + environment, because we would like to read in data from the outside world.
So we can't take an absolutist stance to (4), only a conditional one.
But that functions should <i>generally</i> return the same thing given the same arguments is widely agreed upon.
</p>

<p>
Therefore, talking about pure functions either reduces to talking about something else (like immutability or side effects), or is pointless/trivial.
</p>
</div>
</div>
<div id="outline-container-orgcc4a237" class="outline-3">
<h3 id="orgcc4a237">TLDR<sub>4</sub></h3>
<div class="outline-text-3" id="text-orgcc4a237">
<p>
Functional programming as "<i>programming with pure functions</i>" is a useless notion.
</p>
</div>
</div>
</div>
<div id="outline-container-org0c70bab" class="outline-2">
<h2 id="org0c70bab">Conclusion</h2>
<div class="outline-text-2" id="text-org0c70bab">
<p>
Most of the traditional qualities of functional programming have been adopted by programmers and programming languages which both functional and non-functional advocates alike agree are not functional in nature.
</p>

<p>
The only exception to this I see is the still seemingly contested approach to (im)mutable data.
The idea that immutability is the core of functional programming  goes back all the way to at least the 1970s<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>, and so has historical legitimacy as well.
Therefore I believe that talking about functional programming as immutable programming is the most clear and sensible approach to the subject.
</p>
</div>
<div id="outline-container-org6892594" class="outline-3">
<h3 id="org6892594">Bath Water</h3>
<div class="outline-text-3" id="text-org6892594">
<p>
In addition to this, most if not all of the other ideas discussed in this article are related to each other.
It is difficult to program with immutable data without first-class functions, and it is easier to control side effects with immutable data.
Thus I don't think there is any need to censor speech about these other qualities in relation to functional programming.
But, rather than talking about them as part of a constellation of functional qualities, we should instead speak of them as the branches of a tree rooted in the idea of immutability.
</p>
</div>
</div>
<div id="outline-container-org13037bd" class="outline-3">
<h3 id="org13037bd">Loose Ends</h3>
<div class="outline-text-3" id="text-org13037bd">
<p>
Finally, there are a few other things people bring up when talking about functional programming, such as:
</p>

<ul class="org-ul">
<li>Pattern Matching</li>
<li>Recursion / Tail Call Optimization</li>
<li>Lazy Evaluation</li>
<li>Type Systems</li>
</ul>

<p>
and more.
However, these are all potential concrete features of a programming <i>language</i>, not a programming paradigm.
I would classify them similarly to everything which is not immutable data that we've already discussed: things which pair nicely with functional programming.
</p>
</div>
</div>
<div id="outline-container-org5ac2c76" class="outline-3">
<h3 id="org5ac2c76">TLDR<sub>5</sub></h3>
<div class="outline-text-3" id="text-org5ac2c76">
<p>
Functional programming <i>is</i> immutable programming, which makes it very cool ðŸ˜Ž.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
We are definitely ignoring philosophical questions about identity and constructs like lambda encodings.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
For a more in-depth discussion of these ideas, see <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html">Structure and Interpretations of Computer Programs</a> chapter 3.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Again, see SICP.
</p></div></div>


</div>
</div>
