<blockquote> <p><a href="https://en.wikipedia.org/wiki/Software_Freedom_Day" target="_blank" rel="noopener">Software Freedom Day</a> is this week, and we thought we’d mark the occasion with a post about some of our work on open source software that we maintain. Fastmail believes in being a <a href="https://www.fastmail.com/company/values/" target="_blank" rel="noopener">good internet citizen</a>, and that belief means we participate in the development of free software, both by sharing software that we write and by contributing to the maintenance of free software that we use.</p> <p>This is a highly technical post about how we solved a crash in our automated test systems. You do not need to make any changes to your Fastmail account or your email software, and you can ignore this post if it’s not interesting to you!</p> </blockquote><p>What happens when a mysterious bug causes all your tests to fail once or twice a week? We try to solve these mysteries, even if it takes a year.</p><p>At Fastmail we have a strong testing culture around our code. When we write a new feature or fix a bug, we include tests to show that our feature works or the bug has actually been fixed. We open a Merge Request, and GitLab CI kicks off a job to run the project’s full test suite. We also have a scheduled job that runs once a day, testing our mainline branch. This checks that the tests haven’t started failing because of changes to the outside world.</p><p>The job stands up a virtual machine, installs all of the necessary software, updates configurations, starts the various services that make up Fastmail, and then runs all of the tests. Finally, it shuts down the box and generates some downloadable artifacts with the test results. There are quite a few tests. All told, this process takes about 13 minutes. As a developer, you’re hoping to see this:</p><pre><code>File Count: 441
Assertion Count: 22040
    --&gt;  Result: PASSED  &lt;--
</code></pre><p>Starting some time in early 2023, we’d occasionally have jobs fail in strange ways. We didn’t see failures around the features we were changing. Instead, we’d see a bunch of random tests would fail with the error “Signal: 6” and “Signal: 11”:</p><pre><code>( STDERR )  job 364    free(): invalid size
&lt; REASON &gt;  job 364    Test script returned error (Signal: 6)
&lt; REASON &gt;  job 364    No plan was declared, and no assertions were made.
&lt; REASON &gt;  job 369    Test script returned error (Signal: 11)
&lt; REASON &gt;  job 369    No plan was declared, and no assertions were made.
&lt; REASON &gt;  job 373    Test script returned error (Signal: 11)
&lt; REASON &gt;  job 373    No plan was declared, and no assertions were made.
</code></pre><p>That means one process got a SIGABRT and then after that a bunch of processes got SIGSEGV. Something, somewhere, was going wrong with the software’s use of memory. “Use of memory”, though, covers a <em>lot</em> of what any given program is doing.</p><p>At the time, our test runs didn’t have much logging, so we couldn’t really tell what was going on, and we couldn’t easily reproduce the problem. On any given run, either it happened or it didn’t. For a while, I just assumed our VMs were occasionally dodgy somehow. The problem was rare, so we tried to ignore it and just click “Re-run job” as needed.</p><p>Soon though, it began to happen more frequently.</p><p>I added logging to our builds, and I made sure that the job’s build artifacts would always contain all the logs. With this evidence in hand, we began to see a pattern:</p><pre><code>t1[43556]: segfault at 8 ip 00007fca57fde1ee sp 00007ffdeab5ef00
  error 4 in FastMmap.so[7fca57fda000+6000] likely on CPU 2 (core 2, socket 0)
t3[43580]: segfault at 8 ip 00007fca57fde1ee sp 00007ffdeab5ef00
t9[43685]: segfault at 8 ip 00007fca57fde1ee sp 00007ffdeab5ef00
  error 4 in FastMmap.so[7fca57fda000+6000] likely on CPU 3 (core 3, socket 0)
</code></pre><p>The crash was always in <code>FastMmap.so</code>! This comes from <a href="https://metacpan.org/pod/Cache::FastMmap" target="_blank" rel="noopener">Cache::FastMmap</a>, a Perl module of ours that provides an mmap-backed cache for use across processes.</p><p>Armed with this information, I modified our builds to collect the on-disk cache files, too. With those, I’d be able to examine what was in the cache when a crash happened. Unfortunately, the cache files were corrupt, leaving me with more questions than answers.</p><p>Over the course of months, I started taking a day here and there to dig through this problem – poring over the Cache::FastMmap code, our available logs, and our reproductions using the captured files. I tested and tossed out a <strong>lot</strong> of theories.</p><p>Eventually, I added the ability to capture the core files generated during the test runs, because I realized that when this problem triggered, there was always a <code>SIGABRT</code> first with the error message seen below, which previously I hadn’t thought of as significant:</p><pre><code>( STDERR )  job 364    free(): invalid size
&lt; REASON &gt;  job 364    Test script returned error (Signal: 6)
</code></pre><p>It seemed pretty clear that the first crash was corrupting the file, and all of the processes using the cache file after were crashing because of that.</p><p>So after adding the core file collector, I sat there clicking “Run job” on my merge request over and over and over and over and over, trying to trigger a crash.</p><p><picture><source type="image/webp" srcset="/assets/images/alh-masto-post-KRlL9e_zAe-375.webp 375w, /assets/images/alh-masto-post-KRlL9e_zAe-594.webp 594w" sizes="(max-width: 425px) 375px, 750px"><img alt="the author posts about the inability to reproduce the bug" loading="lazy" decoding="async" src="/assets/images/alh-masto-post-KRlL9e_zAe-375.png" width="594" height="236" srcset="/assets/images/alh-masto-post-KRlL9e_zAe-375.png 375w, /assets/images/alh-masto-post-KRlL9e_zAe-594.png 594w" sizes="(max-width: 425px) 375px, 750px"></picture></p><p>Eventually, it worked… but unfortunately I had no debugging symbols in the core files, so it didn’t help. I modified the build <em>again</em>, including those, and then clicked “Run job” a bunch more.</p><p>Finally, I got what I needed, but this was even more confounding. The stack trace showed that the crash happened here:</p><pre><code>#3  0x00007f8c429d6195 in mmc_do_expunge (cache=cache@entry=0x56113b842070,
    num_expunge=&lt;optimized out&gt;,
    new_num_slots=&lt;optimized out&gt;,
    to_expunge=0x56113b506210) at mmap_cache.c:800
800	  free(to_expunge);
</code></pre><p><code>to_expunge</code> was a valid pointer, and nothing else had freed it yet from what I could tell by looking at the source.</p><p>This told me that most likely we were writing over memory somewhere where we shouldn’t be, and we were stomping on malloc’s internal structures. Unfortunately, these kind of bugs are really hard to track down unless you can catch them in the act using tools like Valgrind or AddressSanitizer.</p><p>I tried various things from there, including modifying the build to output every action taken against the cache file. The logs included a high-resolution timestamps, the action that was taken (fetch, store, delete), and whether it resulted in success or not.</p><p>I replayed these recordings (single threaded - not a perfect test since it didn’t imitate inter-process locking or coordinating) with Valgrind and AddressSanitizer, but I got nowhere.</p><p>I stared at the code, thought for a while longer, and then did some web searching for the “free(): invalid size” error to see if that could maybe help me pinpoint where a bad write was happening.</p><p>That led me to <a href="https://stackoverflow.com/questions/14795001/negative-indexing-gives-error-upon-freeing" target="_blank" rel="noopener">a post on StackOverflow</a> that pointed toward negative indexing. After reading that, I tried a few experimental programs until I reproduced the abort:</p><pre class="language-c"><code class="language-c"><span class="macro property token"><span class="directive-hash token">#</span><span class="directive keyword token">include</span> <span class="string token">&lt;stdlib.h></span></span>

<span class="keyword token">void</span> <span class="function token">main</span><span class="punctuation token">(</span><span class="keyword token">void</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
  <span class="keyword token">int</span> <span class="operator token">*</span><span class="operator token">*</span>x <span class="operator token">=</span> <span class="punctuation token">(</span><span class="keyword token">int</span><span class="operator token">*</span><span class="operator token">*</span><span class="punctuation token">)</span><span class="function token">calloc</span><span class="punctuation token">(</span><span class="number token">5</span><span class="punctuation token">,</span> <span class="keyword token">sizeof</span><span class="punctuation token">(</span><span class="keyword token">int</span><span class="operator token">*</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="keyword token">int</span> <span class="operator token">*</span><span class="operator token">*</span>y <span class="operator token">=</span> <span class="punctuation token">(</span><span class="keyword token">int</span><span class="operator token">*</span><span class="operator token">*</span><span class="punctuation token">)</span><span class="function token">calloc</span><span class="punctuation token">(</span><span class="number token">5</span><span class="punctuation token">,</span> <span class="keyword token">sizeof</span><span class="punctuation token">(</span><span class="keyword token">int</span><span class="operator token">*</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="keyword token">int</span> <span class="operator token">*</span><span class="operator token">*</span>z <span class="operator token">=</span> x<span class="punctuation token">;</span>
  <span class="keyword token">int</span> <span class="operator token">*</span>num <span class="operator token">=</span> <span class="function token">malloc</span><span class="punctuation token">(</span><span class="keyword token">sizeof</span><span class="punctuation token">(</span><span class="keyword token">int</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="operator token">*</span><span class="operator token">--</span>z <span class="operator token">=</span> <span class="punctuation token">(</span><span class="keyword token">int</span> <span class="operator token">*</span><span class="punctuation token">)</span><span class="operator token">&amp;</span>num<span class="punctuation token">;</span>
  <span class="function token">free</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="function token">free</span><span class="punctuation token">(</span>x<span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="punctuation token">}</span></code></pre><pre><code>$ gcc negative-array-index.c
$ ./a.out
free(): invalid size
Aborted (core dumped)
</code></pre><p>Could it be that we were underflowing an array? That is, were we accidentally writing to memory below the lower bound of an array we’d allocated? With this theory in mind, I looked through the Cache::FastMmap source to find where we might be underflowing an array, and I spotted this loop in <code>mmc_calc_expunge()</code>:</p><pre class="language-c"><code class="language-c">MU32 <span class="operator token">*</span><span class="operator token">*</span> copy_base_det <span class="operator token">=</span> <span class="punctuation token">(</span>MU32 <span class="operator token">*</span><span class="operator token">*</span><span class="punctuation token">)</span><span class="function token">calloc</span><span class="punctuation token">(</span>used_slots<span class="punctuation token">,</span> <span class="keyword token">sizeof</span><span class="punctuation token">(</span>MU32 <span class="operator token">*</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
MU32 <span class="operator token">*</span><span class="operator token">*</span> copy_base_det_in <span class="operator token">=</span> copy_base_det <span class="operator token">+</span> used_slots

<span class="comment token">//[... more code ...]</span>

<span class="comment token">/* Loop for each existing slot, and store in a list */</span>
<span class="keyword token">for</span> <span class="punctuation token">(</span><span class="punctuation token">;</span> slot_ptr <span class="operator token">!=</span> slot_end<span class="punctuation token">;</span> slot_ptr<span class="operator token">++</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
  MU32 data_offset <span class="operator token">=</span> <span class="operator token">*</span>slot_ptr<span class="punctuation token">;</span>
  MU32 <span class="operator token">*</span> base_det <span class="operator token">=</span> <span class="function token">S_Ptr</span><span class="punctuation token">(</span>cache<span class="operator token">-></span>p_base<span class="punctuation token">,</span> data_offset<span class="punctuation token">)</span><span class="punctuation token">;</span>
  MU32 expire_on<span class="punctuation token">,</span> kvlen<span class="punctuation token">;</span>

  <span class="comment token">/* Ignore if if free slot */</span>
  <span class="keyword token">if</span> <span class="punctuation token">(</span>data_offset <span class="operator token">&lt;=</span> <span class="number token">1</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
    <span class="keyword token">continue</span><span class="punctuation token">;</span>
  <span class="punctuation token">}</span>

  <span class="comment token">/* Definitely out if mode == 1 which means expunge all */</span>
  <span class="keyword token">if</span> <span class="punctuation token">(</span>mode <span class="operator token">==</span> <span class="number token">1</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
    <span class="operator token">*</span>copy_base_det_out<span class="operator token">++</span> <span class="operator token">=</span> base_det<span class="punctuation token">;</span>
    <span class="keyword token">continue</span><span class="punctuation token">;</span>
  <span class="punctuation token">}</span>

  <span class="comment token">/* Definitely out if expired, and not dirty */</span>
  expire_on <span class="operator token">=</span> <span class="function token">S_ExpireOn</span><span class="punctuation token">(</span>base_det<span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="keyword token">if</span> <span class="punctuation token">(</span>expire_on <span class="operator token">&amp;&amp;</span> now <span class="operator token">>=</span> expire_on<span class="punctuation token">)</span> <span class="punctuation token">{</span>
    <span class="operator token">*</span>copy_base_det_out<span class="operator token">++</span> <span class="operator token">=</span> base_det<span class="punctuation token">;</span>
    <span class="keyword token">continue</span><span class="punctuation token">;</span>
  <span class="punctuation token">}</span>

  <span class="comment token">/* Track used space */</span>
  kvlen <span class="operator token">=</span> <span class="function token">S_SlotLen</span><span class="punctuation token">(</span>base_det<span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="function token">ROUNDLEN</span><span class="punctuation token">(</span>kvlen<span class="punctuation token">)</span><span class="punctuation token">;</span>
  <span class="function token">ASSERT</span><span class="punctuation token">(</span>kvlen <span class="operator token">&lt;=</span> page_data_size<span class="punctuation token">)</span><span class="punctuation token">;</span>
  used_data <span class="operator token">+=</span> kvlen<span class="punctuation token">;</span>
  <span class="function token">ASSERT</span><span class="punctuation token">(</span>used_data <span class="operator token">&lt;=</span> page_data_size<span class="punctuation token">)</span><span class="punctuation token">;</span>

  <span class="comment token">/* Potentially in */</span>
  <span class="operator token">*</span><span class="operator token">--</span>copy_base_det_in <span class="operator token">=</span> base_det<span class="punctuation token">;</span>
<span class="punctuation token">}</span></code></pre><p>This code allocates a new region of memory based on how many used slots we have (<code>used_slots</code>) and takes a pointer to the end of that region of memory:</p><pre class="language-c"><code class="language-c">MU32 <span class="operator token">*</span><span class="operator token">*</span> copy_base_det <span class="operator token">=</span> <span class="punctuation token">(</span>MU32 <span class="operator token">*</span><span class="operator token">*</span><span class="punctuation token">)</span><span class="function token">calloc</span><span class="punctuation token">(</span>used_slots<span class="punctuation token">,</span> <span class="keyword token">sizeof</span><span class="punctuation token">(</span>MU32 <span class="operator token">*</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
MU32 <span class="operator token">*</span><span class="operator token">*</span> copy_base_det_in <span class="operator token">=</span> copy_base_det <span class="operator token">+</span> used_slots<span class="punctuation token">;</span></code></pre><p>Then, we loop over every slot in the cache, looking for ones that have data…</p><pre class="language-c"><code class="language-c"><span class="keyword token">for</span> <span class="punctuation token">(</span><span class="punctuation token">;</span> slot_ptr <span class="operator token">!=</span> slot_end<span class="punctuation token">;</span> slot_ptr<span class="operator token">++</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
  MU32 data_offset <span class="operator token">=</span> <span class="operator token">*</span>slot_ptr<span class="punctuation token">;</span>
  MU32 <span class="operator token">*</span> base_det <span class="operator token">=</span> <span class="function token">S_Ptr</span><span class="punctuation token">(</span>cache<span class="operator token">-></span>p_base<span class="punctuation token">,</span> data_offset<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre><p>…skipping ones that don’t…</p><pre class="language-c"><code class="language-c">  <span class="comment token">/* Ignore if if free slot */</span>
  <span class="keyword token">if</span> <span class="punctuation token">(</span>data_offset <span class="operator token">&lt;=</span> <span class="number token">1</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
    <span class="keyword token">continue</span><span class="punctuation token">;</span>
  <span class="punctuation token">}</span></code></pre><p>…and finally copying over ones that do have data to the new region of memory, starting at the end of the memory region and working towards the front:</p><pre class="language-c"><code class="language-c">  <span class="operator token">*</span><span class="operator token">--</span>copy_base_det_in <span class="operator token">=</span> base_det<span class="punctuation token">;</span></code></pre><p>(Later, <code>copy_base_det</code> ends up in <code>to_expunge</code> seen above.)</p><p>In order for this loop to underflow, the cache would have to have more slots with data in them than <code>used_slots</code> accounts for.</p><p>The only way I could see this happening was if two processes wrote to the cache at the same time, corrupting its accounting. That, though, would mean locking had failed somehow…</p><p>To chase that down, I modified the build to log when a lock was acquired, when a write happened, and when the lock was released. I clicked “Run job” wildly, like I was playing the world’s worst Cookie Clicker game… and eventually I got another hit.</p><p>This time, there was a smoking gun:</p><pre><code>1739384152.734390 [32464] locked page 3: p_offset: 786432 pns: 179 pfs: 115 size: 262144
1739384152.737327 [32928] locked page 3: p_offset: 786432 pns: 179 pfs: 115 size: 262144
1739384152.738589 [32928] unlocked page 3 (with changes): pns: 179 pfs: 114
1739384152.738776 [32464] unlocked page 3 (with changes): pns: 179 pfs: 115
</code></pre><p>Here, <code>pns</code> is the number of slots, and <code>pfs</code> is the number of <em>free</em> slots.</p><p>Above, we see that process 32464 locked the cache, and then before 32464 could write to the cache, process 32928 also locked the cache! That’s supposed to be impossible! Then, the second process wrote an entry to the cache, using up another slot, so it decremented the free slot count. And <em>then</em>, the first process wrote out its changes. Those <em>didn’t</em> include the use of any new slots, and so it set the free slot count back up to 115!</p><p><em>This</em> is what caused <code>mmc_calc_expunge</code> to underflow – it allocated memory for 64 slots (179 total slots minus 115 free slots) but ended up seeing 65 slots with data that it needed to copy over!</p><p>Using the available logs on the machine, I identified the two processes, and found that one of them was a test that I had long suspected was the culprit.</p><p>That test uses <a href="https://metacpan.org/pod/IO::Async::Process" target="_blank" rel="noopener">IO::Async::Process</a> to fork a child, then run some Perl code in that child. It turns out that IO::Async::Process <em>closes all file descriptors</em> except STDIN, STDOUT, and STDERR when forking. This is a surprising thing to do when forking – often a parent might intentionally leave file descriptors open for a child to continue using.</p><p>A file descriptor is just a number representing an open file or socket (like a network connection).</p><p>When Cache::FastMmap first starts up, it opens the cache file for reading/writing:</p><pre class="language-c"><code class="language-c"><span class="keyword token">int</span> fh <span class="operator token">=</span> <span class="function token">open</span><span class="punctuation token">(</span>cache<span class="operator token">-></span>share_file<span class="punctuation token">,</span> O_RDWR<span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="keyword token">if</span> <span class="punctuation token">(</span>fh <span class="operator token">==</span> <span class="operator token">-</span><span class="number token">1</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
  <span class="keyword token">return</span> <span class="function token">_mmc_set_error</span><span class="punctuation token">(</span>cache<span class="punctuation token">,</span> errno<span class="punctuation token">,</span> <span class="string token">"Open of share file %s failed"</span><span class="punctuation token">,</span> cache<span class="operator token">-></span>share_file<span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="punctuation token">}</span>
cache<span class="operator token">-></span>fh <span class="operator token">=</span> fh<span class="punctuation token">;</span></code></pre><p>It then maps that file into memory:</p><pre class="language-c"><code class="language-c">cache<span class="operator token">-></span>mm_var <span class="operator token">=</span> <span class="function token">mmap</span><span class="punctuation token">(</span><span class="number token">0</span><span class="punctuation token">,</span> cache<span class="operator token">-></span>c_size<span class="punctuation token">,</span> PROT_READ <span class="operator token">|</span> PROT_WRITE<span class="punctuation token">,</span> MAP_SHARED<span class="punctuation token">,</span> cache<span class="operator token">-></span>fh<span class="punctuation token">,</span> <span class="number token">0</span><span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre><p>Later, when it needs to write out changes to a specific page in the cache, it locks that region of mapped memory by locking specific ranges of bytes within the file <em>using the file descriptor number</em>:</p><pre class="language-c"><code class="language-c"><span class="comment token">/* Setup fcntl locking structure */</span>
lock<span class="punctuation token">.</span>l_type <span class="operator token">=</span> F_WRLCK<span class="punctuation token">;</span>
lock<span class="punctuation token">.</span>l_whence <span class="operator token">=</span> <span class="constant token">SEEK_SET</span><span class="punctuation token">;</span>
lock<span class="punctuation token">.</span>l_start <span class="operator token">=</span> p_offset<span class="punctuation token">;</span>
lock<span class="punctuation token">.</span>l_len <span class="operator token">=</span> cache<span class="operator token">-></span>c_page_size<span class="punctuation token">;</span>

<span class="comment token">/* Lock the page (block till done, signal, or timeout) */</span>
lock_res <span class="operator token">=</span> <span class="function token">fcntl</span><span class="punctuation token">(</span>cache<span class="operator token">-></span>fh<span class="punctuation token">,</span> F_SETLKW<span class="punctuation token">,</span> <span class="operator token">&amp;</span>lock<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre><p>If another process using Cache::FastMmap with the same file tries to write changes, it will block trying to get the same lock until the current process is finished and unlocks the file.</p><p>However, when IO::Async::Process closes all open file descriptors, <code>cache-&gt;fh</code> becomes invalid, since that number no longer belongs to any open file or socket. Then, later, if the child process opens up any new files or sockets, that number could be reused(!), so when Cache::FastMmap attempts to lock the cache in the child, it succeeds, but locks <em>the wrong file</em>!</p><p>The memory mapped region is not tied to the file descriptor after having been mapped, so any changes written to memory would still overwrite the cache data, and stomp on whatever work any other process is doing at the same time.</p><p>We fixed all this by ditching the “fork and run more Perl in the child” and replacing it with “fork and exec a brand new process”. With exec, we replace our running program entirely, so we no longer have the mmaped regions available. We’ve been segfault free ever since! We also added code to a new open source release of Cache::FastMmap, to try to prevent anybody else from going through all this.</p><p>What’s really frustrating about this is that I almost cracked it months ago. I had suspected that the fork-and-close-children behaviour of IO::Async::Process was the problem, but when I tested some code manually to trigger the bug, I always got “invalid file descriptor” in the children during locking of the mmaped region… because my tests weren’t opening up new file descriptors. The lock file descriptor wasn’t valid and so the mmaped region couldn’t be be written over.</p><p>Alas.</p>