<p><a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> has taken the world of programming by a storm.
Together with LSP, it’s probably the technology that has influenced the
most programming editors and IDEs in the past several years.
And now that Emacs 29+ comes with built-in Tree-sitter support
I’ve been spending a lot of quality time with it, working
on <a href="https://github.com/clojure-emacs/clojure-ts-mode">clojure-ts-mode</a> and <a href="https://github.com/bbatsov/neocaml/">neocaml-mode</a>.</p>

<p>There’s a lot I’d like to share with you about using Tree-sitter effectively, but
today I’ll focus on a different topic. When most people hear about Tree-sitter
they think of font-locking (syntax highlighting) and indentation powered by
the abstract syntax tree (AST), generated by a Tree-sitter grammar.
For a while I’ve also been thinking that the AST data can also be used
for simple, yet reasonably accurate, code completion. (within the context of
a single code buffer, that is) That’s definitely not nearly as powerful
of what you’d normally get from a dedicated tool (e.g. an LSP server), as
those usually have project-wide completion capabilities, but it’s pretty
sweet given that it’s trivial to implement and doesn’t require any
external dependencies.</p>

<p>Below, you’ll find a simple proof of concept for such a completion, in the context
of <code class="language-plaintext highlighter-rouge">clojure-ts-mode</code>:<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-emacs-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defvar</span> <span class="nv">clojure-ts--completion-query-globals</span>
  <span class="p">(</span><span class="nv">treesit-query-compile</span> <span class="ss">'clojure</span>
                         <span class="o">`</span><span class="p">((</span><span class="nv">source</span>
                            <span class="p">(</span><span class="nv">list_lit</span>
                             <span class="p">((</span><span class="nv">sym_lit</span><span class="p">)</span> <span class="nv">@sym</span>
                              <span class="p">(</span><span class="ss">:match</span> <span class="o">,</span><span class="nv">clojure-ts--variable-definition-symbol-regexp</span> <span class="nv">@sym</span><span class="p">))</span>
                             <span class="ss">:anchor</span> <span class="nv">[</span><span class="p">(</span><span class="nv">comment</span><span class="p">)</span> <span class="p">(</span><span class="nv">meta_lit</span><span class="p">)</span> <span class="p">(</span><span class="nv">old_meta_lit</span><span class="p">)</span><span class="nv">]</span> <span class="ss">:*</span>
                             <span class="ss">:anchor</span> <span class="p">((</span><span class="nv">sym_lit</span><span class="p">)</span> <span class="nv">@var-candidate</span><span class="p">)))</span>
                           <span class="p">(</span><span class="nv">source</span>
                            <span class="p">(</span><span class="nv">list_lit</span>
                             <span class="p">((</span><span class="nv">sym_lit</span><span class="p">)</span> <span class="nv">@sym</span>
                              <span class="p">(</span><span class="ss">:match</span> <span class="o">,</span><span class="nv">clojure-ts--function-type-regexp</span> <span class="nv">@sym</span><span class="p">))</span>
                             <span class="ss">:anchor</span> <span class="nv">[</span><span class="p">(</span><span class="nv">comment</span><span class="p">)</span> <span class="p">(</span><span class="nv">meta_lit</span><span class="p">)</span> <span class="p">(</span><span class="nv">old_meta_lit</span><span class="p">)</span><span class="nv">]</span> <span class="ss">:*</span>
                             <span class="ss">:anchor</span> <span class="p">((</span><span class="nv">sym_lit</span><span class="p">)</span> <span class="nv">@fn-candidate</span><span class="p">))))))</span>

<span class="p">(</span><span class="nv">defconst</span> <span class="nv">clojure-ts--completion-annotations</span>
  <span class="p">(</span><span class="nb">list</span> <span class="ss">'var-candidate</span> <span class="s">" Global variable"</span>
        <span class="ss">'fn-candidate</span> <span class="s">" Function"</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">clojure-ts--completion-annotation-function</span> <span class="p">(</span><span class="nv">candidate</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">thread-last</span> <span class="nv">minibuffer-completion-table</span>
               <span class="p">(</span><span class="nv">alist-get</span> <span class="nv">candidate</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">plist-get</span> <span class="nv">clojure-ts--completion-annotations</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">clojure-ts-completion-at-point-function</span> <span class="p">()</span>
  <span class="p">(</span><span class="nv">when-let*</span> <span class="p">((</span><span class="nv">bounds</span> <span class="p">(</span><span class="nv">bounds-of-thing-at-point</span> <span class="ss">'symbol</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">source</span> <span class="p">(</span><span class="nv">treesit-buffer-root-node</span> <span class="ss">'clojure</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">nodes</span> <span class="p">(</span><span class="nv">treesit-query-capture</span> <span class="nv">source</span> <span class="nv">clojure-ts--completion-query-globals</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">bounds</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">cdr</span> <span class="nv">bounds</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">thread-last</span> <span class="nv">nodes</span>
                 <span class="p">(</span><span class="nv">seq-filter</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">item</span><span class="p">)</span> <span class="ss">'sym</span><span class="p">))))</span>
                 <span class="p">(</span><span class="nv">seq-map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">treesit-node-text</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">item</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">item</span><span class="p">)))))</span>
          <span class="ss">:exclusive</span> <span class="ss">'no</span>
          <span class="ss">:annotation-function</span> <span class="nf">#'</span><span class="nv">clojure-ts--completion-annotation-function</span><span class="p">)))</span>
</code></pre></div></div>

<p>I hope you’ll agree that the code is both simple and easy to follow (especially
if you know a bit about Tree-sitter queries and Emacs’s completion APIs). The
meat of the example is <code class="language-plaintext highlighter-rouge">clojure-ts--completion-annotation-function</code>, the rest is
just completion scaffolding.</p>

<p>And the result looks like this:</p>

<p><a href="/assets/images/clojure-ts-completion.png"><img src="/assets/images/clojure-ts-completion.png" alt="clojure-ts-completion.png" /></a></p>

<p>Not too shabby for 30 lines of code, right? With a bit more efforts this can be made
smarter (e.g. to include local bindings as well), and potentially we can even be
consulting all open buffers running <code class="language-plaintext highlighter-rouge">clojure-ts-mode</code> to fetch completion data
from the as well. (although that’s probably an overkill)</p>

<p>Still, I think that’s an interesting use of Tree-sitter that some of you might
find useful.  It seems that Nic Ferrier has been playing with this idea recently
as well - check out his recent video on the subject
<a href="https://www.youtube.com/watch?v=Lt7vSgV2pv0">here</a>.</p>

<p>In time Tree-sitter will redefine how we’re building Emacs major modes and what they can do.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>
It’s still early days and sky is the limit. Exciting times ahead!</p>

<p>That’s all I have for you today. Keep hacking!</p>

<p><strong>P.S.</strong> I plan to write more on the topic of Tree-sitter and how to use it
in Emacs major modes, but in the mean time you might find some of my development notes
useful:</p>

<ul>
  <li><a href="https://github.com/bbatsov/neocaml/?tab=readme-ov-file#development-notes">Neocaml notes</a></li>
  <li><a href="https://github.com/clojure-emacs/clojure-ts-mode/blob/main/doc/design.md">clojure-ts-mode design notes</a></li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Kudos to Roman Rudakov, who put this prototype together earlier today after a short discussion we had on the topic. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>I can easily imagine things like Tree-sitter based linters or complex refactoring commands. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>