<p>
All the cool kids use debuggers for debugging their code. In most situations that&rsquo;s the right answer. After all, you can set breakpoints, step through your code, and examine values at each step. If you want a detailed view into what your code is doing, debuggers are the best solution.
</p>
<p>
Sometimes, though, they&rsquo;re a bit heavy weight and way more than you need. Often all you need is a few strategically placed <code>printf</code>â€‹s to get the necessary information to solve the problem. Sometimes, for various reasons, you can&rsquo;t use a debugger so you&rsquo;re forced to fall back on <code>printf</code>.
</p>
<p>
Marcin Borkowski (mbork) has a <a href="https://mbork.pl/2025-10-06_A_debug_helper_in_Elisp">nice example of the latter</a>. He was debugging an Elisp function that messed with windows and that interfered with <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html">Edebug</a>&rsquo;s use of those windows. The answer, of course, was to fall back to the <code>printf</code> method. The natural solution was to use the Elisp <code>message</code> function but there were some problems. The first problem was easy. The messages appeared in the minibuffer and disappeared before he could read them. He fixed that by wrapping <code>message</code> in a function that waited for a key press before continuing.
</p>
<p>
Then he noticed that virtually all his invocations were of the form <code>(message "var1: %s, var2: %s" var1 var2)</code>, and that it made sense to abstract that a bit into a new function. That brought a couple of new problems but they were also easily dealt with.
</p>
<p>
Mbork&rsquo;s post is well worth reading and his code is worth a bit of study too. I like the way he just digs in and solves the problems without too much worry about whether or not it&rsquo;s the best way. At the end of the day, he solved his problem and that&rsquo;s what matters.</p>
