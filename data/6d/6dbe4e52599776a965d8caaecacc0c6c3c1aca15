<p><img src="https://cdn3.brettterpstra.com/uploads/2025/12/apex-header-2-rb.7522.jpg" width="800" height="226" style="margin:0 auto;clear:both;" class="header" /></p>
<p>If you use Apex for more than one project, you&rsquo;ve probably hit the point where a single global setup doesn&rsquo;t quite cut it. Maybe your book project wants a different plugin set than your docs site, or one repo has stricter defaults than everything else on your machine.</p>

<p>As a personal example, most of my app documentation has always been written in MultiMarkdown, where header ids get generated with no spaces or dashes, so all of my cross-references link to <code class="language-plaintext highlighter-rouge">#thissection</code> type of anchors. My blog and my Jekyll-based documentation sites have always used Kramdown, so header ids and cross references are <code class="language-plaintext highlighter-rouge">#this-section</code>. I needed an easy way to always have Apex use the right header format for the current project.</p>

<p>I also have special plugins for different destinations. For example, my Marked documentation has special Liquid-style tags like <code class="language-plaintext highlighter-rouge">prefpane</code> that generates nice HTML for referencing Preference panes with <code class="language-plaintext highlighter-rouge">x-marked</code> URLs that will open a preference pane directly in Marked. I don&rsquo;t need or want a plugin to do that universally, the output it generates is very specific to Marked.</p>

<p>So I added project-scoped plugins and configurations to Apex. This allows me to get the settings just right for a project, then save them into a local directory and be able to just run <code class="language-plaintext highlighter-rouge">apex</code> without a bunch of command line flags to remember.</p>

<p>You also get a cleaner way to &ldquo;shadow&rdquo; plugins you don&rsquo;t want with a local noop plugin.</p>

<blockquote>
  <p>I also added <code class="language-plaintext highlighter-rouge">++insert++</code> syntax for adding <code class="language-plaintext highlighter-rouge">&lt;ins&gt;insert&lt;/ins&gt;</code> tags, but that&rsquo;s just a little one-off addition.</p>
</blockquote>

<h3 id="project-scoped-plugins-in-apexplugins">Project-scoped plugins in <code class="language-plaintext highlighter-rouge">.apex/plugins</code></h3>

<p>Plugins used to be purely global: Apex would only look in your XDG config dir:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$XDG_CONFIG_HOME/apex/plugins</code>, or</li>
  <li><code class="language-plaintext highlighter-rouge">~/.config/apex/plugins</code></li>
</ul>

<p>Now there&rsquo;s a proper <strong>project scope</strong>, searched in this order:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">./.apex/plugins</code> (current working directory)</li>
  <li><code class="language-plaintext highlighter-rouge">BASE/.apex/plugins</code> when you run with <code class="language-plaintext highlighter-rouge">--base-dir BASE</code></li>
  <li><code class="language-plaintext highlighter-rouge">&lt;git-root&gt;/.apex/plugins</code> when you&rsquo;re inside a Git work tree</li>
  <li>Global: <code class="language-plaintext highlighter-rouge">$XDG_CONFIG_HOME/apex/plugins</code> or <code class="language-plaintext highlighter-rouge">~/.config/apex/plugins</code></li>
</ol>

<p>Each of those directories can hold Apex plugins in the usual format:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code>.apex/
  plugins/
    my-plugin/
      plugin.yml
      whatever-script-you-like</code></pre></div></div>

<p>When Apex builds the plugin list, <strong>earlier locations win by id</strong>. If a plugin with id <code class="language-plaintext highlighter-rouge">footnotes-plus</code> exists in both <code class="language-plaintext highlighter-rouge">.apex/plugins</code> and your global config dir, the project version is the one that runs.</p>

<h3 id="no-op-shadowing-turning-off-plugins-per-project">No-op shadowing: turning off plugins per project</h3>

<p>That id-based precedence also gives you a neat trick: <strong>no-op shadowing</strong>.</p>

<p>If there&rsquo;s a global plugin you usually like, but you don&rsquo;t want it in a specific project, you can &ldquo;shadow&rdquo; it by dropping an empty or no-op plugin with the same id into <code class="language-plaintext highlighter-rouge">.apex/plugins</code>. For example:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code>.apex/
  plugins/
    kbd/
      plugin.yml
      noop.sh</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">plugin.yml</code> might look like:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code><span class="na">id</span><span class="pi">:</span> <span class="s">kbd</span>
<span class="na">title</span><span class="pi">:</span> <span class="s">KBD Noop</span></code></pre></div></div>

<p>Because the project copy of <code class="language-plaintext highlighter-rouge">kbd</code> is discovered first, it <strong>shadows</strong> the global one. You can also do the same trick with purely declarative regex plugins: define a plugin with the same id that simply doesn&rsquo;t match anything meaningful, and the global behavior is effectively disabled for that project.</p>

<h3 id="--list-plugins-now-understands-projects"><code class="language-plaintext highlighter-rouge">--list-plugins</code> now understands projects</h3>

<p>To make this discoverable, <code class="language-plaintext highlighter-rouge">apex --list-plugins</code> was updated to use the <strong>same resolution rules</strong> as the runtime plugin loader.</p>

<p>When you run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code>apex <span class="nt">--list-plugins</span></code></pre></div></div>

<p>you&rsquo;ll see:</p>

<ul>
  <li>An &ldquo;Installed Plugins&rdquo; section that includes plugins from:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">./.apex/plugins</code></li>
      <li><code class="language-plaintext highlighter-rouge">BASE/.apex/plugins</code> (if <code class="language-plaintext highlighter-rouge">--base-dir</code> was used)</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;git-root&gt;/.apex/plugins</code></li>
      <li>global config plugins</li>
    </ul>
  </li>
  <li>An &ldquo;Available Plugins&rdquo; section from the remote directory, <strong>filtered</strong> so remote entries are hidden when you already have a plugin with the same id installed anywhere (project or global).</li>
</ul>

<p>If a project plugin shadows a global one, you&rsquo;ll only see the project entry in the installed list, and the remote listing won&rsquo;t try to &ldquo;helpfully&rdquo; re-offer the same id.</p>

<h3 id="project-level-config-in-apexconfigyml">Project-level config in <code class="language-plaintext highlighter-rouge">.apex/config.yml</code></h3>

<p>Plugins aren&rsquo;t the only thing that benefit from scoping. Apex&rsquo;s configuration system now has an explicit <strong>project layer</strong>, alongside the existing global and per-document metadata.</p>

<p>Config is now read from these places:</p>

<ol>
  <li><strong>Global config</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">$XDG_CONFIG_HOME/apex/config.yml</code>, or</li>
      <li><code class="language-plaintext highlighter-rouge">~/.config/apex/config.yml</code></li>
    </ul>
  </li>
  <li><strong>Project config</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">./.apex/config.yml</code></li>
      <li><code class="language-plaintext highlighter-rouge">BASE/.apex/config.yml</code> when using <code class="language-plaintext highlighter-rouge">--base-dir BASE</code></li>
      <li><code class="language-plaintext highlighter-rouge">&lt;git-root&gt;/.apex/config.yml</code> when inside a Git work tree</li>
    </ul>
  </li>
  <li><strong>Explicit metadata file</strong>
    <ul>
      <li>Any file you pass with <code class="language-plaintext highlighter-rouge">--meta-file FILE</code></li>
    </ul>
  </li>
  <li><strong>Per-document metadata</strong>
    <ul>
      <li>YAML front matter, MultiMarkdown metadata, or Pandoc title blocks</li>
    </ul>
  </li>
  <li><strong>Command-line metadata and flags</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">--meta KEY=VALUE</code>, <code class="language-plaintext highlighter-rouge">--mode</code>, <code class="language-plaintext highlighter-rouge">--pretty</code>, <code class="language-plaintext highlighter-rouge">--no-tables</code>, and so on</li>
    </ul>
  </li>
</ol>

<p>The merge order matters:</p>

<ul>
  <li>Global <code class="language-plaintext highlighter-rouge">config.yml</code> (lowest file precedence)</li>
  <li>Project <code class="language-plaintext highlighter-rouge">.apex/config.yml</code></li>
  <li><code class="language-plaintext highlighter-rouge">--meta-file FILE</code></li>
  <li>Document metadata</li>
  <li><code class="language-plaintext highlighter-rouge">--meta</code> and CLI flags (highest precedence)</li>
</ul>

<p>So if you put this in your <strong>global</strong> config:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code><span class="na">mode</span><span class="pi">:</span> <span class="s">unified</span>
<span class="na">pretty</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">wikilinks</span><span class="pi">:</span> <span class="no">false</span></code></pre></div></div>

<p>and then in your <strong>project</strong> <code class="language-plaintext highlighter-rouge">.apex/config.yml</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code><span class="na">wikilinks</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">indices</span><span class="pi">:</span> <span class="no">true</span></code></pre></div></div>

<p>you&rsquo;ll end up with:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mode: unified</code></li>
  <li><code class="language-plaintext highlighter-rouge">pretty: true</code></li>
  <li><code class="language-plaintext highlighter-rouge">wikilinks: true</code>   # project overrides global</li>
  <li><code class="language-plaintext highlighter-rouge">indices: true</code>     # project-only addition</li>
</ul>

<p>Any <code class="language-plaintext highlighter-rouge">--meta-file</code> you pass on the command line layers on top of both, and document/CLI overrides still win last.</p>

<h3 id="a-quick-example-project-layout">A quick example project layout</h3>

<p>Here&rsquo;s what a repo might look like with all of this wired up:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code>my-book/
  .git/
  .apex/
    config.yml
    plugins/
      figures/
        plugin.yml
        figures.py
      kbd/
        plugin.yml
  chapters/
    01-intro.md
    02-deep-dive.md</code></pre></div></div>

<p>Running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight fixed"><code><span class="nb">cd </span>my-book
apex chapters/01-intro.md <span class="nt">--plugins</span></code></pre></div></div>

<p>will:</p>

<ul>
  <li>Load config from:
    <ul>
      <li>global <code class="language-plaintext highlighter-rouge">config.yml</code> (if any),</li>
      <li>then <code class="language-plaintext highlighter-rouge">./.apex/config.yml</code>,</li>
      <li>then any <code class="language-plaintext highlighter-rouge">--meta-file</code> you pass,</li>
    </ul>
  </li>
  <li>Run plugins from:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">./.apex/plugins</code> first,</li>
      <li>then fall back to global plugins,</li>
    </ul>
  </li>
  <li>Apply per-document metadata and CLI overrides on top.</li>
</ul>

<p>You get per-repo behavior <strong>without</strong> having to constantly remember the right <code class="language-plaintext highlighter-rouge">--meta-file</code> or a long list of flags.</p>

<h3 id="a-quick-note-on-insert">A quick note on <code class="language-plaintext highlighter-rouge">++insert++</code></h3>

<p>While we were in here, another small but handy syntax has been added: <code class="language-plaintext highlighter-rouge">++insert++</code>.</p>

<p><code class="language-plaintext highlighter-rouge">++insert++</code> gives you a lightweight way to add an <code class="language-plaintext highlighter-rouge">&lt;ins&gt;text&lt;/ins&gt;</code> tag to your document. It&rsquo;s just a little shorter and easier than typing out the tags manually. I try not to add too much esoteric markup to the syntax, but I&rsquo;ve seen <code class="language-plaintext highlighter-rouge">++</code> a couple of places and thought it a worthwhil addition.</p>

<h3 id="wrapping-up">Wrapping up</h3>

<p>To recap:</p>

<ul>
  <li>Plugins can now live in <code class="language-plaintext highlighter-rouge">.apex/plugins</code> at the project level, and they override global plugins by id.</li>
  <li><code class="language-plaintext highlighter-rouge">--list-plugins</code> shows the <strong>actual</strong> set of plugins Apex will run for your current project, including overrides.</li>
  <li>Config can now live in <code class="language-plaintext highlighter-rouge">.apex/config.yml</code>, layered on top of your global <code class="language-plaintext highlighter-rouge">config.yml</code> and below any explicit <code class="language-plaintext highlighter-rouge">--meta-file</code>, document metadata, and flags.</li>
  <li><code class="language-plaintext highlighter-rouge">++insertion++</code> gives you <code class="language-plaintext highlighter-rouge">&lt;ins&gt;</code> tags.</li>
</ul>

<p>If you&rsquo;ve been juggling different shell aliases or wrapper scripts for each project, you can probably simplify a lot of that now by letting Apex&rsquo;s own project-aware behavior do the heavy lifting.</p>

<p>Like or share this post <a title="This post on Mastodon" target="_blank" href="https://hachyderm.io/users/ttscoff/statuses/115974151781282518">on Mastodon</a>, <a title="Share on Bluesky" target="_blank" href="https://bsky.app/intent/compose?text=Project-level+plugins+and+config+for+Apex%0A%0Ahttps%3A%2F%2Fbrettterpstra.com%2F2026%2F01%2F28%2Fproject-level-plugins-and-config-for-apex%2F">Bluesky</a>, or <a class="twitter" target="_blank" rel="nofollow" href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fbrettterpstra.com%2F2026%2F01%2F28%2Fproject-level-plugins-and-config-for-apex%2F&text=Project-level+plugins+and+config+for+Apex&url=https%3A%2F%2Fbrettterpstra.com%2F2026%2F01%2F28%2Fproject-level-plugins-and-config-for-apex%2F&via=ttscoff" title="Tweet this post">Twitter</a>.</p>
<hr style="margin:40px 0">

<p>BrettTerpstra.com is supported by readers like you. <a href="https://brettterpstra.com/support/">Click here if you'd
        like to help out.</a></p>
<p>Find Brett on <a rel="me" href="https://hachyderm.io/@ttscoff">Mastodon</a>, <a
        href="https://bsky.app/profile/ttscoff.bsky.social">Bluesky</a>, <a
        href="https://github.com/ttscoff">GitHub</a>, and <a href="https://brettterpstra.com/elsewhere">everywhere
        else</a>.</p><img src="https://brett.trpstra.net/link/535/17265388.gif" height="1" width="1"/>