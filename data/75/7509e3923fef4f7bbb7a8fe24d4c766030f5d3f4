<p>I have a hard time keeping these terms straight:</p>
<ul>
<li>liveness vs. safety</li>
<li>soundness vs. completeness</li>
</ul>
<p>This is intended as a short guide for myself; maybe someone else will find it useful too! Note that this is all to the best of my knowledge and understanding at the present time; if there be faults, they be the faults of myself. I welcome correction and clarification if I am wrong.</p>
<h2 id="liveness-vs-safety">
  Liveness vs. Safety
  <a class="anchor" href="#liveness-vs-safety">#</a>
</h2>
<p>Liveness and safety deal with <em>properties</em> of a system. Contrast that with soundness and completion, which are adjectives about analyses.</p>
<h3 id="liveness">
  Liveness
  <a class="anchor" href="#liveness">#</a>
</h3>
<p>A <em>liveness</em> property of a system is of the form &ldquo;something good will eventually happen.&rdquo; One example is eventual consistency in a concurrent system: we want to know that, after some finite number of steps, our system comes to a consistent state of the world.</p>
<p>Another example might be with a bank: I want it to be the case that when I move money between accounts, the correct amount of money makes it to the destination account. That is something we want to eventually happen, and that&rsquo;s what makes it a liveness property.</p>
<h3 id="safety">
  Safety
  <a class="anchor" href="#safety">#</a>
</h3>
<p><em>Safety</em> is the dual of <em>liveness</em>: in contrast to liveness, a safety property states that &ldquo;something bad does not occur&rdquo;. One example of a safety property is in an operating system, nothing prevents the kernel from preempting a task. We never want to get stuck in a state where the kernel cannot regain control of the processor. If our operating system is safe in this regard, we know that we&rsquo;ll never have the case where a program supersedes the kernel.</p>
<p>Extending the bank analogy, a safety property might be that we never want money lost in a transaction. The program might occasionally fail to deliver money, but no value is accidentally destroyed during a transfer.</p>
<h2 id="soundness-vs-completeness">
  Soundness vs. Completeness
  <a class="anchor" href="#soundness-vs-completeness">#</a>
</h2>
<p>Soundness and completeness refer to whole systems that make some kind of decision, e.g. a type system or some kind of a static analysis.</p>
<h3 id="soundness">
  Soundness
  <a class="anchor" href="#soundness">#</a>
</h3>
<p>From <a href="https://en.wikipedia.org/wiki/Soundness">Wikipedia</a>:</p>
<blockquote>
<p>[A]n argument is sound if it is both valid in form and its premises are true. Soundness also has a related meaning in mathematical logic, wherein logical systems are sound if and only if every formula that can be proved in the system is logically valid with respect to the semantics of the system.</p></blockquote>
<p><em>Soundness</em> means the system is trustworthy. A sound type system, for example, will never tell you that a program is devoid of type errors when there are in fact type errors. Most type systems typically are sound. This means, however, that there are programs which may not contain a type error but that the type checker cannot prove to be devoid of errors.</p>
<p>Another term that may be used for soundness is <em>correct</em>. (Though, I believe, this may be highly context-dependent.)</p>
<h3 id="completeness">
  Completeness
  <a class="anchor" href="#completeness">#</a>
</h3>
<p>The dual of <em>soundness</em>: if a system is complete, it means the system can give an answer for every input. It might make some mistakes in reasoning. E.g. with a complete type system, there is no program which it cannot assign a type to (even if it&rsquo;s a divergent type) but an assertion that a program is type-safe is not necessarily true.</p>
<p>Why can&rsquo;t we have both soundness and completeness at the same time? GÃ¶del is to blame for that.</p>
