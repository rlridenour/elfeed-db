
         
         <p>Raw link: <a href="https://www.youtube.com/watch?v=X3fEO1_QDHA">https://www.youtube.com/watch?v=X3fEO1_QDHA</a></p>
         
         <p>This is a short video demonstration of how I tone down Org citations
using some custom code I wrote. I share the code and its annotated
version. See the following two sections.</p>

<h2>The code without any commentary</h2>

<p><strong>UPDATE 2024-12-26 20:02 +0200:</strong> I updated the code to include the
<code class="language-plaintext highlighter-rouge">save-excursion</code>, which I forgot to cover in my original publication.
The annotated version has the same update.</p>

<p><strong>UPDATE 2024-12-29 10:33 +0200:</strong> Also check the code of JD Smith,
which relies on the Org API to achieve this result:
<a href="https://gist.github.com/jdtsmith/d49eaaae852c5496a80e2489014bc41c">https://gist.github.com/jdtsmith/d49eaaae852c5496a80e2489014bc41c</a>.
In principle, this is a more reliable approach than using regular
expressions. Still, what I provide below is useful in general.</p>

<hr />

<p>The annotated version is in the next section.</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defvar</span> <span class="nv">prot-org-cite-regexp</span>
  <span class="s">"\\(?1:cite: ?\\)?\\(?2:@\\)\\(?:[a-z]+\\)\\(?3:.*?\\)\\(?:[0-9]\\{4,\\}\\)\\(?:[a-z]\\)?"</span>
  <span class="s">"Regular expression matching an Org citation.
Groups 1, 2, and 3 are meant to be hidden when the minor mode
`prot-org-cite-mode' is enabled."</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">prot-org-cite-add-overlays</span> <span class="p">()</span>
  <span class="s">"Add invisible overlays to `prot-org-cite-regexp' numbered groups."</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">case-fold-search</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">save-excursion</span>
      <span class="p">(</span><span class="nv">save-restriction</span>
        <span class="p">(</span><span class="nv">widen</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">goto-char</span> <span class="p">(</span><span class="nv">point-min</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nv">re-search-forward</span> <span class="nv">prot-org-cite-regexp</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">n</span> <span class="mi">4</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">when-let*</span> <span class="p">((</span><span class="nv">beg</span> <span class="p">(</span><span class="nv">match-beginning</span> <span class="nv">n</span><span class="p">))</span>
                          <span class="p">(</span><span class="nv">end</span> <span class="p">(</span><span class="nv">match-end</span> <span class="nv">n</span><span class="p">))</span>
                          <span class="p">(</span><span class="nv">overlay</span> <span class="p">(</span><span class="nv">make-overlay</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
                <span class="p">(</span><span class="nv">overlay-put</span> <span class="nv">overlay</span> <span class="ss">'invisible</span> <span class="no">t</span><span class="p">)</span>
                <span class="c1">;; NOTE: I am not using the `after-string' in this case,</span>
                <span class="c1">;; but am adding here as it is a useful paradigm in</span>
                <span class="c1">;; general.</span>
                <span class="c1">;;</span>
                <span class="c1">;; (overlay-put overlay 'after-string "")</span>
                <span class="p">(</span><span class="nv">overlay-put</span> <span class="nv">overlay</span> <span class="ss">'prot-org-cite-overlay</span> <span class="no">t</span><span class="p">)))))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">prot-org-cite-remove-overlays</span> <span class="p">()</span>
  <span class="s">"Remove all `prot-org-cite-overlay' overlays from the current buffer."</span>
  <span class="p">(</span><span class="nv">when-let*</span> <span class="p">((</span><span class="nv">overlays</span> <span class="p">(</span><span class="nv">save-restriction</span>
                          <span class="p">(</span><span class="nv">widen</span><span class="p">)</span>
                          <span class="p">(</span><span class="nv">overlays-in</span> <span class="p">(</span><span class="nv">point-min</span><span class="p">)</span> <span class="p">(</span><span class="nv">point-max</span><span class="p">))))</span>
              <span class="p">(</span><span class="nv">our-overlays</span> <span class="p">(</span><span class="nv">seq-filter</span>
                             <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">overlay</span><span class="p">)</span>
                               <span class="p">(</span><span class="nv">overlay-get</span> <span class="nv">overlay</span> <span class="ss">'prot-org-cite-overlay</span><span class="p">))</span>
                             <span class="nv">overlays</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">mapc</span> <span class="nf">#'</span><span class="nv">delete-overlay</span> <span class="nv">our-overlays</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">defface</span> <span class="nv">prot-org-cite</span> <span class="o">'</span><span class="p">((</span><span class="no">t</span> <span class="ss">:inherit</span> <span class="nb">shadow</span><span class="p">))</span>
  <span class="s">"Face for Org citations when `prot-org-cite-mode' is enabled."</span><span class="p">)</span>

<span class="p">(</span><span class="nv">defvar-local</span> <span class="nv">prot-org-cite-face-remap-object</span> <span class="no">nil</span>
  <span class="s">"Object of `face-remap-add-relative' for `prot-org-cite'."</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">prot-org-cite-remap-face</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="nv">unmap</span><span class="p">)</span>
  <span class="s">"Remap the `org-cite-key' face to `prot-org-cite'.
With optional UNMAP, undo the remapping."</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">unmap</span>
      <span class="p">(</span><span class="k">progn</span>
        <span class="p">(</span><span class="nv">face-remap-remove-relative</span> <span class="nv">prot-org-cite-face-remap-object</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">setq-local</span> <span class="nv">prot-org-cite-face-remap-object</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">setq-local</span> <span class="nv">prot-org-cite-face-remap-object</span>
                <span class="p">(</span><span class="nv">face-remap-add-relative</span> <span class="ss">'org-cite-key</span> <span class="ss">'prot-org-cite</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">define-minor-mode</span> <span class="nv">prot-org-cite-mode</span>
  <span class="s">"Partially hide Org citations and style them with `prot-org-cite'.
More specifically, hide groups 1, 2, and 3 of `prot-org-cite-regexp'."</span>
  <span class="ss">:global</span> <span class="no">nil</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">prot-org-cite-mode</span>
      <span class="p">(</span><span class="k">progn</span>
        <span class="p">(</span><span class="nv">prot-org-cite-add-overlays</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">prot-org-cite-remap-face</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">prot-org-cite-remove-overlays</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">prot-org-cite-remap-face</span> <span class="ss">:unmap-the-face</span><span class="p">)))</span>
</code></pre></div></div>

<h2>Annotated version of <code class="language-plaintext highlighter-rouge">prot-org-cite-mode</code></h2>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; This defines the `prot-org-cite-regexp' variable.  Its value is a</span>
<span class="c1">;; regular expression (Emacs Lisp).  The official manual of Emacs</span>
<span class="c1">;; covers the technicalities.  You will notice that we number some the</span>
<span class="c1">;; groups.  They are the ones we care about.  The rest are ignored.</span>
<span class="c1">;;</span>
<span class="c1">;; We can use the command `re-builder' to test our Emacs Lisp regular</span>
<span class="c1">;; expression in the current buffer.</span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">prot-org-cite-regexp</span>
  <span class="s">"\\(?1:cite: ?\\)?\\(?2:@\\)\\(?:[a-z]+\\)\\(?3:.*?\\)\\(?:[0-9]\\{4,\\}\\)\\(?:[a-z]\\)?"</span>
  <span class="s">"Regular expression matching an Org citation.
Groups 1, 2, and 3 are meant to be hidden when the minor mode
`prot-org-cite-mode' is enabled."</span><span class="p">)</span>

<span class="c1">;; Here we define a function that overlays.  An "overlay" is an object</span>
<span class="c1">;; that covers a certain region in the buffer.  A "region" is the</span>
<span class="c1">;; space between two buffer positions.  Overlays have a number of</span>
<span class="c1">;; uses.  The one we are interested in here is to make their regions</span>
<span class="c1">;; invisible, thus hiding the affected text.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">prot-org-cite-add-overlays</span> <span class="p">()</span>
  <span class="s">"Add invisible overlays to `prot-org-cite-regexp' numbered groups."</span>
  <span class="c1">;; For the purposes of this operation, we want to make sure that our</span>
  <span class="c1">;; search is case-sensitive.  We thus `let' bind the `case-fold-search'</span>
  <span class="c1">;; variable to a nil value.  Otherwise, our results will depend on the</span>
  <span class="c1">;; user's configuration.</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">case-fold-search</span> <span class="no">nil</span><span class="p">))</span>
    <span class="c1">;; Our code will have the side effect of changing the position of</span>
    <span class="c1">;; the cursor (technically, the "point").  This is needed for our</span>
    <span class="c1">;; purposes, but the user will ultimately want the changes to</span>
    <span class="c1">;; happen without them losing their context.  The `save-excursion'</span>
    <span class="c1">;; allows us to move the point and then trust that Emacs will</span>
    <span class="c1">;; restore it to where it was before.</span>
    <span class="p">(</span><span class="nv">save-excursion</span>
      <span class="c1">;; We want to operate in the entire buffer.  But the user may have</span>
      <span class="c1">;; already narrowed to a portion thereof.  To respect their choice</span>
      <span class="c1">;; while still doing the right thing, we have to wrap our code in</span>
      <span class="c1">;; `save-restriction' and then `widen' the view.  This means that</span>
      <span class="c1">;; our subsequent calls will run in the unnarrowed buffer and the</span>
      <span class="c1">;; narrowing will be restored once we are done.</span>
      <span class="p">(</span><span class="nv">save-restriction</span>
        <span class="p">(</span><span class="nv">widen</span><span class="p">)</span>
        <span class="c1">;; We start from the minimum visible position in the buffer.</span>
        <span class="c1">;; Since we widened the view in the previous line of code, this</span>
        <span class="c1">;; is the beginning of the buffer.  Otherwise, it would have</span>
        <span class="c1">;; been the beginning of the narrowed portion of the buffer.</span>
        <span class="p">(</span><span class="nv">goto-char</span> <span class="p">(</span><span class="nv">point-min</span><span class="p">))</span>
        <span class="c1">;; Starting from the top, we perform a search forward for the</span>
        <span class="c1">;; `prot-org-cite-regexp'.  We do this in a loop.  The loop</span>
        <span class="c1">;; works (i.e. is not infinite) because (i) the search has the</span>
        <span class="c1">;; side effect of moving the point to the end of the match so</span>
        <span class="c1">;; the search does not get stuck in one place, and (ii) we pass</span>
        <span class="c1">;; the relevant argument to `re-search-forward' to return nil if</span>
        <span class="c1">;; there is no match, instead of throwing an error.  The loop</span>
        <span class="c1">;; only runs when its condition is non-nil.</span>
        <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nv">re-search-forward</span> <span class="nv">prot-org-cite-regexp</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
          <span class="c1">;; Here I had to make a stylistic decision.  We want to add</span>
          <span class="c1">;; overlays for the three numbered groups in our regular</span>
          <span class="c1">;; expression.  I could have arranged to do this with another</span>
          <span class="c1">;; `while', which would have its own local counter, but I</span>
          <span class="c1">;; thought it would make the code a bit harder to read for our</span>
          <span class="c1">;; purposes here.  So I am using `dotimes' instead, whose</span>
          <span class="c1">;; semantics are in line with what we are doing, i.e. run</span>
          <span class="c1">;; something N times.  The part about `dotimes' that I do not</span>
          <span class="c1">;; like is that it starts from 0 and its maximum number is</span>
          <span class="c1">;; exclusive, meaning that we only get up to 3 even though we</span>
          <span class="c1">;; have the 4 there.  Someone who is not familiar with this</span>
          <span class="c1">;; behaviour will thus find the following perplexing.</span>
          <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">n</span> <span class="mi">4</span><span class="p">)</span>
            <span class="c1">;; The group 0 in a regular expression is a special number</span>
            <span class="c1">;; which refers to the entire match.  We do not want to do</span>
            <span class="c1">;; anything with that.  We only care about numbers 1, 2, 3.</span>
            <span class="c1">;; Thus, the first run of this `dotimes' does nothing other</span>
            <span class="c1">;; than increment 0 to 1 and run again.</span>
            <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
              <span class="c1">;; Before we start adding our overlays, we need to be sure</span>
              <span class="c1">;; that there is a match for the Nth group in our regular</span>
              <span class="c1">;; expression.  If there is none, we skip it and move on</span>
              <span class="c1">;; with our loop.  If there is a match, then we store its</span>
              <span class="c1">;; beginning and end positions and then make an overlay</span>
              <span class="c1">;; that stretches between those two.</span>
              <span class="p">(</span><span class="nv">when-let*</span> <span class="p">((</span><span class="nv">beg</span> <span class="p">(</span><span class="nv">match-beginning</span> <span class="nv">n</span><span class="p">))</span>
                          <span class="p">(</span><span class="nv">end</span> <span class="p">(</span><span class="nv">match-end</span> <span class="nv">n</span><span class="p">))</span>
                          <span class="p">(</span><span class="nv">overlay</span> <span class="p">(</span><span class="nv">make-overlay</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
                <span class="c1">;; Now that we have created our overlay, we are ready to</span>
                <span class="c1">;; associated properties with it.  These are symbols</span>
                <span class="c1">;; that may already have an internal meaning, such as</span>
                <span class="c1">;; `invisible' or arbitrary symbols that we can use for</span>
                <span class="c1">;; our own purposes later.  Each time we set a property,</span>
                <span class="c1">;; we specify its value.  In principle, we could have a</span>
                <span class="c1">;; fine-grained system with different values, though all</span>
                <span class="c1">;; we need here is something that returns non-nil.</span>
                <span class="p">(</span><span class="nv">overlay-put</span> <span class="nv">overlay</span> <span class="ss">'invisible</span> <span class="no">t</span><span class="p">)</span>
                <span class="c1">;; I keep the `after-string' overlay property here for</span>
                <span class="c1">;; this demonstration.  We do not need it, though it is</span>
                <span class="c1">;; how we can add an arbitrary string in the stead of</span>
                <span class="c1">;; the text we made invisible (think of how Org folds</span>
                <span class="c1">;; its headings, for example).</span>
                <span class="c1">;;</span>
                <span class="c1">;; (overlay-put overlay 'after-string "")</span>

                <span class="c1">;; Finally, we want to make our overlays have a unique</span>
                <span class="c1">;; property that allows us to identify them later.  I</span>
                <span class="c1">;; have called this `prot-org-cite-overlay', though it</span>
                <span class="c1">;; has no inherent meaning.  What matters is that it is</span>
                <span class="c1">;; unambiguously ours and that it has a non-nil value.</span>
                <span class="p">(</span><span class="nv">overlay-put</span> <span class="nv">overlay</span> <span class="ss">'prot-org-cite-overlay</span> <span class="no">t</span><span class="p">)))))))))</span>

<span class="c1">;; This is the function which reverts `prot-org-cite-add-overlays'.</span>
<span class="c1">;; You will notice the same pattern of `save-restriction' for the</span>
<span class="c1">;; aforementioned reasons.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">prot-org-cite-remove-overlays</span> <span class="p">()</span>
  <span class="s">"Remove all `prot-org-cite-overlay' overlays from the current buffer."</span>
  <span class="p">(</span><span class="nv">when-let*</span> <span class="p">((</span><span class="nv">overlays</span> <span class="p">(</span><span class="nv">save-restriction</span>
                          <span class="p">(</span><span class="nv">widen</span><span class="p">)</span>
                          <span class="p">(</span><span class="nv">overlays-in</span> <span class="p">(</span><span class="nv">point-min</span><span class="p">)</span> <span class="p">(</span><span class="nv">point-max</span><span class="p">))))</span>
              <span class="c1">;; Here we go through the whole list of overlays to</span>
              <span class="c1">;; identify those which are ours.  Without this</span>
              <span class="c1">;; filtering, we could/would cause something to break.</span>
              <span class="p">(</span><span class="nv">our-overlays</span> <span class="p">(</span><span class="nv">seq-filter</span>
                             <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">overlay</span><span class="p">)</span>
                               <span class="p">(</span><span class="nv">overlay-get</span> <span class="nv">overlay</span> <span class="ss">'prot-org-cite-overlay</span><span class="p">))</span>
                             <span class="nv">overlays</span><span class="p">)))</span>
    <span class="c1">;; Now that we have found all our overlays, let us delete them.</span>
    <span class="p">(</span><span class="nb">mapc</span> <span class="nf">#'</span><span class="nv">delete-overlay</span> <span class="nv">our-overlays</span><span class="p">)))</span>

<span class="c1">;; The default style for Org citations is like that of links.  In</span>
<span class="c1">;; general, this is fine though our mode is designed to tone down the</span>
<span class="c1">;; citations.  We thus define our custom face, which inherits from the</span>
<span class="c1">;; `shadow' face.  We will apply this in the buffer where `prot-org-cite-mode'</span>
<span class="c1">;; is enabled.</span>
<span class="p">(</span><span class="nv">defface</span> <span class="nv">prot-org-cite</span> <span class="o">'</span><span class="p">((</span><span class="no">t</span> <span class="ss">:inherit</span> <span class="nb">shadow</span><span class="p">))</span>
  <span class="s">"Face for Org citations when `prot-org-cite-mode' is enabled."</span><span class="p">)</span>

<span class="c1">;; The technicalities of how to apply a face instead of another are</span>
<span class="c1">;; covered by the function `face-remap-add-relative'.  Its return</span>
<span class="c1">;; value is a special object that we need to store, such that we can</span>
<span class="c1">;; remove it afterwards.  You will notice how this declaration of the</span>
<span class="c1">;; variable has the "local" specifier, meaning that `setq' is</span>
<span class="c1">;; functionally equivalent to `setq-local' (I still write the latter,</span>
<span class="c1">;; because I prefer the code to be more explicit about what it is</span>
<span class="c1">;; doing).</span>
<span class="p">(</span><span class="nv">defvar-local</span> <span class="nv">prot-org-cite-face-remap-object</span> <span class="no">nil</span>
  <span class="s">"Object of `face-remap-add-relative' for `prot-org-cite'."</span><span class="p">)</span>

<span class="c1">;; This function sets up the `face-remap-add-relative' that I</span>
<span class="c1">;; mentioned in the previous comment.  We could have defined a</span>
<span class="c1">;; separate function for undoing this effect, though I considered it</span>
<span class="c1">;; pertinent to demonstrate the use of optional parameters.  Anything</span>
<span class="c1">;; after the `&amp;optional' defaults to nil if it is not supplied as an</span>
<span class="c1">;; argument.  So we can call the function without it, but we can also</span>
<span class="c1">;; furnish the argument if we need to.</span>
<span class="c1">;;</span>
<span class="c1">;; The UNMAP we define here does not treat its value specially.  Any</span>
<span class="c1">;; non-nil value will suffice.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">prot-org-cite-remap-face</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="nv">unmap</span><span class="p">)</span>
  <span class="s">"Remap the `org-cite-key' face to `prot-org-cite'.
With optional UNMAP, undo the remapping."</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">unmap</span>
      <span class="p">(</span><span class="k">progn</span>
        <span class="p">(</span><span class="nv">face-remap-remove-relative</span> <span class="nv">prot-org-cite-face-remap-object</span><span class="p">)</span>
        <span class="c1">;; As I noted before, the `defvar-local' makes it so that we do</span>
        <span class="c1">;; not need to write `setq-local', as `setq' will do the same</span>
        <span class="c1">;; thing.  I still prefer to be unambiguous.</span>
        <span class="p">(</span><span class="nv">setq-local</span> <span class="nv">prot-org-cite-face-remap-object</span> <span class="no">nil</span><span class="p">))</span>
    <span class="c1">;; In this call we see how the value of the variable</span>
    <span class="c1">;; `prot-org-cite-face-remap-object' is set to the return value of</span>
    <span class="c1">;; the `face-remap-add-relative' function call.  So we get the</span>
    <span class="c1">;; side effect of the remap, while we also store the return value.</span>
    <span class="p">(</span><span class="nv">setq-local</span> <span class="nv">prot-org-cite-face-remap-object</span>
                <span class="p">(</span><span class="nv">face-remap-add-relative</span> <span class="ss">'org-cite-key</span> <span class="ss">'prot-org-cite</span><span class="p">))))</span>

<span class="c1">;; All we need to do now is put everything together.  Our minor mode</span>
<span class="c1">;; is, at its core, a simple toggle to do/undo our stylistic changes.</span>
<span class="c1">;; The :global keyword specifies whether our mode has effect across</span>
<span class="c1">;; all buffers, but ours is buffer-local because of the nil value we</span>
<span class="c1">;; specify.</span>
<span class="p">(</span><span class="nv">define-minor-mode</span> <span class="nv">prot-org-cite-mode</span>
  <span class="s">"Partially hide Org citations and style them with `prot-org-cite'.
More specifically, hide groups 1, 2, and 3 of `prot-org-cite-regexp'."</span>
  <span class="ss">:global</span> <span class="no">nil</span>
  <span class="c1">;; What the `define-minor-mode' does behind the scenes is to define</span>
  <span class="c1">;; an interactive function (a "command") and a variable that use the</span>
  <span class="c1">;; same symbol, `prot-org-cite-mode' in this case.  There is no</span>
  <span class="c1">;; clash, as Emacs has separate namespaces for functions and</span>
  <span class="c1">;; variables.  Then, when we call the command it sets its</span>
  <span class="c1">;; corresponding variable to a non-nil or nil value, so the rest of</span>
  <span class="c1">;; our logic runs accordingly.</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">prot-org-cite-mode</span>
      <span class="c1">;; The `progn' is our way of saying "those multiple calls are a</span>
      <span class="c1">;; bundle, so treat them as one".  This is necessary to write an</span>
      <span class="c1">;; `if' statement (among others), because the THEN part has to</span>
      <span class="c1">;; be one argument.  But the ELSE part does not need the `progn'</span>
      <span class="c1">;; because of a special behaviour which automatically treats all</span>
      <span class="c1">;; remaining arguments as a single list.  In Emacs Lisp</span>
      <span class="c1">;; functions, this is achieved by the `&amp;rest' keyword (well, the</span>
      <span class="c1">;; `if' in particular does not use `&amp;rest' because it is written</span>
      <span class="c1">;; in C, though you will see that in plenty of places).</span>
      <span class="p">(</span><span class="k">progn</span>
        <span class="p">(</span><span class="nv">prot-org-cite-add-overlays</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">prot-org-cite-remap-face</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">prot-org-cite-remove-overlays</span><span class="p">)</span>
    <span class="c1">;; As I wrote in my commentary about the optional parameter of</span>
    <span class="c1">;; `prot-org-cite-remap-face', it does not treat its value in any</span>
    <span class="c1">;; special way.  What matters is for it to be non-nil.  In cases</span>
    <span class="c1">;; like this one, I prefer to use a :KEYWORD, which can be any</span>
    <span class="c1">;; arbitrary text: it always evaluates to itself, i.e. it is</span>
    <span class="c1">;; non-nil (same for symbols, though a keyword in this context is</span>
    <span class="c1">;; generally less ambiguous).</span>
    <span class="p">(</span><span class="nv">prot-org-cite-remap-face</span> <span class="ss">:unmap-the-face</span><span class="p">)))</span>
</code></pre></div></div>
        
      