<div id="outline-container-orgbb236cc" class="outline-2">
<h2 id="orgbb236cc">Early LISP history (1956–1959)</h2>
<div class="outline-text-2" id="text-orgbb236cc">
<p>
Herbert Stoyan.  <i><a href="https://doi.org/10.1145/800055.802047">Early Lisp History (1956–1959)</a></i>. In <i>LFP ’84:
Proceedings of the 1984 ACM Symposium on Lisp and Functional
Programming</i>, pp.299–310. 1984.
</p>

<p>
A study of Lisp's evolution from first proposal to practical
implementation.
</p>

<p>
It begins with McCarthy's proposal (co-authored with Marvin
Minsky, Nathaniel Rochester, and Claude Shannon, and dated 31
August 1955) for a summer research project at Dartmouth College to
"study the relationship of language to intelligence".
</p>

<p>
In a later (handwritten!) note McCarthy homed-in on the core
challenges in this programme: the lack of a clear way to describe
<i>procedures</i> to each other (what <a href="https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/">Abelson and Sussman</a> later refer to
as <i>procedural epistemology</i>), and the tight binding of programming
systems at that time to specific machines, and hence their need to
bow to engineering (rather than semantic) considerations. The
language that became Lisp sought primarily to overcome these two
challenges.
</p>

<p>
The journey proceeded by taking the list data structures developed
by Allen Newell and Herb Simon as part of <a href="https://en.wikipedia.org/wiki/Logic_Theorist">Logic Theorist</a> and
embedding them into FORTRAN (for which there was already a working
compiler) – which also incidentally muddied the conceptual waters
by trying to express list and list-functional concepts in a
language built around numbers that barely allowed functions to be
defined by the user at all. Indeed, McCarthy and others had
long-running problems accepting that the list-processing functions
<i>were</i> functions, given that their result does not depend solely on
their arguments when viewed at the lowest level. This shows how
pernicious a low-level implementation can be. The final resulting
language, the FORTRAN List Processing Language (FLPL), shared many
programming approaches function names with what became Lisp.
</p>

<p>
McCarthy went on to champion the functional approach, including
the invention of conditional expressions (alongside or replacing
conditional statements) and the power of the different kinds of
function composition and higher-order functions. It's important to
remember that McCarthy's driving interest remained in AI, not
programming languages <i>per se</i>:
</p>

<blockquote>
<p>
Already in 1956 it was clear that one had to work with symbolic
expressions to reach the goal of artificial intelligence.
</p>
</blockquote>

<p>
Which is a fascinating piece of history in itself, as a large
branch of modern AI concerning machine learning and large language
models has explicit rejects this view in favour of sub-symbolic
AI. Which approach is "correct" in whatever sense remains to be
seen.
</p>

<p>
But it remains McCarthy's contributions to programming languages
that stand out. As well as conditional expressions he can be
credited with garbage collection, meta-circular interpretation,
and clarifying the relationship between programming and proof:
</p>

<blockquote>
<p>
We should mention here that McCarthy at the same time conceived the
idea of logic-oriented programming, that is, the idea of using logical
formulae to express goals that a program should try to establish and
of using the prover as programming language interpreter.
</p>
</blockquote>

<p>
(Although it's important to recognise that Newell and Simon's
work, on logic as an application rather than as a general
programming language, pre-dates McCarthy's.)
</p>
</div>
</div>