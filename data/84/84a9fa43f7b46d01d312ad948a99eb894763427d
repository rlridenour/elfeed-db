<div>    <p><em>2022 Update</em>: I have since made <a href="./testing-buffer-modifying-emacs-code-again">an improved version</a> of the code in this article. This article is still useful to read as motivation for the problem.</p></div><hr/><p>I was writing some functions to change variable names from <code>camelCase</code> to <code>snake_case</code>, and back again. (For some reason, Java code uses <code>camelCase</code>, and SQL colmns are named with <code>snake_case</code>) Because this was nontrivial code, I wanted to test it.</p><p>If the functions took a string as an argument, and returned the modified value, I'd be able to write some simple tests. These tests would call the function on some strings, and check the return value. But instead, the functions we want to test modify the buffer instead of returning a value. So what can we do to test this code? We could rewrite the functions to be small wrappers around functions that do the "actual work" of changing cases. It would be unfortunate to have to rewrite the code to be able to test it, but at least we'd be able to write some tests.</p><p>But even wrapping the functions this way wouldn't be enough! The functions change <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Point.html">point</a>, which is not testable by checking the return value from such a wrapped function!</p><p>What would I do if I was testing it by hand? I'd insert some text in a buffer, call my function on it to modify the buffer. I'd then examine the text in the buffer. Here's the outline of what I want to do:</p><pre><code>In a temp buffer:  insert text  move point to the beginning of the buffer  call the function being tested  return the entire buffer as a string</code></pre><p>That maps to emacs lisp code straightforwardly:</p><pre><code>(with-temp-buffer  (insert "hi_mom")  (goto-char (point-min))  (camelcase-dwim 1)  (buffer-string))</code></pre><p>Great! This code now calls our function under test on a specific input string, and returns the value of the buffer at the end. Let's set it up as an <a href="https://www.gnu.org/software/emacs/manual/html_node/ert/index.html">ERT test</a>:</p><pre><code>(ert-deftest camelcase-dwim/single-word-from-snake-case ()  (should (equal "hiMom"                 (with-temp-buffer                   (insert "hi_mom")                   (goto-char (point-min))                   (camelcase-dwim 1)                   (buffer-string)))))</code></pre><p>But look how repetitive a second test would be!</p><pre><code>(ert-deftest camelcase-dwim/two-words-from-snake-case ()  (should (equal "hiMom howAreYou"                 (with-temp-buffer                   (insert "hi_mom how_are_you")                   (goto-char (point-min))                   (camelcase-dwim 2)                   (buffer-string)))))</code></pre><p>That's a lot of copied code. Let's write a macro that does this for us:</p><pre><code>(defmacro on-temp-buffer (string &rest body)  "Insert STRING into a temp buffer, then run BODY on the temp buffer.Point starts at the beginning of the buffer, and after running BODY,the entire buffer is returned as a string."  (declare (indent 0) (debug t))  `(with-temp-buffer     (insert ,string)     (goto-char (point-min))     ,@body     (buffer-string)))</code></pre><p>Now, the test code is much shorter:</p><pre><code>(ert-deftest camelcase-dwim/single-word-from-snake-case ()  (should (equal "hiMom"                 (on-temp-buffer                   "hi_mom"                   (camelcase-dwim 1)))))</code></pre><p>Awesome, this test is now way easier to read because it only has the logic we care about. But we're not done. Remember that <code>#'camelcase-dwim</code> moves point? I want to make sure point is moved to the right place. So I wrote a similar macro which returns <code>(point)</code> instead of <code>(buffer-string)</code>:</p><pre><code>(defmacro on-temp-buffer-point (string &rest body)  "Insert STRING into a temp buffer, then run BODY on the temp buffer.Point starts at the beginning of the buffer, and after running BODY,\(point) is returned."  (declare (indent 0) (debug t))  `(with-temp-buffer     (insert ,string)     (goto-char (point-min))     ,@body     (point)))</code></pre><p>It can be used as follows:</p><pre><code>(ert-deftest camelcase-dwim/basic-snake-case-with-other-words-check-point ()  (should (equal 6                 (on-temp-buffer-point                   "hi_mom and_other stuff"                   (camelcase-dwim 1)))))</code></pre><p>So now we have two macros that can be used to test code that modifies an Emacs buffer, without having to change the functions being tested. And that's our goal.</p>