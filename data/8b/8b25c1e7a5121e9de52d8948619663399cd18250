The need: take multiple vectors and view each vector as a column (not a row) of the data, so all the first items go together, all the second, etc. Here&rsquo;s a rough version that felt too clunky (alert: it features a number) and fragile but happens to demonstrate the needs:
(let [[names jobs langs :as all] [[&#34;john&#34; &#34;jane&#34; &#34;michael&#34;] [&#34;chef&#34; &#34;driver&#34; &#34;vet&#34;] [&#34;English&#34; &#34;German&#34; &#34;French&#34;]]] (map #(zipmap [:name :job :lang] %) (partition 3 (interleave names jobs langs)))) ;; ({:name &#34;john&#34;, :job &#34;chef&#34;, :lang &#34;English&#34;}  ;; {:name &#34;jane&#34;, :job &#34;driver&#34;, :lang &#34;German&#34;}  ;; {:name &#34;michael&#34;, :job &#34;vet&#34;, :lang &#34;French&#34;}) Solution (let [[names jobs langs :as all] [[&#34;john&#34; &#34;jane&#34; &#34;michael&#34;] [&#34;chef&#34; &#34;driver&#34; &#34;vet&#34;] [&#34;English&#34; &#34;German&#34; &#34;French&#34;]]] (apply map #(zipmap [:name :job :lang] %&amp;) all)) ;; =&gt; ({:name &#34;john&#34;, :job &#34;chef&#34;, :lang &#34;English&#34;} {:name &#34;jane&#34;, :job &#34;driver&#34;, :lang &#34;German&#34;} {:name &#34;michael&#34;, :job &#34;vet&#34;, :lang &#34;French&#34;}) This solution taught me two new things: