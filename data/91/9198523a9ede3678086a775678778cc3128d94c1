<p>As an Emacs user, you&rsquo;re always hunting for ways to shave milliseconds off common tasks and generally noodling around and shaving some more of that yak!. File switching is one of those operations you do hundreds of times a day, so even small improvements compound dramatically. Today, I want to share a workflow that I have been tinkering with that combines the best of Emacs&rsquo;s built-in recent file tracking with modern completion interfaces.</p>
<figure><img src="https://emacs.dyerdwelling.family/ox-hugo/20250815071935-emacs--Fast-File-Navigation-in-Emacs.jpg" width="100%">
</figure>

<p>Emacs gives us several ways out of the box to quickly access files:</p>
<ul>
<li>find-file</li>
<li>switch-to-buffer for open buffers</li>
<li>Registers</li>
<li>Bookmarks</li>
<li>recentf-mode for recently accessed files</li>
</ul>
<p>and I have a funny feeling there are probably more.</p>
<p>Each has its place, but they all have limitations. switch-to-buffer only shows currently open buffers, and with fido-mode, I have found that the most frequently used buffers don&rsquo;t always bubble to the top predictably, I may need to look a little more into this though. Registers are great but require manual setup and only remember the position when you set them, not your last edit location.</p>
<p>What I really wanted was instant access to my recently edited files, with each file opening exactly where I left off!</p>
<p>I thought I had become quite efficient at file switching through fido completion and dired but only recently I realised I was navigating through dired to find files way too often and wasting time.  I think this is probably typical of an Emacsers journey and after a while of continuous minor toil there comes a time to take action and shave off those milliseconds and improve flow.</p>
<p>The solution starts by enabling two built-in  Emacs features:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elisp" data-lang="elisp"><span style="display:flex;"><span>(save-place-mode <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>(recentf-mode <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>(setq recentf-max-menu-items <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>(setq recentf-max-saved-items <span style="color:#ae81ff">10</span>)
</span></span></code></pre></div><p>save-place-mode automatically remembers your cursor position in every file and restores it when you reopen the file, it was the first time I had heard of this when figuring all this out and couldn&rsquo;t believe I didn&rsquo;t know about it before (not an uncommon Emacs experience), this works across Emacs sessions, so you get that &ldquo;pick up exactly where I left off&rdquo; experience.</p>
<p>And recentf-mode maintains a persistent list of recently visited files, ordered chronologically. Unlike switch-to-buffer, this survives Emacs restarts and gives you a true history of your work and I thought in this case it better to limit the list size as much as possible for greater clarity.</p>
<p>The traditional recentf-open-files command shows a nice ordered list in a buffer but to some it could feel clunky compared to modern completion interfaces.  There is also recentf-open which does go through completing read but then reorders the recentf list for some reason, so to me the obvious solution is to push the recent files list through completing-read myself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elisp" data-lang="elisp"><span style="display:flex;"><span>(defun my/fido-recentf ()
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Use fido to select from recently opened files.&#34;</span>
</span></span><span style="display:flex;"><span>  (interactive)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">completing-read</span> <span style="color:#e6db74">&#34;Recent file: &#34;</span> recentf-list <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">t</span> <span style="color:#66d9ef">nil</span> <span style="color:#e6db74">&#39;recentf-list</span>))
</span></span></code></pre></div><p>To get this to work the way I wanted, I had to supply recentf-list also as the last argument. By using the same symbol for both the collection and the history, we tell the completion system to respect the original ordering. Your most recently accessed files should stay at the top!</p>
<p>In my final solution I have decided to keep the old recentf-open-files interface as an option. Strangely I actually like the old list in a buffer interface so I have included it in my final version as an option.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elisp" data-lang="elisp"><span style="display:flex;"><span>(defun my/fido-recentf (arg)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Use fido to select from recently opened files.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">With universal argument, use the traditional recentf-open-files interface.&#34;</span>
</span></span><span style="display:flex;"><span>  (interactive <span style="color:#e6db74">&#34;P&#34;</span>)
</span></span><span style="display:flex;"><span>  (if arg
</span></span><span style="display:flex;"><span>      (recentf-open-files)
</span></span><span style="display:flex;"><span>    (find-file (<span style="color:#a6e22e">completing-read</span> <span style="color:#e6db74">&#34;Recent file: &#34;</span> recentf-list <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">t</span> <span style="color:#66d9ef">nil</span> <span style="color:#e6db74">&#39;recentf-list</span>))))
</span></span></code></pre></div><p>Now M-x my/fido-recentf gives you completing read, while C-u M-x my/fido-recentf drops you into the classic numbered list.</p>
<p>Bind this to something convenient (I use M-o) and your file navigation transforms! (well that might be a bit of an exaggeration)</p>
<p>This might seem like a small optimization, but it exemplifies what makes Emacs special. We&rsquo;re not just using the tools as shipped, we&rsquo;re composing them in novel ways to create something perfectly tailored to our needs.</p>
<p>That&rsquo;s the kind of workflow improvement that makes every day at the keyboard just a little bit more pleasant, and those small pleasures add up to something significant over months and years of coding.</p>
