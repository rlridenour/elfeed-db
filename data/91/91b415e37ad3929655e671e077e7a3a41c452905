<p>This is the nineteenth post in the <a href="/blog/fastmail-advent-2024/">Fastmail Advent 2024</a> series. The previous post was <a href="/blog/offline-sync/">Dec 18: Building offline: syncing changes back to the server</a>. The next post is <a href="/blog/how-fastmail-uses-fastmail/">Dec 20: How Fastmail uses Fastmail!</a>.</p><p>Yesterday, we looked at <a href="/blog/offline-sync/">how we store changes you make offline</a> so we can accurately and efficiently sync them back to the server when you come online. Today, we’ll discuss why email is special, and what else we do to make this super fast, with support for full-text search offline.</p><h2 id="why-offline-email-is-hard" tabindex="-1">Why offline email is hard</h2><p>As discussed earlier, because we use JMAP for all of our APIs, once we can implement generic offline support and have it work for everything (currently 56 data types and counting in our app!). However, mail is special. And the reason it’s special is purely the volume of data.</p><p>Most web apps severely underestimate how small their data is. In almost all cases, you will be more efficient and way faster to just suck it all into memory and do a linear filter pass whenever you need to query it. This is the difference between response as-you-type autocomplete and frustrating loading spinners on each key stroke. Even for users with 10,000 contacts this is only a few megabytes of data — perfectly cacheable.</p><p>Email is different though. We have users with millions of messages. Even with attachments handled separately in JMAP, each message could have hundreds of kilobytes of HTML as the body. But we expect opening a mailbox to load a listing pretty much instantly, and searches to be fast too. To make this work, we have to add a number of tricks to our standard offline approach.</p><h2 id="splitting-the-data" tabindex="-1">Splitting the data</h2><p>The first trick is to split the data into two separate <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore" target="_blank" rel="noopener">object stores</a>:</p><ol> <li> <p><strong>EmailMetadata</strong>: this stores just the data that’s not parsed from the email content, like the id, thread id, keywords it has, and mailboxes it’s in. This keeps it small, but crucially also contains all the mutable data. This is treated like our standard JMAP object store for a data type.</p> </li> <li> <p><strong>EmailContent</strong>: this stores the email content; who it was sent from/to, the subject, body, list of attachments (but not the attachment data itself) etc.</p> </li> </ol><p>Due to the volume of data, we can’t load everything at once. We page in the data in stages instead:</p><ol> <li>We fetch a list of just the ids and create placeholder entries in the EmailMetadata object store.</li> <li>We page in the metadata and basic headers (like to/from/subject) for all messages in batches. This gives us everything we need to show the listing for any folder or label.</li> <li>We page in the body for pinned and recent messages, or everything if the user has selected this option in settings, again in batches.</li> </ol><p>This split is useful, because for most queries we can get away with just loading the metadata into memory, not the content. This is a big saving in time and memory when deserialising the objects from the underlying datastore.</p><h2 id="efficient-mailbox-querying" tabindex="-1">Efficient mailbox querying</h2><p>A linear pass through all the metadata is surprisingly tractable, even for large mailboxes, however it’s slower than we want for common queries (like opening your inbox). This is where we introduce a couple of extra custom indexes — separate object stores we are careful to update in lock step with any changes to our data.</p><p>The first of these is <strong>EmailMailboxes</strong>. This stores an entry for each addition or removal of a message from a folder/label, allowing us to both very efficiently compute the list of messages/conversations in a particular mailbox, and also calculate a delta update to the query when making changes.</p><p>The key for this object store is:</p><pre class="language-javascript"><code class="language-javascript"><span class="punctuation token">[</span><span class="constant token">MAILBOX_ID</span><span class="punctuation token">,</span> <span class="constant token">REMOVED_MODSEQ</span><span class="punctuation token">,</span> <span class="constant token">ADDED_MODSEQ</span><span class="punctuation token">]</span><span class="punctuation token">;</span></code></pre><p>The values look like:</p><pre class="language-javascript"><code class="language-javascript"><span class="punctuation token">[</span><span class="constant token">EMAIL_ID</span><span class="punctuation token">,</span> <span class="constant token">THREAD_ID</span><span class="punctuation token">,</span> <span class="constant token">DATE</span><span class="punctuation token">,</span> <span class="constant token">IS_UNREAD</span><span class="punctuation token">]</span><span class="punctuation token">;</span></code></pre><p>Whenever a message is added to a mailbox, a new entry is created. <code>ADDED_MODSEQ</code> is the current “updated” moseq of the message, and <code>REMOVED_MODSEQ</code> is 0.</p><p>If the message is removed from the mailbox, the old entry is deleted, and a new one added with the same <code>ADDED_MODSEQ</code>, but <code>REMOVED_MODSEQ</code> set to the new “updated” modseq of the message.</p><p>From this, we can quickly get the list of current messages in a particular mailbox by doing a range query for entries with keys that start: <code>[MAILBOX_ID, 0]</code>. The values include the date and thread id, allowing us to do the most common sort, and remove duplicates for the same thread id, without having to even fetch the metadata objects for the emails.</p><h2 id="delta-query-updates" tabindex="-1">Delta query updates</h2><p>JMAP has a way for a client to <a href="https://www.rfc-editor.org/rfc/rfc8620.html#section-5.6" target="_blank" rel="noopener">ask for what’s changed in a query</a>. This allows it to more efficiently update its local store and uses less bandwidth. With the EmailMailboxes index, we can also implement this. First we fetch the entries for the current messages as before, but then we also fetch the entries for messages that have been removed since our last state (this is a range query between <code>[MAILBOX_ID, sinceModSeq + 1]</code> and <code>[MAILBOX_ID, max_int]</code>). We sort these entries together according to the sort order the user has requested, normally date descending:</p><pre class="language-javascript"><code class="language-javascript">mailboxRecords<span class="punctuation token">.</span><span class="function token">sort</span><span class="punctuation token">(</span>
    <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span>
        b<span class="punctuation token">[</span><span class="constant token">DATE</span><span class="punctuation token">]</span> <span class="operator token">-</span> a<span class="punctuation token">[</span><span class="constant token">DATE</span><span class="punctuation token">]</span> <span class="operator token">||</span>
        <span class="punctuation token">(</span>a<span class="punctuation token">[</span><span class="constant token">EMAIL_ID</span><span class="punctuation token">]</span> <span class="operator token">&lt;</span> b<span class="punctuation token">[</span><span class="constant token">EMAIL_ID</span><span class="punctuation token">]</span> <span class="operator token">?</span> <span class="number token">1</span> <span class="operator token">:</span> a<span class="punctuation token">[</span><span class="constant token">EMAIL_ID</span><span class="punctuation token">]</span> <span class="operator token">></span> b<span class="punctuation token">[</span><span class="constant token">EMAIL_ID</span><span class="punctuation token">]</span> <span class="operator token">?</span> <span class="operator token">-</span><span class="number token">1</span> <span class="operator token">:</span> <span class="number token">0</span><span class="punctuation token">)</span> <span class="operator token">||</span>
        a<span class="punctuation token">[</span><span class="constant token">ADDED_MODSEQ</span><span class="punctuation token">]</span> <span class="operator token">-</span> b<span class="punctuation token">[</span><span class="constant token">ADDED_MODSEQ</span><span class="punctuation token">]</span><span class="punctuation token">,</span>
<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre><p>Then we can iterate through to calculate what has been added or removed from the query, like so. (“Exemplar” is our term for the email that’s representing a thread when <a href="https://www.rfc-editor.org/rfc/rfc8621.html#section-4.4.3" target="_blank" rel="noopener">the “collapseThreads” argument</a> is true.)</p><pre class="language-javascript"><code class="language-javascript"><span class="keyword token">let</span> index <span class="operator token">=</span> <span class="operator token">-</span><span class="number token">1</span><span class="punctuation token">;</span>
<span class="keyword token">const</span> seenExemplar <span class="operator token">=</span> collapseThreads <span class="operator token">?</span> <span class="keyword token">new</span> <span class="class-name token">Set</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">:</span> <span class="keyword token">null</span><span class="punctuation token">;</span>
<span class="keyword token">const</span> seenOldExemplar <span class="operator token">=</span> collapseThreads <span class="operator token">?</span> <span class="keyword token">new</span> <span class="class-name token">Set</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">:</span> <span class="keyword token">null</span><span class="punctuation token">;</span>
<span class="keyword token">let</span> uptoHasBeenFound <span class="operator token">=</span> <span class="boolean token">false</span><span class="punctuation token">;</span>
<span class="keyword token">let</span> total <span class="operator token">=</span> <span class="number token">0</span><span class="punctuation token">;</span>
<span class="keyword token">const</span> added <span class="operator token">=</span> <span class="punctuation token">[</span><span class="punctuation token">]</span><span class="punctuation token">;</span>
<span class="keyword token">const</span> removed <span class="operator token">=</span> <span class="punctuation token">[</span><span class="punctuation token">]</span><span class="punctuation token">;</span>
<span class="keyword token">for</span> <span class="punctuation token">(</span><span class="keyword token">const</span> record <span class="keyword token">of</span> mailboxRecords<span class="punctuation token">)</span> <span class="punctuation token">{</span>
    <span class="keyword token">const</span> isDeleted <span class="operator token">=</span> <span class="operator token">!</span><span class="operator token">!</span>record<span class="punctuation token">[</span><span class="constant token">REMOVED_MODSEQ</span><span class="punctuation token">]</span><span class="punctuation token">;</span>
    <span class="comment token">// Created and deleted after our previous state? Ignore.</span>
    <span class="keyword token">const</span> isNew <span class="operator token">=</span> record<span class="punctuation token">[</span><span class="constant token">ADDED_MODSEQ</span><span class="punctuation token">]</span> <span class="operator token">></span> sinceModSeq<span class="punctuation token">;</span>
    <span class="keyword token">if</span> <span class="punctuation token">(</span>isNew <span class="operator token">&amp;&amp;</span> isDeleted<span class="punctuation token">)</span> <span class="punctuation token">{</span>
        <span class="keyword token">continue</span><span class="punctuation token">;</span>
    <span class="punctuation token">}</span>

    <span class="comment token">// Is this message the current exemplar?</span>
    <span class="keyword token">let</span> isNewExemplar <span class="operator token">=</span> <span class="boolean token">false</span><span class="punctuation token">;</span>
    <span class="keyword token">let</span> isOldExemplar <span class="operator token">=</span> <span class="boolean token">false</span><span class="punctuation token">;</span>
    <span class="keyword token">const</span> emailId <span class="operator token">=</span> record<span class="punctuation token">[</span><span class="constant token">EMAIL_ID</span><span class="punctuation token">]</span><span class="punctuation token">;</span>
    <span class="keyword token">const</span> threadId <span class="operator token">=</span> record<span class="punctuation token">[</span><span class="constant token">THREAD_ID</span><span class="punctuation token">]</span><span class="punctuation token">;</span>
    <span class="keyword token">if</span> <span class="punctuation token">(</span><span class="operator token">!</span>isDeleted <span class="operator token">&amp;&amp;</span> <span class="punctuation token">(</span><span class="operator token">!</span>collapseThreads <span class="operator token">||</span> <span class="operator token">!</span>seenExemplar<span class="punctuation token">.</span><span class="function token">has</span><span class="punctuation token">(</span>threadId<span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
        isNewExemplar <span class="operator token">=</span> <span class="boolean token">true</span><span class="punctuation token">;</span>
        index <span class="operator token">+=</span> <span class="number token">1</span><span class="punctuation token">;</span>
        total <span class="operator token">+=</span> <span class="number token">1</span><span class="punctuation token">;</span>
        <span class="keyword token">if</span> <span class="punctuation token">(</span>collapseThreads<span class="punctuation token">)</span> <span class="punctuation token">{</span>
            seenExemplar<span class="punctuation token">.</span><span class="function token">add</span><span class="punctuation token">(</span>threadId<span class="punctuation token">)</span><span class="punctuation token">;</span>
        <span class="punctuation token">}</span>
    <span class="punctuation token">}</span>
    <span class="comment token">// Was this message an old exemplar?</span>
    <span class="comment token">// 1. Must not have been added to mailbox after the client's state</span>
    <span class="comment token">// 2. Must have been removed from mailbox before the client's state</span>
    <span class="comment token">// 3. Must not have already found the old exemplar.</span>
    <span class="keyword token">if</span> <span class="punctuation token">(</span><span class="operator token">!</span>isNew <span class="operator token">&amp;&amp;</span> <span class="punctuation token">(</span><span class="operator token">!</span>collapseThreads <span class="operator token">||</span> <span class="operator token">!</span>seenOldExemplar<span class="punctuation token">.</span><span class="function token">has</span><span class="punctuation token">(</span>threadId<span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
        isOldExemplar <span class="operator token">=</span> <span class="boolean token">true</span><span class="punctuation token">;</span>
        <span class="keyword token">if</span> <span class="punctuation token">(</span>collapseThreads<span class="punctuation token">)</span> <span class="punctuation token">{</span>
            seenOldExemplar<span class="punctuation token">.</span><span class="function token">add</span><span class="punctuation token">(</span>threadId<span class="punctuation token">)</span><span class="punctuation token">;</span>
        <span class="punctuation token">}</span>
    <span class="punctuation token">}</span>

    <span class="keyword token">if</span> <span class="punctuation token">(</span>isOldExemplar <span class="operator token">&amp;&amp;</span> <span class="operator token">!</span>isNewExemplar<span class="punctuation token">)</span> <span class="punctuation token">{</span>
        removed<span class="punctuation token">.</span><span class="function token">push</span><span class="punctuation token">(</span>emailId<span class="punctuation token">)</span><span class="punctuation token">;</span>
    <span class="punctuation token">}</span> <span class="keyword token">else</span> <span class="keyword token">if</span> <span class="punctuation token">(</span><span class="operator token">!</span>isOldExemplar <span class="operator token">&amp;&amp;</span> isNewExemplar<span class="punctuation token">)</span> <span class="punctuation token">{</span>
        <span class="comment token">// If the message has been moved out and back in again</span>
        <span class="comment token">// we'll have separate mailbox records for added/removed</span>
        <span class="comment token">// so not detect it's both the old and new exemplar;</span>
        <span class="comment token">// check for that here.</span>
        <span class="keyword token">const</span> removedIndex <span class="operator token">=</span> isMutableSort <span class="operator token">?</span> <span class="operator token">-</span><span class="number token">1</span> <span class="operator token">:</span> removed<span class="punctuation token">.</span><span class="function token">indexOf</span><span class="punctuation token">(</span>emailId<span class="punctuation token">)</span><span class="punctuation token">;</span>
        <span class="keyword token">if</span> <span class="punctuation token">(</span>removedIndex <span class="operator token">></span> <span class="operator token">-</span><span class="number token">1</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
            removed<span class="punctuation token">.</span><span class="function token">splice</span><span class="punctuation token">(</span>removedIndex<span class="punctuation token">,</span> <span class="number token">1</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
        <span class="punctuation token">}</span> <span class="keyword token">else</span> <span class="punctuation token">{</span>
            added<span class="punctuation token">.</span><span class="function token">push</span><span class="punctuation token">(</span><span class="punctuation token">{</span>
                index<span class="punctuation token">,</span>
                <span class="literal-property property token">id</span><span class="operator token">:</span> emailId<span class="punctuation token">,</span>
            <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
        <span class="punctuation token">}</span>
    <span class="punctuation token">}</span>

    <span class="comment token">// Special case for mutable sorts (based on isFlagged/isUnread)</span>
    <span class="keyword token">if</span> <span class="punctuation token">(</span>isMutableSort <span class="operator token">&amp;&amp;</span> isOldExemplar <span class="operator token">&amp;&amp;</span> isNewExemplar<span class="punctuation token">)</span> <span class="punctuation token">{</span>
        <span class="comment token">// Has the isUnread/isFlagged status of the message/thread</span>
        <span class="comment token">// (as appropriate) possibly changed since the client's state?</span>
        <span class="comment token">// If so, we need to remove the exemplar from the client view</span>
        <span class="comment token">// and add it back in at the correct position.</span>
        <span class="keyword token">const</span> mayHaveMoved <span class="operator token">=</span> collapseThreads
            <span class="operator token">?</span> threadChanged<span class="punctuation token">.</span><span class="function token">has</span><span class="punctuation token">(</span>threadId<span class="punctuation token">)</span>
            <span class="operator token">:</span> emailChanged<span class="punctuation token">.</span><span class="function token">has</span><span class="punctuation token">(</span>emailId<span class="punctuation token">)</span><span class="punctuation token">;</span>
        <span class="keyword token">if</span> <span class="punctuation token">(</span>mayHaveMoved<span class="punctuation token">)</span> <span class="punctuation token">{</span>
            removed<span class="punctuation token">.</span><span class="function token">push</span><span class="punctuation token">(</span>emailId<span class="punctuation token">)</span><span class="punctuation token">;</span>
            added<span class="punctuation token">.</span><span class="function token">push</span><span class="punctuation token">(</span><span class="punctuation token">{</span>
                index<span class="punctuation token">,</span>
                <span class="literal-property property token">id</span><span class="operator token">:</span> emailId<span class="punctuation token">,</span>
            <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
        <span class="punctuation token">}</span>
    <span class="punctuation token">}</span>
    <span class="comment token">// If this is the last message the client cares about, we can stop</span>
    <span class="comment token">// here and just return what we've calculated so far. We already</span>
    <span class="comment token">// know the total count for this message list as we keep it pre</span>
    <span class="comment token">// calculated and cached in the Mailbox object.</span>
    <span class="comment token">// However, if the sort is mutable we can't break early, as</span>
    <span class="comment token">// messages may have moved from the region we care about to lower</span>
    <span class="comment token">// down the list.</span>
    <span class="keyword token">if</span> <span class="punctuation token">(</span><span class="operator token">!</span>isMutableSort <span class="operator token">&amp;&amp;</span> <span class="operator token">!</span>isNew <span class="operator token">&amp;&amp;</span> emailId <span class="operator token">===</span> upToId<span class="punctuation token">)</span> <span class="punctuation token">{</span>
        uptoHasBeenFound <span class="operator token">=</span> <span class="boolean token">true</span><span class="punctuation token">;</span>
        <span class="keyword token">break</span><span class="punctuation token">;</span>
    <span class="punctuation token">}</span>
<span class="punctuation token">}</span></code></pre><h2 id="mail-search" tabindex="-1">Mail search</h2><p>Fastmail supports an <a href="https://www.fastmail.help/hc/en-us/articles/360060591213-Searching-your-mail" target="_blank" rel="noopener">extremely powerful set of search operators</a>, allowing for <a href="https://www.fastmail.com/features/search/" target="_blank" rel="noopener">fast, precise searching</a>. We support almost all of it offline, with a few caveats discussed below.</p><p>To make full-text search work and be performant, we need to build another index. If you have hundreds of thousands of messages, it would be unusably slow to scan through all of them looking for a word, phrase or email address.</p><p>Our index is stored in another <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a> object store called <strong>EmailSearch</strong>. The key for each entry is <code>[token, emailId]</code>. The token is usually a word or other sequence of letters and numbers extracted from the email. We also have special token variations to represent a list-id or email addresses found in the headers. We create an entry in EmailSearch for each such token we find in the email. The value encodes where the token was found (e.g. in the <code>To</code> header, or the message body), and the index(es) of the token so we can do <a href="https://en.wikipedia.org/wiki/Phrase_search" target="_blank" rel="noopener">phrase searches</a>.</p><p>We decided to index the content on the device, rather than download the indexes from the server. This ensured our search index would be completely in sync with the cached messages you have on your device, and we could index and make searchable messages and memos you wrote while you were offline.</p><p>However, this does mean the offline search works a little differently to our server-based search, so may return slightly different results (although we think both will do a great job in most cases). In particular:</p><ul> <li>Our offline search doesn’t index any text inside attachments. When online you can search for content in attached PDFs, spreadsheets, and other documents.</li> <li>Our offline search doesn’t do <a href="https://en.wikipedia.org/wiki/Stemming" target="_blank" rel="noopener">stemming</a>. Stemming tries to reduce a word to its common root, so if you search in English for <code>bus</code> you would also match emails containing <code>buses</code>, but not <code>business</code>. Stemming requires language analysis of the email content and custom stemming algorithms for each language, and we decided the extra complexity and code download size was not currently worth it for our offline search. Instead, our offline search does prefix matching by default, so <code>bus</code> will still match <code>buses</code> but also <code>business</code>. Of course, if you wrap the term in quotes (like <code>&quot;bus&quot;</code>) it will only look for exact matches, just like with server-based search.</li> </ul><p>And of course, the search index will only contain messages you have downloaded for offline, which might not be everything in your account. We therefore try to do a search on the server first and only fallback to the local search if you are offline.</p><h2 id="search-tokenisation" tabindex="-1">Search tokenisation</h2><p>To create our index we have to be able to extract the tokens from a sequence of text. We have users around the world, so we knew we had to handle multilingual text and scripts. In the end, we settled on a simple but effective tokenisation algorithm:</p><ol> <li>We normalise the string into Unicode <a href="https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms" target="_blank" rel="noopener">NFKD normal form</a>. This will decompose diacritics to make it easy to strip them, and replace various variations of letters and numbers (such as typographic ligatures, or subscript numbers) with the baseline equivalent.</li> <li>We divide the string into segments according to the <a href="https://www.unicode.org/reports/tr29/#Word_Boundaries" target="_blank" rel="noopener">Unicode text segmentation word boundary algorithm</a>.</li> <li>For each segment, we apply the full <a href="https://www.unicode.org/Public/16.0.0/ucd/CaseFolding.txt" target="_blank" rel="noopener">Unicode case folding substitutions</a> (for example, this will replace uppercase letters with lowercase for Latin text), then we strip every code point that’s not categorised by Unicode as a number, letter, joining punctuation, or emoji.</li> </ol><p>If we have anything left, that’s our token. So to give an example, supposing we had the text:</p><pre><code>The café is über cheap — only $3.60 a ☕️!!
</code></pre><p>We would end up with the following tokens:</p><pre><code>the
cafe
is
uber
cheap
only
360
a
☕️
</code></pre><h2 id="wrapping-it-up" tabindex="-1">Wrapping it up</h2><p>We now have the indexes we need for fast, precise search. There’s still a lot of work involved in putting it all together though! When you search for something complex like <code>in:inbox from:@example.com (is:pinned OR &quot;very important&quot;)</code>, we analyse the query to work out which indexes to use and efficiently combine them to compute the results. The speed will depend on how much mail you have—and how fast your device is!—but we believe it lives up to the Fastmail promise of great search everywhere.</p><p>There’s so much interesting tech behind our offline support, but for now I need to stop writing. If you’ve read all of this mini series on how we are making our app work offline: thank you, and I hope you found it interesting! Please give the beta a go, and let us know any feedback you might have. We’re excited to finish polishing this highly requested feature and we hope to ship it to everyone early in the new year.</p>