<p>If you, like me, enjoy tinkering with programming languages, configuring text editors and installing command-line tools, you will have faced the difficulty of managing versions, configuration files and environments, and replicating them on other machines. I have used a variety of<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> different &lsquo;dotfile managers&rsquo; for this task, <a href="https://www.rousette.org.uk/archives/setting-up-a-development-environment-with-nix-and-home-manager/">most recently</a> Nix and Nix Home Manager. This was an amazing and full-featured system. It was a steep learning curve to set up, but once I had done so, it was relatively easy to maintain, at least at first.</p>
<p>However&hellip; you knew there had to be a &lsquo;however&rsquo;, right? Nix is amazing, but I get the feeling that it is best used on Linux, and perhaps best used as NixOS, where you configure the whole operating system with it. While it works on macOS, the operating system itself puts constraints on what Nix is able to control, and as macOS is not the key platform for development effort, some packages are broken for macOS. I found myself having to manage more and more bits of my command-line ecosystem outside of Nix, which rather defeated the purpose of it. Managing and integrating all those components became difficult. I still think that if I had a Linux machine, I would choose to install NixOS on it and love the experience, but I needed to find another solution for my Macs. I settled on a partnership between <a href="https://www.chezmoi.io/">chezmoi</a> and <a href="https://mise.jdx.dev/">mise-en-place (mise for short)</a>.</p>
<h3 id="chezmoi">Chezmoi</h3>
<p>I think I had come across <a href="https://www.chezmoi.io/">chezmoi</a> before in my exploration of dotfile managers, but had decided against trying it for some reason (I don&rsquo;t remember why). It works a little bit differently from similar tools, which might have been what disconcerted me before. Instead of maintaining a git-based store of files and then symlinking them into place in the home directory, you leave the existing dotfiles (and other kinds of files, of which more later) in place, and tell chezmoi to add them to its pool of managed files. Chezmoi then makes a copy in the directory <code>~/.local/share/chezmoi</code> and keeps track of the relationship between the files. The only tricky part is that you have to remember to edit the files under this directory (not the originals), and then run the command <code>chezmoi add</code> after you have done so to update the originals. This chezmoi directory is of course a git repository, so to sync the changes on another machine, you do <code>chezmoi update</code> which pulls and applies the latest changes. It took me a little while to get used to this way of doing things, but now it feels natural.</p>
<p>Those are the basics, but chezmoi has a lot of power and flexibility. Synchronising dotfiles is the core of it, but you can also include scripts with template variables which you can set up to run only once (for example, to bootstrap a setup when you are setting up a new computer), or run only if the underlying file has changes. Templates can include logic for checking what machine or platform you are on, so that you can install different tools on Intel and Apple Silicon macOS machines, or a different suite of applications on a work or personal machine.</p>
<p>For example, I have this in my <code>.chezmoi.toml.tmpl</code> file, which sets a variable <code>arm</code> on the basis of the output of the <code>uname -p</code> command.</p>
<div class="highlight"><pre tabindex="0" style="color:#e0def4;background-color:#232136;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#908caa">{{</span>- <span style="color:#ea9a97">$arm</span> :<span style="color:#908caa">=</span> <span style="color:#ea9a97">false</span> <span style="color:#908caa">}}{{</span>/* are we running on intel or arm processor? */<span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">{{</span>- <span style="color:#3e8fb0">if</span> eq .chezmoi.os <span style="color:#f6c177">&#34;darwin&#34;</span> -<span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">{{</span>- <span style="color:#3e8fb0">if</span> contains <span style="color:#f6c177">&#34;arm&#34;</span> <span style="color:#908caa">(</span>output <span style="color:#f6c177">&#34;uname&#34;</span> <span style="color:#f6c177">&#34;-p&#34;</span> <span style="color:#908caa">|</span> trim<span style="color:#908caa">)</span> -<span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">{{</span>- <span style="color:#ea9a97">$arm</span> <span style="color:#908caa">=</span> <span style="color:#ea9a97">true</span> -<span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">{{</span>- end -<span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">{{</span>- end -<span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">[</span>data<span style="color:#908caa">]</span>
</span></span><span style="display:flex;"><span> <span style="color:#ea9a97">arm</span> <span style="color:#908caa">=</span> <span style="color:#908caa">{{</span> <span style="color:#ea9a97">$arm</span> <span style="color:#908caa">}}</span>
</span></span></code></pre></div><p>In my <code>dot_zprofile.tmpl</code> file, the following lines check the value of <code>arm</code> and write the correct command into the generated <code>.zprofile</code> file so that homebrew is set up correctly on both Intel and Apple Silicon Macs:</p>
<div class="highlight"><pre tabindex="0" style="color:#e0def4;background-color:#232136;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#908caa">{{</span>- <span style="color:#3e8fb0">if</span> .arm <span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#ea9a97">eval</span> <span style="color:#f6c177">&#34;</span><span style="color:#3e8fb0">$(</span>/opt/homebrew/bin/brew shellenv<span style="color:#3e8fb0">)</span><span style="color:#f6c177">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">{{</span> <span style="color:#3e8fb0">else</span> <span style="color:#908caa">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#ea9a97">eval</span> <span style="color:#f6c177">&#34;</span><span style="color:#3e8fb0">$(</span>/usr/local/bin/brew shellenv<span style="color:#3e8fb0">)</span><span style="color:#f6c177">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#908caa">{{</span>- end <span style="color:#908caa">}}</span>
</span></span></code></pre></div><p>The &lsquo;dot_&rsquo; prefix is one of several added to added files by chezmoi to indicate that the managed file has certain attributes (in this case, a hidden file), and the &lsquo;.tmpl&rsquo; suffix tells chezmoi to evaluate the template content before copying the file to its destination. In addition, you don&rsquo;t have to restrict yourself only to traditional dotfiles: you can add files from anywhere (e.g. <code>~/Library/Spelling</code> to pick up dictionaries), and chezmoi will ensure that they are synced correctly with the target files. You could use the same thing to sync a folder of binary scripts in your home directory so that they can be used on multiple machines, and changes tracked. You can <code>chezmoi add</code> a whole directory tree of stuff, or target specific files, so it allows you to be very selective about what you manage with chezmoi.</p>
<p>I have a relatively simple system, compared to what is possible using chezmoi. I run a script on the first run of chezmoi to install homebrew itself, then sync a bunch of dotfiles for the shell and various tools, plus neovim and Doom Emacs config files. I then use a script to run <code>brew bundle</code> to install a list of applications using homebrew (both command-line and GUI apps), as well as neovim and Emacs. Finally, another script runs <code>mise install</code>, which brings me to mise-en-place.</p>
<h3 id="mise-en-place">mise-en-place</h3>
<p>Homebrew is great for installing an enormous range of applications, but I know from previous experience that it isn&rsquo;t ideal for programming languages or any other application where you want to have different versions installed concurrently. For example, you might want to install the latest version of Ruby globally so that you can have some useful tools like <a href="https://github.com/ttscoff/howzit">howzit</a> installed (and not care much about what version that is), but then specify a particular version of Ruby and particular Gems for a project directory. Many programming languages have their own tool chains for enabling that, but if you dabble in a few languages<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>, you need to remember the intricacies of each one. This is where <a href="https://mise.jdx.dev/">mise</a> comes in.</p>
<p>mise can install specific versions of tools or languages for you, set up project-specific environments (effectively replacing things like <code>direnv</code>), and act as a task runner to run build scripts and the like for any language, enabling you to learn and use one coherent syntax across different programming languages.</p>
<p>This is similar to Nix shell, but it is much more lightweight, easier to install and understand than Nix. The Ruby situation that I outlined above is something that I wanted to achieve on Nix, but never managed to get working. I wanted to have a globally installed set of Gems for key tools, but then have projects with different versions of Ruby and different sets of Gems. I tried all sorts of things on Nix and asked about it on the Nix Discourse, but it just didn&rsquo;t seem to be something that was possible with the partially nix-controlled macOS setup. It was trivially easy with mise, and I have similar setups for other languages.</p>
<h3 id="is-this-my-one-true-dotfiles-system">Is this my one true dotfiles system?</h3>
<p>Who knows? I do really like it. It has power and flexibility, but it is also simple to understand, which is handy when you haven&rsquo;t edited your config for a while, and you forget how it all works. Neither chezmoi nor mise bury their fingers deep into the OS in the way that Nix does. Uninstalling Nix is &mdash; as I discovered &mdash; a multi-step process involving lots of commands that need sudo privileges, and messing with fairly fundamental parts of the filesystem. In contrast, if you wanted to stop using chezmoi, you would just delete your dotfiles repo. In fact, you wouldn&rsquo;t even have to do that: you could just ignore the dotfiles repo and go back to editing the original files. mise puts things in the <code>~/.local</code> directory, and adds the relevant paths to your shell, so that is also easy to dismantle if you decide not to use it any more. I&rsquo;m really enjoying these tools, and don&rsquo;t have any plans to stop using it, but it is good to know that I could, without incurring a lot of work.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>&lsquo;a variety of&rsquo; is a bit of an understatement. I&rsquo;ve probably used as many dotfile management systems as I have text editors, which is to say &mdash; a lot.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>bsag raises her dabbling hand sheepishly&hellip;&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>