<p>One of the core ideas in functional programming is to filter a set
  of items by some criterion.  It may be somewhat suprising to learn
  that lisp does not have a built-in function named
  &ldquo;filter&rdquo; &ldquo;select&rdquo;, or &ldquo;keep&rdquo;
  that performs this operation.  Instead, Common Lisp provides the
  &ldquo;remove&rdquo;, &ldquo;remove-if&rdquo;, and
  &ldquo;remove-if-not&rdquo; functions, which perform the
  complementary operation of removing items that satisfy or do not
  satisfy a given predicate.</p>

<p>The <code>remove</code> function, like similar sequence functions,
  takes an optional keyword <code>:test-not</code> argument that can
  be used to specify a test that must <em>fail</em> for an item to be
  considered for removal.  Thus if you invert your logic for
  inclusion, you can use the <code>remove</code> function as a
  &ldquo;filter&rdquo; by specifying the predicate
  with <code>:test-not</code>.</p>

<pre>
&gt; (defvar *nums* (map 'list (&#955; (n) (format nil "~r" n)) (iota 10)))
*NUMS*

;; Keep *nums* with four letters
&gt; (remove 4 *nums* :key #'length :test-not #'=)
("zero" "four" "five" "nine")

;; Keep *nums* starting with the letter "t"
&gt; (remove #\t *nums* :key (partial-apply-right #'elt 0) :test-not #'eql)
("two" "three")</pre>