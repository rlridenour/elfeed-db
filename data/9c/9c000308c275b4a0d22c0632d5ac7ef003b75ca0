<p>
<i>Published: [2025-07-21 Mon]. Comments <a href="https://mathstodon.xyz/@oantolin/114890671803436392">on Mastodon.</a></i>
</p>

<p>
This blog entry is part of the Emacs Carnival for July 2025, <a href="https://gregnewman.io/blog/emacs-carnival-2025-07-writing-experience/">hosted by
Greg Newman</a>, with the topic of "Writing Experience".
</p>

<p>
I mostly use Emacs to write prose, not because I don't also use Emacs
to write computer programs, but simply because I write a whole lot
more prose than code! I write papers, lecture notes, homework
assignments, notes on different topics (some public, some private), my
website including this blog, emails, comments on social networks, and
I'm even supposed to be keeping a journal (though I notice the most
recent entry is from April...).
</p>

<p>
But more than that, I tend to write any bit of text longer than a
sentence or two in Emacs. The main the reason for that is that I edit
a lot as I write and Emacs makes this easier than any other text
editor I'm aware of. Before Emacs I used Vim and, while it is a very
powerful text editor, it has distinct modes for inserting text (called
insert mode, naturally) and for editing it (called normal mode, to
mock writers for being imperfect and <i>normally</i> requiring editing). The
separation of modes nudges you in the direction of getting a first
rough draft down and then editing it. That suits some people
perfectly, and it is certainly something I could do and was used to,
but I think that I am naturally more of an edit-as-you-go person. My
evidence for this is that it is what I do in Emacs, which favors
neither the draft-first nor the edit-as-you-go style ―it's pretty much
the same number of keystrokes either way, unlike in Vim where you give
the poor <code>ESC</code> key a break if you batch your edits.
</p>

<p>
By the way, the fact that I spend so much time editing prose is also
why I need a text editor like Emacs or Vim and couldn't switch to a
code editor like VS Code. When an editor calls itself a "code editor",
my impression is that it does so to signal poor support for prose (or
maybe it wants to signal good support for code ―I needn't be so
negative). I don't think VS Code has commands to move by or select
sentences, for example; instead it's line-oriented, which makes sense
for programming ―or, I guess, for people who write prose one sentence
per line because they use <code>git</code> and want cleaner diffs but don't know
about <code>git diff --word-diff</code>.
</p>

<p>
Emacs is very powerful out of the box for editing prose, but even so I
have a few personal tweaks to make it fit me like a glove. In the rest
of this blog post I will describe a few commands I use when editing
prose, some built-in, some I wrote myself to scratch a small but
persistent itch.
</p>
<div id="outline-container-org12843ee" class="outline-3">
<h3 id="org12843ee">Changing case and transposing</h3>
<div class="outline-text-3" id="text-org12843ee">
<p>
One of my most common typos is being slow to release the shift key and
accidentally capitalizing the first two letters of a word, as in &ldquo;See
you next THursday!&rdquo;. When I make that mistake I often notice it before
I finish typing that word and in stock Emacs I could fix it right away
with <code>M-- M-c</code> or <code>M-b M-c</code>. (By default <code>M-c</code> is bound to <code>capitalize-word</code>,
but I recommend rebinding it to <code>capitalize-dwim</code> which acts as
<code>capitalize-word</code> unless there is an active region in which case it acts
as <code>capitalize-region</code>.) At some point I noticed that my most common use
of <code>M-c</code> was to capitalize the previous word, and decided to simplify
that case. Initially I wrote a command that is just like
<code>capitalize-dwim</code> except that if point is at the end of the word it acts
on the previous word rather than on the next one. That did simplify my
most common usage of <code>M-c</code> but it introduced a new problem: when I
wasn&rsquo;t fixing a typo in a word I just entered, I often forgot the new
behavior and expected <code>M-c</code> to capitalize the next word, even if point
was at the end of a word; in those cases my new command annoyed me
quite a bit.
</p>

<p>
This illustrates what I feel is an underappreciated point: the user
experience (UX) of even simple editing commands is often tricky to get
exactly right. Of course, people are aware that UX design is hard, but
I think people tend to assume it&rsquo;s only hard for larger programs, not
for something tiny like <code>capitalize-word</code>. But for a command you are
likely to use many times a day getting the UX exactly right really
pays off. I eventually fixed my command drawing inspiration from a
different set of commands that are also extremely useful while writing
prose: the tranpose family of commands. I&rsquo;ll explain the feature of
these commands that I adopted for the case change commands, after I
explain what they do. The transpose commands are fantastic and I don&rsquo;t
understand why not every editor has them (even Vim doesn&rsquo;t!). Another
extremely common typo I make is swapping two charcaters. To fix that,
you put point on the second of the characters (if your cursor is a
bar, put the bar between the swapped characters) and use
<code>transpose-chars</code>, bound by default to <code>C-t</code>. There are also
<code>tranpose-words</code> (<code>M-t</code>), <code>transpose-sexps</code> (<code>C-M-t</code>), <code>transpose-lines</code>
(<code>C-x C-t</code>), <code>transpose-sentences</code> and <code>transpose-paragraphs</code>.
The sexp and line commands are more useful for editing code than
prose, but are still useful for prose, particular since parenthetical
expressions or quoted text count as sexps. It&rsquo;s a little sad that the
sentence and paragraph commands are not bound by default; I bind them
to <code>M-T</code> and <code>C-x M-t</code> respectively. While <code>transpose-chars</code> is most useful
for fixing typos, the other transpose commands are more useful while
editing. I find I rearrange text quite a bit: Even for a 5−10 line
email I&rsquo;m fairly likely to have swapped two sentences or even two
paragraphs while writing it!
</p>

<p>
The transpose family of commands have a few very nifty features:
</p>

<ol class="org-ol">
<li>They leave point after the second of the two swapped things, which
means that by simply repeating the command you can continue to move
that thing to the right. With a negative prefix argument you can
drag things to the left instead.</li>
<li>With a prefix argument of 0 they can swap non-adjacent things!
Select a region starting somewhere in the first thing and ending
somewhere in the second and call a transpose command with a prefix
argument of 0 to swap them,</li>
<li>If you use <code>transpose-chars</code> at the end of a line you might think it
would swap the last character of the line with the newline, since,
that newline is after all the next character, but instead it swaps
the last two characters on the line. This means that if you
accidentally swap two characters while entering text (at the end of
some line) and notice the typo immediately, you can fix it with
just <code>C-t</code> without moving the point! This is special behavior of
<code>transpose-chars</code>, sadly not shared by <code>transpose-words</code>, but at least
that one has a similar but lesser magic: if you use <code>transpose-words</code>
at the end of the <i>buffer</i> (yes, I said &ldquo;buffer&rdquo;, not &ldquo;line&rdquo;), it
will&#x2026; not swap the last two words, but produce an error message.
and also move point to before the last word. But that very last bit
means that a second <code>M-t</code> will swap the last two words! OK, kind of
lame compared to <code>C-t</code> but at least it&rsquo;s something.</li>
</ol>

<p>
That last behavior of <code>transpose-chars</code> is what I adopted for my
versions of the case-change dwim commands: if you call one of my
case-change commands at the end of a line, it changes the case of the
last word of the line (not the first word on the next non-blank line,
which is what <code>capitalize-word</code> or <code>capitalize-dwim</code> would do). And that
feels perfect to me: my common typo is fixed with a simply <code>M-c</code> but
while editing text in the middle of the text I don&rsquo;t get any
unpleasant surprises anymore. Try teaching that to a web browser text
input box!
</p>
</div>
</div>
<div id="outline-container-orgd9f63c5" class="outline-3">
<h3 id="orgd9f63c5">Marking whole words</h3>
<div class="outline-text-3" id="text-orgd9f63c5">
<p>
Another tiny annoyance I had with the built-in commands is that the
marking commands only mark from point to the end of the thing they are
for. For example <code>mark-word</code> does not mark the word at point, it marks
the portion of that word starting at point (so if point is on the
first character of the word, it does mark the entire word). The
analogous command for sentences has more honest name:
<code>mark-end-of-sentence</code> ―though <code>mark-to-end-of-sentence</code> would be even
clearer. Now, for sentences, that behavior seems fine and useful to
me, since I often do want to grab just the tail of a sentence, but I
basically never want to mark just a piece of a word. So I wrote a
command that marks the entire word point is on, bound it to <code>M-@</code> and
just use it in place of <code>mark-word</code>. Obviously I called my command
<code>mark-my-word</code>.
</p>
</div>
</div>
<div id="outline-container-orga01ffed" class="outline-3">
<h3 id="orga01ffed">Useful commands with no default key binding</h3>
<div class="outline-text-3" id="text-orga01ffed">
<p>
That <code>mark-end-of-sentence</code> command I mentioned doesn&rsquo;t have a default
key binding, but that&rsquo;s OK since you can achieve the same effect by
using shift selection with the <code>forward-sentence</code> command (I mean typing
<code>M-E</code>). But there are some very useful commands, particularly in the
<code>misc.el</code> library, with no key binding:
</p>

<ul class="org-ul">
<li><code>zap-up-to-char</code>, which I find I want more often than <code>zap-to-char</code>, so
I bind this one <code>M-z</code> and <code>zap-to-char</code> to <code>M-Z</code>.</li>
<li><code>forward-to-word</code> and <code>backward-to-word</code> which move to the opposite end
of the word than <code>forward-word</code> and <code>backward-word</code> do; I bind these to
<code>M-F</code> and <code>M-B</code>.</li>
<li><code>copy-from-above-command</code> and <code>duplicate-dwim</code>, two commands that can
duplicate a line. The first duplicates the line above point and the
second duplicates the line at point. The first command actually
duplicates the tail of the line above starting from the current
column, and if given a numeric argument will only duplicate that
many characters (I hardly ever use this last bit of functionality
since I find counting characters tedious and error prone). The
second command will duplicate the region if it is active ―which is
what <code>dwim</code> means in several Emacs commands.</li>
<li><code>delete-forward-char</code> is a surprising one: by default <code>C-d</code> is bound to
<code>delete-char</code> but the documentation for that command says: &ldquo;The
command ‘delete-forward-char’ is preferable for interactive use,
e.g. because it respects values of ‘delete-active-region’ and
‘overwrite-mode’.&rdquo; I agreed and rebound <code>C-d</code>.</li>
<li><code>kill-paragraph</code>, I bind this to <code>M-K</code>.</li>
<li><code>up-list</code> moves you out of a delimited expression, which honestly is
more useful when writing code, but I mention it here since I do use
it often for getting out of parenthetical remarks or quotation
marks. I bind to <code>C-M-o</code> which goes well with the other sexp
navigation commands with <code>C-M-</code> modifiers; the mnemonic for <code>o</code> is that
it gets me Out of a sexp.</li>
<li><code>transpose-sentences</code> and <code>transpose-paragraphs</code> I already mentioned
above. I bind them to <code>M-T</code> and <code>C-x M-t</code>. In org-mode buffers you don&rsquo;t
really need <code>transpose-paragraphs</code> since <code>M-&lt;down&gt;</code> and <code>M-&lt;up&gt;</code> cover its
functionality.</li>
</ul>
</div>
</div>
<div id="outline-container-org72dc7b3" class="outline-3">
<h3 id="org72dc7b3">Dabbrev</h3>
<div class="outline-text-3" id="text-org72dc7b3">
<p>
The kind of &ldquo;autocompletion&rdquo; I almost always want while writing prose
is simply to complete text I&rsquo;ve already typed somewhere. For that
<code>dabbrev-expand</code> (bound to <code>M-/</code>) is super useful: it&rsquo;ll search for
completions of the beginning of a word you&rsquo;ve typed in several places
in order: the current buffer before point, the current buffer after
point, other buffers in the same major mode as the current buffer, and
finally all other buffers. (That&rsquo;s just the default configuration, as
usual in Emacs, dabbrev is quite configurable.) I often find myself
opening some file just so I can complete words from it in another
buffer. One lesser known feature of <code>dabbrev-expand</code> is that you can
also use it to complete phrases, not just words: if right after
completing a word using <code>dabbrev-expand</code> you insert a space and then run
<code>dabbrev-expand</code> again, it will insert the word that followed the first
word wherever it found it. So <code>M-/ SPC M-/ SPC M-/ ...</code> will complete a
phrase from your buffer. To make this even more convenient I wrote
this little command that I bind to <code>M-;</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #531ab6;">defun</span> <span style="color: #721045;">dabbrev-next</span> (arg)
  <span style="color: #2a5045; font-style: italic;">"Insert the next ARG words from where previous expansion was found."</span>
  (<span style="color: #531ab6;">interactive</span> <span style="color: #3548cf;">"p"</span>)
  (<span style="color: #531ab6;">dotimes</span> (_ arg)
    (insert <span style="color: #3548cf;">" "</span>)
    (dabbrev-expand 1))
  (<span style="color: #531ab6;">setq</span> this-command 'dabbrev-expand))
</pre>
</div>

<p>
That way I can complete a phrase with <code>M-/ M-; M-; ...</code>. You can really
fly that way. For example, the previous paragraph says &ldquo;current
buffer&rdquo; three times; I only wrote the first one in full, the others
were <code>cur M-/ M-;</code>.
</p>
</div>
</div>
<div id="outline-container-org8ed1616" class="outline-3">
<h3 id="org8ed1616">Ediff</h3>
<div class="outline-text-3" id="text-org8ed1616">
<p>
This one isn&rsquo;t so impressive to computer programmers, used as they are
to source control, but let me tell you that the ease with which you
can merge versions of files using <code>ediff</code> will absolutely blow
mathematicians minds! I&rsquo;ve impressed several coauthors by merging our
changes to a draft paper in less than a minute, flying over changes
faster than they can orient themselves. It feels like a super power to
people who haven&rsquo;t seen something like it before.
</p>
</div>
</div>
<div id="outline-container-orgbf9650c" class="outline-3">
<h3 id="orgbf9650c">Keyboard macros</h3>
<div class="outline-text-3" id="text-orgbf9650c">
<p>
I don&rsquo;t think it would surprise anyone to say that keyboard macros are
very useful for automating edits while coding, but perhaps it is a
little surprising they can also be very useful while editing prose.
One thing that comes up fairly often for me is that I want to write a
bulleted list and I have the raw data I need to talk about in some
other format. For example I might have a spreadsheet (if it&rsquo;s shared)
or an org table (if I&rsquo;m the only one editing) with a list of names,
email addresses and affiliations of some people and I need to write a
small paragraph about each person. Here&rsquo;s an example with fake people:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Juana Sinisterra</td>
<td class="org-left">jsinis@uni.junco</td>
<td class="org-left">Universidad del Junco</td>
</tr>

<tr>
<td class="org-left">Molly Edwards</td>
<td class="org-left">medwards@henkin.edu</td>
<td class="org-left">Henkin College</td>
</tr>

<tr>
<td class="org-left">Mario Finetti</td>
<td class="org-left">mfino@vallebruna.it</td>
<td class="org-left">Universitá di Vallebruna</td>
</tr>
</tbody>
</table>

<p>
And I want to turn it into:
</p>

<ul class="org-ul">
<li>Juana Sinisterra &lt;jsinis@uni.junco&gt; from Universidad del Junco, XXX.</li>
<li>Molly Edwards &lt;medwards@henkin.edu&gt; from Henkin College, XXX.</li>
<li>Mario Finetti &lt;mfino@vallebruna.it&gt; from Universitá di Vallebruna,
XXX.</li>
</ul>

<p>
where the &ldquo;XXX&rdquo; are placeholders I&rsquo;ll fill in later. (I&rsquo;d actually use
<code>&lt;++&gt;</code> as the placeholders and fill them in using my <a href="https://github.com/oantolin/placeholder">placeholder
package</a>, but never mind that now.) For this I&rsquo;d record a keyboard
macro that transforms a single row of the table and just run it for
each line. For dealing with keyboard macros I prefer the &ldquo;modern&rdquo;
interface, consisting of <code>kmacro-start-macro-or-insert-counter</code> (bound
to <code>&lt;f3&gt;</code>) and <code>kmacro-end-or-call-macro</code> (bound to <code>&lt;f4&gt;)</code>, which can be
used in place of all four of these &ldquo;old&rdquo; key bindings: <code>C-x (</code>, <code>C-x C-k
C-i</code>, <code>C-x )</code> and <code>C-x e</code>. However I find the function keys a little too
far for comfort, so I rebind the commands to <code>M-r</code> (for &ldquo;record&rdquo;) and
<code>M-m</code> (for &ldquo;macro&rdquo;). (<code>M-m</code> is bound by default to <code>back-to-indentation</code>, a
command which I do use but rebound to the more mnemonic <code>M-i</code>; <code>M-r</code> also
has a default binding, but I never use that command). Since I switched
to the simpler &ldquo;modern&rdquo; macro commands I find that I use keyboard
macros a lot more, and rebinding them to the highly accesible <code>M-r</code> and
<code>M-m</code> keys gave my macro usage a further boost.
</p>

<p>
In the example I gave above, I wanted to run the keyboard macro to
every line of a table. You can do that by recording the macro, marking
the remaining lines and using <code>apply-macro-to-region-lines</code> bound to <code>C-x
C-k r</code>. That key binding is a little awkward and to be honest I don&rsquo;t
use it: Embark binds that command to <code>m</code> when you are acting on a
region, so I use <code>C-. m</code> (simpler key bindings are a nice perk of
Embark&rsquo;s contextuality). But there is further convenience to be
enjoyed: as in this example, I very often want to apply a macro to
every line of a &ldquo;paragraph&rdquo; (a table with a blank line after it
counts), or rather, to the remaining lines of a paragraph after
recording the macro for the first line. For that I wrote this simple
command I bind to <code>M-M</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #531ab6;">defun</span> <span style="color: #721045;">apply-macro-to-rest-of-paragraph</span> ()
  <span style="color: #2a5045; font-style: italic;">"Apply last keyboard macro to each line in the rest of the current paragraph."</span>
  (<span style="color: #531ab6;">interactive</span>)
  (<span style="color: #531ab6;">when</span> defining-kbd-macro (kmacro-end-macro nil))
  (apply-macro-to-region-lines
   (line-beginning-position 2)
   (<span style="color: #531ab6;">save-excursion</span> (end-of-paragraph-text) (point))))
</pre>
</div>

<p>
It feels like magic: <code>M-r</code>, do stuff to the first line, <code>M-M</code> and boom,
the same transformation gets applied to the rest of the lines!
</p>
</div>
</div>
