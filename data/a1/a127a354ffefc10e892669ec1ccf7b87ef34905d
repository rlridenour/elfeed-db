<p>God was this weird to figure out.</p>

<p>So <code>swift test</code> will produce a lot of stuff on standard output. Test failures, to nobody’s help, also just list the file names, not the (relative) paths:</p>

<pre><code>􀢄  Test amazingTest() recorded an issue at MyTests.swift:12:34: Expectation failed: ...
</code></pre>

<p>In theory, <code>MyTest.swift:12:34</code> is enough to instruct an editor where to look for the test failure.</p>

<p>Here’s a regular expression that matches this:</p>

<pre><code>"^.* Test .* recorded an issue at ([a-zA-Z0-9_\/ ]+\.swift):([0-9]+):([0-9]+): "
</code></pre>

<p><a href="https://regex101.com/r/SB7za7/1">Test it on regex101.com</a>.</p>

<p>Now why do we need this – not just me, but you?</p>

<p>For Emacs <code>compile-mode</code> output, so that these lines are recognized as failures, and so that you can jump from one failure to the next with the help of <code>next-error</code> (<kbd>C-x `</kbd>), for example.</p>

<p>By default, a filename without a relative path won’t be found if you click the error messagt, though; resolved against the base project directory, the file cannot be found. A filename without a path is insanity. What if you have <code>MyTests.swift</code> in two test targets? Tough luck. (Spoiler: Even though we’ll get the filename resolution to work, I still have no clue how to deal with this, and I strongly believe that <code>swift test</code> should have a <code>--print-path-in-output</code> flag so we can rely on the proper source of truth, and not some band-aid.)</p>

<p>Let’s not get ahead of ourselves; how do we teach this format to the Emacs compilation mode error detector?</p>

<p>If you learn by example, read these:</p>

<ul>
  <li><a href="https://www.emacswiki.org/emacs/CreatingYourOwnCompileErrorRegexp">EmacsWiki: Creating Your Own Compile Error Regexp</a></li>
  <li><a href="https://emacs.stackexchange.com/questions/44253/use-a-function-to-get-file-in-compilation-error-regexp-alist">Emacs StackExchange: use a function to get file in compilation-error-regexp-alist</a></li>
  <li><a href="https://github.com/Fuco1/compile-eslint/">Emacs compilation-mode support for ESLint</a> has a working example with conditional adding or replacing the regexp.</li>
</ul>

<p>If you hate yourself, <a href="https://doc.endlessparentheses.com/Var/compilation-error-regexp-alist-alist.html">read the manual (mirror)</a>. Oh wait, that’s <code>compilation-error-regexp-alist-alist</code>, where the regexp goes, not where it’s explained, <a href="https://doc.endlessparentheses.com/Var/compilation-error-regexp-alist.html">read the other manual page</a> on <code>compilation-error-regexp-alist</code>, where it explains:</p>

<blockquote>
  <p>Each elt has the form (REGEXP FILE [LINE COLUMN TYPE HYPERLINK
HIGHLIGHT…]). If REGEXP matches, the FILE’th subexpression
gives the file name, and the LINE’th subexpression gives the line
number. The COLUMN’th subexpression gives the column number on
that line.</p>

  <p>If FILE, LINE or COLUMN are nil or that index didn’t match, that
information is not present on the matched line. In that case the
file name is assumed to be the same as the previous one in the
buffer, line number defaults to 1 and column defaults to
beginning of line’s indentation.</p>

  <p>FILE can also have the form (FILE FORMAT…), where the FORMATs
(e.g. “%s.c”) will be applied in turn to the recognized file
name, until a file of that name is found. Or FILE can also be a
function that returns (FILENAME) or (RELATIVE-FILENAME . DIRNAME).
In the former case, FILENAME may be relative or absolute.</p>
</blockquote>

<p>Let me help you decode that: “FILE’th” is shorthand for “if you provide a number, the number is the group index in the regexp”; with Swift, we have <code>filename:line:column</code>, so it’s in order, and we can pass <code>1 2 3</code> for the regexp printed above.</p>

<p>We can match this alright, but the path is not resolvable, so we need a function. To use a function, put the function name in place of the literal <code>1</code>. The function will not take arguments.</p>

<p>How do you get the filename, in the function if it takes no arguments? You get it from the global regexp matching context: <code>(match-string-no-properties 1)</code> will behave like passing <code>1</code> to the alist. Or alist-alist.</p>

<p>For some reason of indirection, we have two alists:</p>

<ul>
  <li><code>compilation-error-regexp-alist</code>: can contain the full alist, but actually nowadays only contains a symbol per language, the language’s name. Here: <code>swift</code>. The actual regexps are included in:</li>
  <li><code>compilation-error-regexp-alist-alist</code>, which is an alist of alists. Hence the name. We’ll add an entry in a minute so you see how is elements are structured.</li>
</ul>

<p>First, here’s a working but probably not maximally efficient Swift path resolver based on a filename:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">ct/swift-compile-error-find-file</span> <span class="p">()</span>
  <span class="s">"Find Swift test file from matched filename in compilation buffer.

Extracts filename from match group 1 and searches for it in Tests 
directories or .
Returns (FILENAME) or (RELATIVE-FILENAME . DIRNAME) for compilation mode."</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">filename</span> <span class="p">(</span><span class="nv">match-string-no-properties</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">file-name-absolute-p</span> <span class="nv">filename</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">list</span> <span class="nv">filename</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">project-root</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">boundp</span> <span class="ss">'compilation-directory</span><span class="p">)</span>
                                 <span class="nv">compilation-directory</span><span class="p">)</span>
                               <span class="nv">default-directory</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">found-file</span> <span class="p">(</span><span class="nb">or</span>
                          <span class="c1">;; First try exact path from project root</span>
                          <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">file-exists-p</span> <span class="p">(</span><span class="nv">expand-file-name</span> <span class="nv">filename</span> <span class="nv">project-root</span><span class="p">))</span>
                            <span class="p">(</span><span class="nv">expand-file-name</span> <span class="nv">filename</span> <span class="nv">project-root</span><span class="p">))</span>
                          <span class="c1">;; Then search in Tests directories</span>
                          <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nv">file-expand-wildcards</span> 
                                <span class="p">(</span><span class="nv">expand-file-name</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"Tests/*/%s"</span> <span class="nv">filename</span><span class="p">)</span> <span class="nv">project-root</span><span class="p">)))</span>
                          <span class="c1">;; Try deeper nesting</span>
                          <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nv">file-expand-wildcards</span> 
                                <span class="p">(</span><span class="nv">expand-file-name</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"Tests/*/*/%s"</span> <span class="nv">filename</span><span class="p">)</span> <span class="nv">project-root</span><span class="p">)))</span>
                          <span class="c1">;; Try Sources directories too (for non-test files referenced in tests, just in case)</span>
                          <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nv">file-expand-wildcards</span> 
                                <span class="p">(</span><span class="nv">expand-file-name</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"Sources/*/%s"</span> <span class="nv">filename</span><span class="p">)</span> <span class="nv">project-root</span><span class="p">)))</span>
                          <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nv">file-expand-wildcards</span> 
                                <span class="p">(</span><span class="nv">expand-file-name</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"Sources/*/*/%s"</span> <span class="nv">filename</span><span class="p">)</span> <span class="nv">project-root</span><span class="p">))))))</span>
        <span class="p">(</span><span class="k">if</span> <span class="nv">found-file</span>
            <span class="p">(</span><span class="nb">list</span> <span class="nv">found-file</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">list</span> <span class="nv">filename</span><span class="p">))))))</span>
</code></pre></div></div>

<p>So this <code>file-expand-wildcards</code> usage will hopefully find all kinds of Swift files in <code>Tests/</code>. During interactive tests, I found that the glob will not match infinite subdirectories, so if you have deep directory structures – I’m sorry, then you need to add more deeply nested expansions. (Thanks again, <code>swift test</code> …)</p>

<p>So finally, we add the ‘swift’ symbol to both alists, and include the regular expression in weird Emacs Lisp form, where you need to escape the grouping parentheses:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">push</span> <span class="ss">'swift</span> <span class="nv">compilation-error-regexp-alist</span><span class="p">)</span>
<span class="p">(</span><span class="nb">push</span> <span class="o">'</span><span class="p">(</span><span class="nv">swift</span> 
        <span class="s">"^.* Test .* recorded an issue at \\([a-zA-Z0-9_/ ]+\\.swift\\):\\([0-9]+\\):\\([0-9]+\\): "</span>
        <span class="nv">ct/swift-compile-error-find-file</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
      <span class="nv">compilation-error-regexp-alist-alist</span><span class="p">)</span>
</code></pre></div></div>

<p>Here you see that instead of just passing the group indices <code>1</code>, <code>2</code>, and <code>3</code>, we pass the function name instead of the filename group index, and <code>2</code> and <code>3</code>.</p>

<p>With this glorious change, you can click on test failures and use <code>next-error</code> and friends.</p>

<p>Now if you have the same test file name in two directories, you’re screwed. It’s ambiguous. Nothing to do about it. <code>file-expand-wildcards</code> will return a list of relative paths to the files anyway, which is very considerate, but it won’t help you decide which one is the correct one.</p>

<p>You could match the test case name in the regular expression, too, and then look for the test definition in both files and return the path of the file that contains the test case name. To further disambiguate, you could also use the line number to check for the location of the test case.</p>

<p>This sounds ridiculous because it is. We shouldn’t need to do this.</p>

<p>If you have two test files with two identical test case names at the exact same line number, you’re still screwed. I’m sorry.</p>

<p>Only thing that could help is a <code>swift</code> flag to include the relative path. Which would’ve been a great idea anyway. But alas.</p>
<hr><p><small><a href="https://christiantietze.de/hire-me/">Hire me</a> for freelance macOS/iOS work and consulting.</small></p><p><small><a href="https://christiantietze.de/apps/">Buy</a> my apps.</small></p><p><small><a href="https://christiantietze.de/newsletter/">Receive</a> new posts via email.</small></p>