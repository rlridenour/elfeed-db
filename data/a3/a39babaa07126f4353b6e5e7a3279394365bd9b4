<p>Which Django interactive framework is actually the fastest? LiveView, HTMX, Unicorn, Reactor, or good old server-side rendering? I don't know, but I'd like to find out. Is investing time in WebSockets a waste? Is hmtx slow? So many questions to answer.</p>
<p>The results were... surprising.</p>
<h2 id="blog-single-content__title--technology-comparison" class="blog-single__content-title">Technology Comparison</h2>
<p>First, a quick overview of the technologies compared:</p>
<div class="table"><table>
<thead>
<tr>
<th>Feature</th>
<th>LiveView</th>
<th>SSR</th>
<th>django-htmx</th>
<th>Unicorn</th>
<th>Reactor</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Transport</strong></td>
<td>WebSocket</td>
<td>HTTP</td>
<td>AJAX</td>
<td>AJAX</td>
<td>WebSocket</td>
</tr>
<tr>
<td><strong>Update Type</strong></td>
<td>Real-time</td>
<td>Full reload</td>
<td>Partial</td>
<td>Reactive</td>
<td>Real-time</td>
</tr>
<tr>
<td><strong>Multi-user</strong></td>
<td>‚úÖ Broadcast</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>‚úÖ Broadcast</td>
</tr>
<tr>
<td><strong>Infrastructure</strong></td>
<td>Redis + Channels</td>
<td>Django only</td>
<td>Django only</td>
<td>Django only</td>
<td>Redis + Channels</td>
</tr>
</tbody>
</table>
</div><h2 id="blog-single-content__title--performance-testing" class="blog-single__content-title">Performance Testing</h2>
<p>To settle this question, I built an identical alert management system using each framework. The test workflow: click a button that creates a database record, wait for it to render on the page, navigate to a form (page/modal), intentionally fail validation, see error messages, submit correctly, return to the previous screen, and verify the new element appears. Pretty easy and common workflow.</p>
<p>Each framework was tested 10 times using Chrome DevTools Performance API, measuring:</p>
<ul>
<li><strong>Response time</strong>: From button click to UI update</li>
<li><strong>Network requests</strong>: HTTP calls or WebSocket messages</li>
<li><strong>Data transfer</strong>: Bytes sent over the wire</li>
</ul>
<p>Fair and square. Same system, same test, same browser.</p>
<p><a href="https://github.com/tanrax/django-interactive-frameworks-benchmark">My code is here</a></p>
<h3 id="blog-single-content__title--results-summary" class="blog-single__content-title">Results Summary</h3>
<div class="table"><table>
<thead>
<tr>
<th>Implementation</th>
<th>Avg Response Time</th>
<th>Network Requests</th>
<th>Data Transfer</th>
<th>Technology</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LiveView</strong></td>
<td><strong>9.35ms</strong></td>
<td>0 (WebSocket)</td>
<td>0.44 KB</td>
<td>WebSocket messages</td>
</tr>
<tr>
<td><strong>Reactor</strong></td>
<td><strong>12.00ms</strong></td>
<td>0 (WebSocket)</td>
<td>0.51 KB</td>
<td>WebSocket components</td>
</tr>
<tr>
<td><strong>django-htmx</strong></td>
<td><strong>16.48ms</strong></td>
<td>1 HTTP request</td>
<td>36.13 KB</td>
<td>AJAX partial HTML</td>
</tr>
<tr>
<td><strong>Unicorn</strong></td>
<td><strong>26.76ms</strong></td>
<td>1 HTTP request</td>
<td>69.34 KB</td>
<td>AJAX component sync</td>
</tr>
<tr>
<td><strong>SSR</strong></td>
<td><strong>47.25ms</strong></td>
<td>2 HTTP requests</td>
<td>8.30 KB</td>
<td>POST + redirect GET</td>
</tr>
</tbody>
</table>
</div><h3 id="blog-single-content__title--performance-visualizations" class="blog-single__content-title">Performance Visualizations</h3>
<p>All charts indicate that <strong>lower values are better</strong> for optimal performance.</p>
<h4 id="blog-single-content__title--response-time-comparison" class="blog-single__content-title">Response Time Comparison</h4>
<p><img alt="Response Time Comparison" src="https://img.andros.dev/DMdD2axB0ohSx37zoMkQ4kClSHo=/filters:format(avif)/https://andros.dev/media/blog/2025/12/benchmark-response-time.png" /></p>
<p><em>Average response times across implementations. LiveView (9.35ms) is fastest, followed by Reactor (12.00ms), django-htmx (16.48ms), Unicorn (26.76ms), and SSR (47.25ms).</em></p>
<h4 id="blog-single-content__title--http-requests-per-action" class="blog-single__content-title">HTTP Requests per Action</h4>
<p><img alt="HTTP Requests Comparison" src="https://img.andros.dev/n4CW9ccD5BmAfdQLDaDsW2Jvrr8=/filters:format(avif)/https://andros.dev/media/blog/2025/12/benchmark-network-requests.png" /></p>
<p><em>Number of HTTP requests required per action. LiveView and Reactor use 0 HTTP requests (WebSocket), while SSR requires 2 (POST + redirect).</em></p>
<h4 id="blog-single-content__title--data-transfer-overhead" class="blog-single__content-title">Data Transfer Overhead</h4>
<p><img alt="Data Transfer Comparison" src="https://img.andros.dev/S2B36mKT5xTiZNPs_wGGdXDjinY=/filters:format(avif)/https://andros.dev/media/blog/2025/12/benchmark-data-transfer.png" /></p>
<p><em>Amount of data transferred per action. LiveView (0.44 KB) and Reactor (0.51 KB) transfer minimal data, while Unicorn transfers the most (69 KB).</em></p>
<h4 id="blog-single-content__title--performance-stability" class="blog-single__content-title">Performance Stability</h4>
<p><img alt="Performance Stability" src="https://img.andros.dev/9itv8fTo-f3Ko2z3OJ7g5ir-CXc=/filters:format(avif)/https://andros.dev/media/blog/2025/12/benchmark-stability.png" /></p>
<p><em>Response time consistency across 10 iterations. Lower and flatter lines indicate better, more stable performance.</em></p>
<h3 id="blog-single-content__title--key-findings" class="blog-single__content-title">Key Findings</h3>
<p><strong>üèÜ Speed Winner: LiveView (9.35ms)</strong></p>
<ul>
<li>WebSocket communication eliminates HTTP overhead</li>
<li>Real-time bidirectional connection already established</li>
<li>Minimal data transfer (0.44 KB per action)</li>
<li>Best for: Real-time dashboards, collaborative apps, maximum performance</li>
</ul>
<p><strong>ü•à Runner-up: Reactor (12.00ms)</strong></p>
<ul>
<li>Phoenix LiveView-style architecture with WebSocket</li>
<li>Component-based approach with excellent speed</li>
<li>Only 28% slower than LiveView, 4x faster than SSR</li>
<li>Best for: Structured components with near-LiveView performance</li>
</ul>
<p><strong>ü•â Third Place: django-htmx (16.48ms)</strong></p>
<ul>
<li>Best AJAX solution, 38% faster than Unicorn</li>
<li>Efficient partial updates, minimal JavaScript</li>
<li>Good balance of speed and simplicity</li>
<li>Best for: Modern UX without WebSockets</li>
</ul>
<p><strong>4Ô∏è‚É£ Fourth Place: Unicorn (26.76ms)</strong></p>
<ul>
<li>Component-based with two-way data binding</li>
<li>Full component state synchronization</li>
<li>Larger payloads (69 KB) due to component data</li>
<li>Best for: Interactive forms with complex state management</li>
</ul>
<p><strong>5Ô∏è‚É£ Traditional: SSR (47.25ms)</strong></p>
<ul>
<li>Full page reload with complete render cycle</li>
<li>Two HTTP requests (POST + redirect GET)</li>
<li>Slowest but simplest infrastructure</li>
<li>Best for: SEO-critical pages, simple CRUD apps</li>
</ul>
<h2 id="blog-single-content__title--conclusions" class="blog-single__content-title">Conclusions</h2>
<ol>
<li><strong>WebSocket Dominance</strong>: Both LiveView (9.35ms) and Reactor (12.00ms) outperform HTTP-based solutions by 43-80%, with zero HTTP requests per action.</li>
<li><strong>Reactor vs LiveView</strong>: Reactor is 28% slower than LiveView but offers Phoenix LiveView-style components. Both transfer minimal data (0.44-0.51 KB) compared to AJAX solutions.</li>
<li><strong>Best AJAX Solution</strong>: django-htmx (16.48ms) is 38% faster than Unicorn (26.76ms), proving that simpler approaches often win in the AJAX category.</li>
<li><strong>Component Overhead</strong>: Unicorn's full state sync adds significant overhead (69 KB vs django-htmx's 36 KB), trading bandwidth for richer interactivity.</li>
<li><strong>Network Efficiency</strong>: WebSocket solutions (LiveView, Reactor) transfer 70-157x less data than AJAX solutions, demonstrating superior efficiency.</li>
<li><strong>Stability</strong>: WebSocket implementations show excellent consistency (std dev &lt;1.2ms) while all frameworks maintain stable performance across iterations.</li>
</ol>
<p>In summary, if maximum speed and efficiency are your goals, WebSocket-based frameworks like LiveView and Reactor are the clear winners. For those seeking a balance of speed and simplicity without WebSockets, django-htmx and Unicorn is a strong contender. If you prioritize simplicity and SEO, traditional SSR remains a viable option despite its slower performance.</p>