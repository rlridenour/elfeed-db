<p>While adding more rendering capabilities to <a href="https://plainorg.com">Plain Org</a>, it soon became apparent some sort of screenshot/snapshot testing was necessary to prevent regressing existing features. That is, we first generate a rendered snapshot from a given org snippet, followed by some visual inspection, right before we go and save the blessed snapshot (often referred to as golden) to our project. Future changes are validated against the golden snapshot to ensure rendering is still behaving as expected.</p>
<p>Let's say we'd like to validate table rendering with links, we can write a test as follows:</p>
<pre><code class="language-swift">func testTableWithLinks() throws {
  assertSnapshot(
    matching: OrgMarkupText.make(
      &quot;&quot;&quot;
      | URL                    | Org link    |
      |------------------------+-------------|
      | https://flathabits.com | [[https://flathabits.com][Flat Habits]] |
      | Regular text           | Here too    |
      |------------------------+-------------|
      &quot;&quot;&quot;),
    as: .image(layout: .sizeThatFits))
}
</code></pre>
<p>The corresponding snapshot golden can be seen below.</p>
<p><img src="https://xenodium.github.io/images/emacs-bends-again/testTableWithLinks.1.png" alt=""></p>
<p>This is all done rather effortlessly thanks to <a href="https://twitter.com/pointfreeco">Point Free</a>'s wonderful <a href="https://github.com/pointfreeco/swift-snapshot-testing">swift-snapshot-testing</a> utilities.</p>
<p>So what does any of this have to do with Emacs? You see, as I added more snapshot tests and made modifications to the rendering logic, I needed a quick way to visually inspect and override all goldens. All the main pieces were already there, I just needed some elisp glue to <em>bend Emacs my way™.</em></p>
<p>First, I needed to run my Xcode builds from the command line. This is already <a href="https://developer.apple.com/library/archive/technotes/tn2339/_index.html">supported via xcodebuild</a>. Next, I needed a way to parse test execution data to extract failing tests. <a href="https://twitter.com/davidahouse">David House</a>'s <a href="https://github.com/davidahouse/xcodebuild-to-json">xcodebuild-to-json</a> handles this perfectly. What's left? Glue it all up with some elisp.</p>
<p>Beware, the following code snippet is packed with assumptions about my project, it's messy, surely has bugs, can be optimized, etc. But the important point here is that Emacs is such an amazing malleable power tool. Throw some elisp at it and you can to bend it to your liking. After all, it's [your]{.underline} editor.</p>
<p>And so here we are, I can now run snapshot tests from Emacs using my hacked up <code>plainorg-snapshot-test-all</code> function and quickly override (or ignore) all newly generated snapshots by merely pressing y/n keys. Oh, and our beloved web browser was also invited to the party. Press &quot;d&quot; to open two browser tabs if you'd like to take a closer look (not demoed below).</p>
<p>Success. <em>Emacs bends again</em>.</p>
<p><img src="https://xenodium.github.io/images/emacs-bends-again/diff.gif" alt=""></p>
<pre><code class="language-{.commonlisp">;;; -*- lexical-binding: t; -*-

(defun plainorg-snapshot-test-all ()
  &quot;Invoke xcodebuild, compare failed tests screenshots side-to-side,
and offer to override them.&quot;
  (interactive)
  (let* ((project (cdr (project-current)))
         (json-tmp-file (make-temp-file &quot;PlainOrg_Tests_&quot; nil &quot;.json&quot;))
         (default-directory project))
    (unless (file-exists-p (concat project &quot;PlainOrg.xcodeproj&quot;))
      (user-error &quot;Not in PlainOrg project&quot;))
    (set-process-sentinel
     (start-process
      &quot;xcodebuild&quot;
      (with-current-buffer
          (get-buffer-create &quot;*xcodebuild*&quot;)
        (let ((inhibit-read-only t))
          (erase-buffer))
        (current-buffer))
      &quot;/usr/bin/xcodebuild&quot;
      &quot;-scheme&quot; &quot;PlainOrg&quot; &quot;-target&quot; &quot;PlainOrgTests&quot; &quot;-destination&quot; &quot;name=iPhone 13&quot; &quot;-quiet&quot; &quot;test&quot;)
     (lambda (p e)
       (with-current-buffer (get-buffer &quot;*xcodebuild*&quot;)
         (let ((inhibit-read-only t))
           (insert (format &quot;xcodebuild exit code: %d\n\n&quot; (process-exit-status p)))))
       (when (not (eq 0 (process-exit-status p)))
         (set-process-sentinel
          (start-process
           &quot;xcodebuild-to-json&quot;
           &quot;*xcodebuild*&quot;
           &quot;/opt/homebrew/bin/xcodebuild-to-json&quot;
           &quot;--derived-data-folder&quot; (format &quot;/Users/%s/Library/Developer/Xcode/DerivedData/&quot;
                                           (user-login-name)) &quot;--output&quot; json-tmp-file)
          (lambda (p e)
            (with-current-buffer (get-buffer &quot;*xcodebuild*&quot;)
              (let ((inhibit-read-only t))
                (insert (format &quot;xcodebuild-to-json exit code: %d\n\n&quot; (process-exit-status p)))))
            (when (= 0 (process-exit-status p))
              (with-current-buffer (get-buffer &quot;*xcodebuild*&quot;)
                (let ((inhibit-read-only t))
                  (insert &quot;Screenshot comparison started\n\n&quot;)))
              (plainorg--snapshot-process-json (get-buffer &quot;*xcodebuild*&quot;) json-tmp-file)
              (with-current-buffer (get-buffer &quot;*xcodebuild*&quot;)
                (let ((inhibit-read-only t))
                  (insert &quot;\nScreenshot comparison finished\n&quot;))
                (read-only-mode +1))))))))
    (switch-to-buffer-other-window &quot;*xcodebuild*&quot;)))

(defun plainorg--snapshot-process-json (result-buffer json)
  &quot;Find all failed snapshot tests in JSON and offer to override
 screenshots, comparing them side to side.&quot;
  (let ((hashtable (with-current-buffer (get-buffer-create &quot;*build json*&quot;)
                     (erase-buffer)
                     (insert-file-contents json)
                     (json-parse-buffer))))
    (mapc
     (lambda (item)
       (when (equal (gethash &quot;id&quot; item)
                    &quot;SnapshotTests&quot;)
         (mapc
          (lambda (testCase)
            (when (and (gethash &quot;failureMessage&quot; testCase)
                       (string-match-p &quot;Snapshot does not match reference&quot;
                                       (gethash &quot;failureMessage&quot; testCase)))
              (let* ((paths (plainorg--snapshot-screenshot-paths
                             (gethash &quot;failureMessage&quot; testCase)))
                     (override-result (plainorg--snapshot-override-image
                                       &quot;Expected screenshot&quot;
                                       (nth 0 paths) ;; old
                                       &quot;Actual screenshot&quot;
                                       (nth 1 paths) ;; new
                                       (nth 0 paths))))
                (when override-result
                  (with-current-buffer result-buffer
                    (let ((inhibit-read-only t))
                      (insert override-result)
                      (insert &quot;\n&quot;)))))))
          (gethash &quot;testCases&quot; item))))
     (gethash &quot;classes&quot; (gethash &quot;details&quot; hashtable)))))

(defun plainorg--snapshot-screenshot-paths (failure-message)
  &quot;Extract a paths list from FAILURE-MESSAGE of the form:

failed - Snapshot does not match reference.

@−
\&quot;/path/to/expected/screenshot.1.png\&quot;
@+
\&quot;/path/to/actual/screenshot.1.png\&quot;

Newly-taken snapshot does not match reference.
&quot;
  (mapcar
   (lambda (line)
     (string-remove-suffix &quot;\&quot;&quot;
                           (string-remove-prefix &quot;\&quot;&quot; line)))
   (seq-filter
    (lambda (line)
      (string-prefix-p &quot;\&quot;&quot; line))
    (split-string failure-message &quot;\n&quot;))))

(defun plainorg--snapshot-override-image (old-buffer old new-buffer new destination)
  (let ((window-configuration (current-window-configuration))
        (action)
        (result))
    (unwind-protect
        (progn
          (delete-other-windows)
          (split-window-horizontally)
          (switch-to-buffer (with-current-buffer (get-buffer-create old-buffer)
                              (let ((inhibit-read-only t))
                                (erase-buffer))
                              (insert-file-contents old)
                              (image-mode)
                              (current-buffer)))
          (switch-to-buffer-other-window (with-current-buffer (get-buffer-create new-buffer)
                                           (let ((inhibit-read-only t))
                                             (erase-buffer))
                                           (insert-file-contents new)
                                           (image-mode)
                                           (current-buffer)))
          (while (null result)
            (setq action (read-char-choice (format &quot;Override %s? (y)es (n)o (d)iff in browser? &quot;
                                                   (file-name-base old))
                                           '(?y ?n ?d ?q)))
            (cond ((eq action ?n)
                   (setq result
                         (format &quot;Keeping old %s&quot; (file-name-base old))))
                  ((eq action ?y)
                   (copy-file new old t)
                   (setq result
                         (format &quot;Overriding old %s&quot; (file-name-base old))))
                  ((eq action ?d)
                   (shell-command (format &quot;open -a Firefox %s --args --new-tab&quot; old))
                   (shell-command (format &quot;open -a Firefox %s --args --new-tab&quot; new)))
                  ((eq action ?q)
                   (set-window-configuration window-configuration)
                   (setq result (format &quot;Quit %s&quot; (file-name-base old)))))))
      (set-window-configuration window-configuration)
      (kill-buffer old-buffer)
      (kill-buffer new-buffer))
    result))
</code></pre>
