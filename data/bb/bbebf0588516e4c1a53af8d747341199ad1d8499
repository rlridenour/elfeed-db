<p>
As many of you know, your can output to a buffer directly from within Eshell by redirecting the output to a <code>#&lt;buffer ...&gt;</code> structure like this
</p>
<div class="org-src-container">
<pre class="src src-eshell">Welcome to the Emacs shell

~/org/blog $ echo "Hello World!" &gt; #&lt;buffer hello-buffer&gt;
</pre>
</div>
<p>
That naming convention may seem weird but it&rsquo;s exactly how Emacs refers to buffers. As Christian Tietze says in <a href="https://christiantietze.de/posts/2025/10/redirect-output-to-buffers-from-emacs-eshell/">this post about redirecting output to a buffer</a> you can see this by executing the <code>current-buffer</code> command (it&rsquo;s not an interactive function so you have to call it as <code>(current-buffer)</code> in some Elisp context).
</p>
<p>
Tietze covers all this in his post but the interesting thing is that he hates having to remember and type the <code>#&lt;buffer ...&gt;</code> structure. I can sympathize. I got it wrong at least once while preparing this post. Tietze has the solution. He wrote a function, <code>new-buffer</code>, that generates a temporary buffer and returns it just as if you had specified it with the buffer notation. Then he can write <code>Hello World!</code> into a temporary buffer like this
</p>
<div class="org-src-container">
<pre class="src src-eshell">Welcome to the Emacs shell

~/org/blog $ echo "Hello World!" &gt; (new-buffer)
</pre>
</div>
<p>
That&rsquo;s a bit easier to remember and less clumsy to type than the <code>#&lt;buffer ...&gt;</code> construct.
</p>
<p>
Of course, as Tietze says, all this makes sense only if you&rsquo;re already in Eshell. Otherwise, you can achieve the same result by simply using <code>shell-command</code> or <code>async-shell-command</code>. Regardless, Tietze&rsquo;s post is interesting and worth a couple minutes of your time.</p>
