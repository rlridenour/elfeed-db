
         
         <p>I have been doing a lot of work these days on my themes. The immediate
goal is two-fold: (i) make the <code class="language-plaintext highlighter-rouge">modus-themes</code> more flexible so they
can be used as a the basis for other theme packages and (ii) make the
<code class="language-plaintext highlighter-rouge">ef-themes</code> the first project to benefit from this development. Having
the Modus themes as a foundation gives us all of their customisability
and extensive face coverage for little extra work. The themes are well
tested and are also shipped with core Emacs. It all fits together.</p>

<p>In this article, I give you the big picture view of how this is
supposed to work. Remember that the only source of truth for my
packages is their corresponding manual. Any blog post is useful the
time it is written but will eventually go out of date.</p>

<h2>Symbol properties for themes</h2>

<p>When we define a theme, we essentially add properties to a symbol. In
its simplest form, this is how:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">put</span> <span class="ss">'my-test-symbol</span> <span class="ss">'my-test-proerty</span> <span class="s">"Hello world test value"</span><span class="p">)</span>
</code></pre></div></div>

<p>Evaluate the above and then try the following:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span> <span class="ss">'my-test-symbol</span> <span class="ss">'my-test-proerty</span><span class="p">)</span>
<span class="c1">;; =&gt; "Hello world test value"</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">custom-declare-theme</code> does the heavy lifting, while the
<code class="language-plaintext highlighter-rouge">deftheme</code> macro streamlines most of that work. Still, the point is
that we have symbols whose properties we can access and, thus, we can
filter by any given property. To make things even better, we can add
arbitrary properties to a theme. Here is a real scenario of
<strong>_in-development code that might change</strong>:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span> <span class="ss">'modus-operandi</span> <span class="ss">'theme-properties</span><span class="p">)</span>
<span class="c1">;; =&gt; (:kind color-scheme :background-mode light :family modus-themes :modus-core-palette modus-themes-operandi-palette :modus-user-palette modus-operandi-palette-user :modus-overrides-palette modus-operandi-palette-overrides)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">theme-properties</code> has as a plist value. Its Modus-specific
properties are references to variables that we can use to do our work,
such as to put together a theme palette that combines the relevant
overrides with the core entries.</p>

<h2>Getting a list of themes based on their properties</h2>

<p>When we declare a theme with <code class="language-plaintext highlighter-rouge">custom-declare-theme</code>, we make it known
to Emacs by adding it to the <code class="language-plaintext highlighter-rouge">custom-known-themes</code>. When we eventually
load a theme, its symbol gets stored in the <code class="language-plaintext highlighter-rouge">custom-enabled-themes</code>.
Knowing that themes have properties, we can filter those lists
accordingly. With my current development code, I can do this, for
example:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">my-demo-is-modus-p</span> <span class="p">(</span><span class="nv">theme</span><span class="p">)</span>
  <span class="s">"Return non-nil if THEME has `modus-themes' :family property."</span>
  <span class="p">(</span><span class="nv">when-let*</span> <span class="p">((</span><span class="nv">properties</span> <span class="p">(</span><span class="nb">get</span> <span class="nv">theme</span> <span class="ss">'theme-properties</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">family</span> <span class="p">(</span><span class="nv">plist-get</span> <span class="nv">properties</span> <span class="ss">:family</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">eq</span> <span class="nv">family</span> <span class="ss">'modus-themes</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">seq-filter</span> <span class="nf">#'</span><span class="nv">my-demo-is-modus-p</span> <span class="nv">custom-known-themes</span><span class="p">)</span>
<span class="c1">;; =&gt; (modus-vivendi-tritanopia modus-vivendi-tinted modus-vivendi modus-vivendi-deuteranopia modus-operandi-tritanopia modus-operandi-tinted modus-operandi modus-operandi-deuteranopia)</span>
</code></pre></div></div>

<p>The next step from here is to make all the Modus infrastructure rely
on generic functions and methods for working with themes. Then any
package can provides its own method for returning a list of desired
themes.</p>

<h2>Generic function and methods for getting a list of themes</h2>

<p>Emacs Lisp has a concept of generic functions, which it borrows from
Common Lisp. The general idea is to have a single symbol, like
<code class="language-plaintext highlighter-rouge">modus-themes-get-themes</code> whose implementation details are
instantiated via specialised methods. For example, when a minor mode
is active, a given method takes effect, thus changing what
<code class="language-plaintext highlighter-rouge">modus-themes-get-themes</code> actually does.</p>

<p>The default implementation is this:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">cl-defgeneric</span> <span class="nv">modus-themes-get-themes</span> <span class="p">()</span>
  <span class="s">"Return a list of all themes with `modus-themes' :family property."</span>
  <span class="p">(</span><span class="nv">modus-themes-get-all-known-themes</span> <span class="ss">'modus-themes</span><span class="p">))</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">modus-themes-get-all-known-themes</code> has a filter like the
one I demonstrated in the code block further above. By default, this
is what I get when I run the aforementioned generic function:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">modus-themes-get-themes</span><span class="p">)</span>
<span class="c1">;; =&gt; (modus-operandi modus-operandi-tinted modus-operandi-deuteranopia modus-operandi-tritanopia modus-vivendi modus-vivendi-tinted modus-vivendi-deuteranopia modus-vivendi-tritanopia)</span>
</code></pre></div></div>

<p>The beauty of this design is that another package can define a method
to make the same code return something else. This is how I do it in
the current development target of the <code class="language-plaintext highlighter-rouge">ef-themes</code> (again, the actual
code might change):</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">cl-defmethod</span> <span class="nv">modus-themes-get-themes</span> <span class="p">(</span><span class="nv">&amp;context</span> <span class="p">(</span><span class="nv">ef-themes-take-over-modus-themes-mode</span> <span class="p">(</span><span class="nb">eql</span> <span class="no">t</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">modus-themes-get-all-known-themes</span> <span class="ss">'ef-themes</span><span class="p">))</span>
</code></pre></div></div>

<p>Notice that this method has a <code class="language-plaintext highlighter-rouge">&amp;context</code>, which is the scenario in
which it is relevant. In this case, we have a minor mode that
activates the method when it is enabled:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">define-minor-mode</span> <span class="nv">ef-themes-take-over-modus-themes-mode</span>
  <span class="s">"When enabled, all Modus themes commands consider only Ef themes."</span>
  <span class="ss">:global</span> <span class="no">t</span>
  <span class="ss">:init-value</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>This minor mode does not have anything in its body. It does not need
to, because the <code class="language-plaintext highlighter-rouge">define-minor-mode</code> macro already instantiates the
parts we care about. Namely, when we call the function defined by the
minor mode (i.e. <code class="language-plaintext highlighter-rouge">ef-themes-take-over-modus-themes-mode</code>), it toggles
the value of the variable <code class="language-plaintext highlighter-rouge">ef-themes-take-over-modus-themes-mode</code>
(functions and variables have separate namespaces in Emacs Lisp and
thus the same symbol can be in both places). Our method then becomes
relevant when the user enables the minor mode:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">ef-themes-take-over-modus-themes-mode</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>And now the generic function <code class="language-plaintext highlighter-rouge">modus-themes-get-themes</code> does something
else:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">modus-themes-get-themes</span><span class="p">)</span>
<span class="c1">;; =&gt; (ef-winter ef-tritanopia-light ef-tritanopia-dark ef-trio-light ef-trio-dark ef-symbiosis ef-summer ef-spring ef-rosa ef-reverie ef-owl ef-night ef-melissa-light ef-melissa-dark ef-maris-light ef-maris-dark ef-light ef-kassio ef-frost ef-elea-light ef-elea-dark ef-eagle ef-duo-light ef-duo-dark ef-dream ef-deuteranopia-light ef-deuteranopia-dark ef-day ef-dark ef-cyprus ef-cherie ef-bio ef-autumn ef-arbutus)</span>
</code></pre></div></div>

<p>Since all the Modus functions are redesigned to work with this generic
function, we can now use commands like <code class="language-plaintext highlighter-rouge">modus-themes-select</code> or even
<code class="language-plaintext highlighter-rouge">modus-themes-list-colors</code> for any of those themes.</p>

<p>As a bonus, we can now seamlessly blend Modus themes with their
derivatives. Imagine a user who wants to invoke the command
<code class="language-plaintext highlighter-rouge">modus-themes-load-random</code> (or its variants for light and dark themes)
and have it consider the likes of <code class="language-plaintext highlighter-rouge">modus-operandi</code> and <code class="language-plaintext highlighter-rouge">ef-dream</code>.
Users can opt in to this feature via the minor mode that the Modus
themes provide called <code class="language-plaintext highlighter-rouge">modus-themes-include-derivatives-mode</code>. It is
the same ideas as the minor mode for the Ef themes, mentioned above:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">define-minor-mode</span> <span class="nv">modus-themes-include-derivatives-mode</span>
  <span class="s">"When enabled, all Modus themes commands cover derivatives as well.
Otherwise, they only consider the `modus-themes-items'.

Derivative theme projects can implement the equivalent of this minor
mode plus a method for `modus-themes-get-themes' to filter themes
accordingly."</span>
  <span class="ss">:global</span> <span class="no">t</span>
  <span class="ss">:init-value</span> <span class="no">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nv">cl-defmethod</span> <span class="nv">modus-themes-get-themes</span> <span class="p">(</span><span class="nv">&amp;context</span> <span class="p">(</span><span class="nv">modus-themes-include-derivatives-mode</span> <span class="p">(</span><span class="nb">eql</span> <span class="no">t</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">modus-themes-get-all-known-themes</span> <span class="no">nil</span><span class="p">))</span>
</code></pre></div></div>

<p>This is what happens when I load both the <code class="language-plaintext highlighter-rouge">modus-themes</code> and the
<code class="language-plaintext highlighter-rouge">ef-themes</code> and enable this “all good ones fit” minor mode:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">modus-themes-include-derivatives-mode</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nv">modus-themes-get-themes</span><span class="p">)</span>
<span class="c1">;; =&gt; (modus-operandi modus-operandi-tinted modus-operandi-deuteranopia modus-operandi-tritanopia modus-vivendi modus-vivendi-tinted modus-vivendi-deuteranopia modus-vivendi-tritanopia ef-winter ef-tritanopia-light ef-tritanopia-dark ef-trio-light ef-trio-dark ef-symbiosis ef-summer ef-spring ef-rosa ef-reverie ef-owl ef-night ef-melissa-light ef-melissa-dark ef-maris-light ef-maris-dark ef-light ef-kassio ef-frost ef-elea-light ef-elea-dark ef-eagle ef-duo-light ef-duo-dark ef-dream ef-deuteranopia-light ef-deuteranopia-dark ef-day ef-dark ef-cyprus ef-cherie ef-bio ef-autumn ef-arbutus)</span>
</code></pre></div></div>

<p>And when I no longer want to include everything, I just disable the
minor mode:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">modus-themes-include-derivatives-mode</span> <span class="mi">-1</span><span class="p">)</span>

<span class="p">(</span><span class="nv">modus-themes-get-themes</span><span class="p">)</span>
<span class="c1">;; =&gt; (modus-operandi modus-operandi-tinted modus-operandi-deuteranopia modus-operandi-tritanopia modus-vivendi modus-vivendi-tinted modus-vivendi-deuteranopia modus-vivendi-tritanopia)</span>
</code></pre></div></div>

<p>It is a thing of beauty!</p>

<h2>Finalising the implementation details</h2>

<p>I am still experimenting with some of the technicalities involved. In
principle, derivative themes will (i) depend on the <code class="language-plaintext highlighter-rouge">modus-themes</code>,
(ii) define each of their themes using the <code class="language-plaintext highlighter-rouge">modus-themes-theme</code> macro,
and (iii) specify how/when they affect the behaviour of the generic
function <code class="language-plaintext highlighter-rouge">modus-themes-get-themes</code>.</p>

<p>The code I am working on will soon be available in the respective
<code class="language-plaintext highlighter-rouge">main</code> branch of <code class="language-plaintext highlighter-rouge">modus-themes.git</code> and <code class="language-plaintext highlighter-rouge">ef-themes.git</code>. I think this
gives us the tools to realise the full potential of the Modus themes.</p>

<p>Finally, it is not just package authors that can benefit from this
development. Users may also curate their themes with something as
basic as this:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">cl-defmethod</span> <span class="nv">modus-themes-get-themes</span> <span class="p">()</span>
  <span class="o">'</span><span class="p">(</span><span class="nv">modus-operandi</span> <span class="nv">ef-eagle</span> <span class="nv">modus-vivendi-tinted</span> <span class="nv">ef-melissa-dark</span><span class="p">))</span>

<span class="p">(</span><span class="nv">modus-themes-get-themes</span><span class="p">)</span>
<span class="c1">;; =&gt; (modus-operandi ef-eagle modus-vivendi-tinted ef-melissa-dark)</span>
</code></pre></div></div>

<p>In this method, there is no function involved for returning a list of
themes nor an opt-in clause. It simply hardcodes a list of themes. The
point is that it works! The approach with the minor mode will usually
be better and is easy enough. It is all a matter of empowering
personal preference, which is the Emacs-y outlook, after all. I expect
users to define their own collections, as they see fit.</p>

<p>Have fun!</p>

<h2>About the Modus themes</h2>

<p>Highly accessible themes, conforming with the highest standard for
colour contrast between background and foreground values (WCAG AAA).
They also are optimised for users with red-green or blue-yellow colour
deficiency.</p>

<p>The themes are very customisable and provide support for a wide range
of packages.  Their manual is detailed so that new users can get
started, while it also provides custom code for all sorts of more
advanced customisations.</p>

<p>Since August 2020, the original Modus themes (<code class="language-plaintext highlighter-rouge">modus-operandi</code>,
<code class="language-plaintext highlighter-rouge">modus-vivendi</code>) are built into Emacs version 28 or higher. Emacs 28
ships with <code class="language-plaintext highlighter-rouge">modus-themes</code> version <code class="language-plaintext highlighter-rouge">1.6.0</code>. Emacs 29 includes version
<code class="language-plaintext highlighter-rouge">3.0.0</code>. Emacs 30 provides version <code class="language-plaintext highlighter-rouge">4.4.0</code>. Version 4 is a major
refactoring of how the themes are implemented and customised. Such
major versions are not backward-compatible due to the limited
resources at my disposal to support multiple versions of Emacs and of
the themes across the years.</p>

<ul>
  <li>Package name (GNU ELPA): <code class="language-plaintext highlighter-rouge">modus-themes</code></li>
  <li>Official manual: <a href="https://protesilaos.com/emacs/modus-themes">https://protesilaos.com/emacs/modus-themes</a></li>
  <li>Change log: <a href="https://protesilaos.com/emacs/modus-themes-changelog">https://protesilaos.com/emacs/modus-themes-changelog</a></li>
  <li>Colour palette: <a href="https://protesilaos.com/emacs/modus-themes-colors">https://protesilaos.com/emacs/modus-themes-colors</a></li>
  <li>Sample pictures: <a href="https://protesilaos.com/emacs/modus-themes-pictures">https://protesilaos.com/emacs/modus-themes-pictures</a></li>
  <li>Git repositories:
    <ul>
      <li>GitHub: <a href="https://github.com/protesilaos/modus-themes">https://github.com/protesilaos/modus-themes</a></li>
      <li>GitLab: <a href="https://gitlab.com/protesilaos/modus-themes">https://gitlab.com/protesilaos/modus-themes</a></li>
    </ul>
  </li>
  <li>Backronym: My Old Display Unexpectedly Sharpened … themes.</li>
</ul>

<h2>About the Ef themes</h2>

<p>The <code class="language-plaintext highlighter-rouge">ef-themes</code> are a collection of light and dark themes for GNU
Emacs that provide colourful (“pretty”) yet legible options for users
who want something with a bit more flair than the <code class="language-plaintext highlighter-rouge">modus-themes</code> (also
designed by me).</p>

<ul>
  <li>Package name (GNU ELPA): <code class="language-plaintext highlighter-rouge">ef-themes</code></li>
  <li>Official manual: <a href="https://protesilaos.com/emacs/ef-themes">https://protesilaos.com/emacs/ef-themes</a></li>
  <li>Change log: <a href="https://protesilaos.com/emacs/ef-themes-changelog">https://protesilaos.com/emacs/ef-themes-changelog</a></li>
  <li>Sample pictures: <a href="https://protesilaos.com/emacs/ef-themes-pictures">https://protesilaos.com/emacs/ef-themes-pictures</a></li>
  <li>Git repositories:
    <ul>
      <li>GitHub: <a href="https://github.com/protesilaos/ef-themes">https://github.com/protesilaos/ef-themes</a></li>
      <li>GitLab: <a href="https://gitlab.com/protesilaos/ef-themes">https://gitlab.com/protesilaos/ef-themes</a></li>
    </ul>
  </li>
  <li>Backronym: Eclectic Fashion in Themes Hides Exaggerated Markings,
Embellishments, and Sparkles.</li>
</ul>
        
      