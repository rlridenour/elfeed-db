<ul>
<li>Use nreverse and nconc to operate on lists in-place.</li>
<li>Set buffer local variables:</li>
</ul>
<pre><code class="language-{.commonlisp">(setq-local my-clever-var)
</code></pre>
<ul>
<li>Execute before saving buffer:</li>
</ul>
<pre><code class="language-{.commonlisp">(add-hook 'write-file-hooks
          (lambda ()
            (message &quot;about to save!&quot;)))
</code></pre>
<ul>
<li>Possibly use to start processes and send file content:</li>
</ul>
<pre><code class="language-{.commonlisp">(make-comint NAME PROGRAM &amp;optional STARTFILE &amp;rest SWITCHES)
</code></pre>
<ul>
<li>Creating markers:</li>
</ul>
<pre><code class="language-{.commonlisp">(setq my-marker (copy-marker (point)))
  #&lt;marker at 10251 in *ielm*&gt;

(marker-buffer my-marker)
  #&lt;buffer *ielm*&gt;

(marker-position my-marker)
  10251 (#o24013, #x280b, ?â ‹)
</code></pre>
<ul>
<li>Get org heading at point:</li>
</ul>
<pre><code class="language-{.commonlisp">(org-get-heading 'no-tags 'no-todo)
</code></pre>
<ul>
<li>Remove string text properties. From manual:</li>
</ul>
<blockquote>
<p>(substring-no-properties STRING &amp;optional FROM TO)</p>
<p>Return a substring of STRING, without text properties. It starts at index FROM and ends before TO. TO may be nil or omitted; then the substring runs to the end of STRING. If FROM is nil or omitted, the substring starts at the beginning of STRING. If FROM or TO is negative, it counts from the end.</p>
</blockquote>
<ul>
<li>Skip org entry metadata/drawers:</li>
</ul>
<pre><code class="language-{.commonlisp">(org-end-of-meta-data-and-drawers)
</code></pre>
<ul>
<li>Random access to org entry using id (or CUSTOM_ID):</li>
</ul>
<pre><code class="language-{.commonlisp">(org-open-link-from-string &quot;[[#%exciting-custom-id]]&quot;)
</code></pre>
<ul>
<li>From <a href="http://endlessparentheses.com/debugging-emacs-lisp-part-1-earn-your-independence.html">Debugging Elisp Part 1: Earn your independence</a>:</li>
</ul>
<blockquote>
<ul>
<li>Go to where the function is defined.</li>
<li>Press C-u C-M-x. Edebug breakpoint for function.</li>
<li>Invoke function in question.</li>
<li>n/c will get you around.</li>
<li>q when done.</li>
</ul>
</blockquote>
<ul>
<li>Pretty printing objects:</li>
</ul>
<pre><code class="language-{.commonlisp">(let ((my-var (list &quot;val1&quot;
                    &quot;val2&quot;
                    &quot;val3&quot;)))
  (pp-to-string my-var))
</code></pre>
<ul>
<li>Search and/or replace in curent buffer:</li>
</ul>
<pre><code class="language-{.commonlisp">(re-search-forward &quot;needle&quot;
                   nil t)
(match-beginning 0) ;; Start location of match from last search.
(match-end 0) ;; End location of match from last search.
(replace-match &quot;love&quot;)

;; needle-in-haystack
</code></pre>
<ul>
<li>Restrict buffer editing to a region:</li>
</ul>
<pre><code class="language-{.commonlisp">(narrow-to-region (point)
                  (point-max))
</code></pre>
<ul>
<li>Restore restriction:</li>
</ul>
<pre><code class="language-{.commonlisp">(save-restriction (narrow-to-region (point)
                                    (point-max))
</code></pre>
<ul>
<li>Restore point, mark, and current buffer:</li>
</ul>
<pre><code class="language-{.commonlisp">(save-excursion (goto-char (point-max))
                (insert &quot;Hello elisp.&quot;))
</code></pre>
<ul>
<li>Concatenating strings:</li>
</ul>
<pre><code class="language-{.commonlisp">(concat &quot;Hello &quot; &quot;elisp &quot; &quot;world.&quot;)
</code></pre>
<ul>
<li>Grabbing thing at point:</li>
</ul>
<pre><code class="language-{.commonlisp">(thing-at-point 'word)
(thing-at-point 'symbol)
(thing-at-point 'line)
</code></pre>
<ul>
<li>Unit test with ert.</li>
<li>Basic iteration with dolist:</li>
</ul>
<pre><code class="language-{.commonlisp">(dolist (v '(&quot;a&quot; &quot;b&quot; &quot;c&quot;))
  (print v))
</code></pre>
<ul>
<li>Output to other buffer:</li>
</ul>
<pre><code class="language-{.commonlisp">(with-current-buffer (get-buffer-create &quot;*some buffer*&quot;)
  (princ '(some list to print)
         (current-buffer)))
</code></pre>
<ul>
<li>For a temporary buffer, use with-temp-buffer:</li>
</ul>
<pre><code class="language-{.commonlisp">(with-temp-buffer
  (insert &quot;abc&quot;)
  (point))
</code></pre>
<ul>
<li>Cons cells <a href="http://emacslife.com/read-lisp-tweak-emacs/beginner-2-understand-emacs-lisp.html#sec-4-4">bookmark</a>.</li>
<li>Check for substring:</li>
</ul>
<pre><code class="language-{.commonlisp">(string-match-p REGEXP STRING &amp;optional START)
</code></pre>
<ul>
<li>Matching substrings and accessing groups:</li>
</ul>
<pre><code class="language-{.commonlisp">(setq haystack &quot;Always click [[http://reddit.com/r/emacs][here]].&quot;)
(setq needle-re &quot;\\[\\[\\(.*\\)]\\[\\(.*\\)]]&quot;)
  &quot;\\[\\[\\(.*\\)]\\[\\(.*\\)]]&quot;

(string-match needle-re haystack)
  13 (#o15, #xd, ?\C-m)

(match-string 0 haystack)
  &quot;[[http://reddit.com/r/emacs][here]]&quot;

(match-string 1 haystack)
  &quot;http://reddit.com/r/emacs&quot;

(match-string 2 haystack)
  &quot;here&quot;
</code></pre>
<ul>
<li>Return argument unchanged (noop):</li>
</ul>
<pre><code class="language-{.commonlisp">(identity ARG)
</code></pre>
<ul>
<li>Org insert today's timestamp</li>
</ul>
<pre><code class="language-{.commonlisp">(org-insert-time-stamp (current-time))
</code></pre>
<ul>
<li><a href="http://ergoemacs.org/emacs/elisp_determine_OS_version.html">OS version in .emacs</a>: Determine OS in emacs lisp.</li>
<li>First element</li>
</ul>
<pre><code class="language-{.commonlisp">(car LIST)
</code></pre>
<ul>
<li>All but first element</li>
</ul>
<pre><code class="language-{.commonlisp">(cdr LIST)
</code></pre>
<ul>
<li>Add NEWELT to front of PLACE</li>
</ul>
<pre><code class="language-{.commonlisp">(push NEWELT PLACE)
</code></pre>
<ul>
<li>Invoke 'FUNCTION for each in SEQUENCE</li>
</ul>
<pre><code class="language-{.commonlisp">(mapcar FUNCTION SEQUENCE)
</code></pre>
<ul>
<li>Search/replace</li>
</ul>
<pre><code class="language-{.commonlisp">(while (search-forward &quot;Hello&quot;)
  (replace-match &quot;Bonjour&quot;))
</code></pre>
<ul>
<li>Save to kill ring = copy.</li>
<li>Point = cursor position.</li>
<li>Mark = a buffer position.</li>
<li>Kill = cut text.</li>
<li>Yank = paste.</li>
<li>Buffer:File = 1:1.</li>
<li>Window:Buffer = 1:1.</li>
<li>Frame:Window = 1:many.</li>
<li>Font lock = syntax highlighting.</li>
</ul>
