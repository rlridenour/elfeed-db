<h2>cl-loop for in</h2>
<pre><code class="language-{.commonlisp">(cl-loop for day in '(&quot;mon&quot; &quot;tue&quot; &quot;wed&quot; &quot;thu&quot; &quot;fri&quot; &quot;sat&quot; &quot;sun&quot;)
         do (print day))
</code></pre>
<h2>cl-loop for from to</h2>
<pre><code class="language-{.commonlisp">(cl-loop for x from 1 to 5
         do (print x))
</code></pre>
<h2>pcase literal matching</h2>
<pre><code class="language-{.commonlisp">(pcase &quot;word&quot;
  ('word (message &quot;Matched 'word symbol&quot;))
  (&quot;word&quot; (message &quot;Matched \&quot;word\&quot; string&quot;)))
</code></pre>
<h2>Avoid nesting with the help of thread-first and thread-last.</h2>
<pre><code class="language-{.commonlisp">(thread-last &quot;12.....34&quot;
  (string-remove-prefix &quot;1&quot;)
  (string-remove-suffix &quot;4&quot;))
</code></pre>
<h2>Find file upwards, up parents, up hierarchy</h2>
<pre><code class="language-{.commonlisp">(locate-dominating-file FILE NAME)
</code></pre>
<h2>Find executable in PATH</h2>
<pre><code class="language-{.commonlisp">(executable-find COMMAND)
</code></pre>
<h2>Read string with completion (helm/ido/ivy friendly)</h2>
<pre><code class="language-{.commonlisp">(completing-read PROMPT COLLECTION &amp;optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HIST DEF INHERIT-INPUT-METHOD)
</code></pre>
<h2>Execute command/process and return list (similar to shell-command-to-string)</h2>
<pre><code class="language-{.commonlisp">(process-lines PROGRAM &amp;rest ARGS)
</code></pre>
<h2>Iterating org buffer</h2>
<pre><code class="language-{.commonlisp">(org-element-map (org-element-parse-buffer) '(headline link)
  (lambda (element)
    (cond
     ((and (eq (org-element-type element) 'headline)
           (= (org-element-property :level element) 1))
      (print &quot;headline&quot;))
     ((eq (org-element-type element) 'link)
      (print &quot;link&quot;)))
    nil))
</code></pre>
