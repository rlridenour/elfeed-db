<p>
<i>Published: [2025-07-01 Tue]. Comments <a href="https://mathstodon.xyz/@oantolin/114779994118160925">on Mastodon</a></i>.
</p>

<p>
This is the entry I would have written for the "Take Two"-themed Emacs
carnival if it had taken me less than a month to decide to
participate. It's about all the myriad minibuffer completion UIs I've
been through as an Emacs user, and is quite long because I've tried so
many!
</p>

<p>
Just to make sure we're on the same page: Emacs commands prompt for
user input in the minibuffer and offer <i>completion</i>, which means some
sort of assistance typing sensible inputs. There are many possible
user interfaces for this in Emacs and I've tried many but all of them
(By the way, this is a constant in my Emacs usage: I try many but not
all of the options, since there are always too many. For example, of
the built-in ways to list buffers I've used <code>switch-to-buffer</code>, <code>ibuffer</code>,
<code>electric-buffer-list</code> and several third party options ―I currently
use <code>consult-buffer</code> from the Consult package― but I've never tried
the built-in <code>bs-show</code>, for example. Similarly, of the built-ins I've
only used GNUS to read email and RSS feeds, but never tried Rmail for
email or NewsTicker for RSS; let alone trying all third party options
―I did use mu4e for email for a bit and elfeed for RSS feeds!)
</p>

<p>
Just so this doesn't take forever to write, I will write it all from
memory, and let people correct me on details I get wrong ―it's only
fair since I do that to other people all the freaking time (it's a
wonder I have any friends). This list attempts to be in chronological
order of my usage, but I'm sure I'm getting some of this slightly
wrong (and fortunately no-one is likely to be able to call me out
about errors in the ordering of my personal usage of these UIs).
</p>
<div id="outline-container-org29ab806" class="outline-3">
<h3 id="org29ab806">Default completion</h3>
<div class="outline-text-3" id="text-org29ab806">
<p>
In my early days as an Emacs user I simply used the default completion
UI. This UI doesn&rsquo;t not show the completion candidates all the time.
If all the candidates have the next bit of text in common, pressing
TAB inserts it into the minibuffer (people call this TAB completion).
I&rsquo;ve always found this funny since it makes <b>zero</b> progress towards
choosing a single completion candidate: it only inserts as much text
as will <b>not</b> narrow down things at all! But people like it for some
reason, I guess as visual feedback that what you thought the
completion candidates had in common they really do have in common. (To
be fair you can configure <code>completion-cycle-threshold</code> to have TAB cycle
among candidates when there aren&rsquo;t many left.)
</p>

<p>
Pressing TAB a second time will pop up the <code>*Completions*</code> buffer, which
shows a list of all completion candidates. From there you can click on
a candidates, navigate to it and press RET, or just type some more and
press TAB again to get an updated candidate list.
</p>

<p>
Don&rsquo;t knock the default completion UI. It is functional, powerful and
perfectly usable out of the box. But most people want to see how the
available candidates change automatically as you type. The other UIs I
tried all have that feature in common; they also all have a notion of
the &ldquo;current completion candidate&rdquo;, and there is a way to select that
current candidate without finishing typing it ―usually but not
always this done simply by pressing RET.
</p>
</div>
</div>
<div id="outline-container-orga3a255f" class="outline-3">
<h3 id="orga3a255f">Ido</h3>
<div class="outline-text-3" id="text-orga3a255f">
<p>
Ido also comes with Emacs and is pretty funky. For one thing it
doesn&rsquo;t take over all minibuffer completion services, it only provides
special versions of certain commands, mainly to open files and switch
buffers. Those commands also enable some additional key bindings while
you are using the commands: while opening a file you can press a key
to delete a file, or while switching buffers you can press a key to
kill a buffer. This sort of thing is called &ldquo;acting on a completion
candidate&rdquo;, and <a href="https://github.com/oantolin/embark">boy do I like it</a> ―more about this later. Ido uses
fuzzy completion, where characters only have to appear in order in a
completion candidate, not necessarily consecutively; for example <code>epnf</code>
matches <code>eww-open-file</code>.
</p>

<p>
If you like Ido but want to use it for all minibuffer completion there
are some options: there&rsquo;s the <a href="https://github.com/DarwinAwardWinner/ido-completing-read-plus">ido-completing-read+</a> package and the
built-in <code>fido-mode</code>. I don&rsquo;t particularly like fuzzy matching since it
feels inefficient to me, there are always two many matches for my
taste.
</p>
</div>
</div>
<div id="outline-container-org47b036f" class="outline-3">
<h3 id="org47b036f">Helm</h3>
<div class="outline-text-3" id="text-org47b036f">
<p>
Helm is a comprehensive package that not only takes over all
minibuffer completion duties but comes with many commands that take
advantage of Helm&rsquo;s additional features. It&rsquo;s big and brash and
opinionated. I used it for many months and was quite happy with it. I
particularly liked that the Helm commands came with many actions you
could perform on the completion candidates. I didn&rsquo;t much like its
default aesthetics or its long load time (although since you only
incur that once per session it doesn&rsquo;t really matter). One thing I
didn&rsquo;t like much is that somehow it didn&rsquo;t seem to blend in very well
with the rest of my Emacs experience. For example, only commands
written specially to use Helm had actions for the completion
candidates, and the actions had to be implemented in a particular way,
you couldn&rsquo;t use any old Emacs command as an action. But all in all
Helm is great, an impressive piece of software that sprouted its own
mini-ecosystem of related packages.
</p>
</div>
</div>
<div id="outline-container-orgb9be6bd" class="outline-3">
<h3 id="orgb9be6bd">Ivy</h3>
<div class="outline-text-3" id="text-orgb9be6bd">
<p>
After Helm I used Ivy and its companion Swiper and Counsel packages
for a while. It felt pretty similar to using Helm to me, except I
liked the default look of it better (which is not to say you couldn&rsquo;t
easily configure the visual aspects of Helm). It also had a notion of
actions, but similarly to Helm, you needed to write them specially for
each command. I think it was less batteries-included than Helm, for
example I have a vague recollection of <code>counsel-find-file</code>, its
substitute for <code>find-file</code>, not coming with actions to rename or copy
files, which I wrote in my own configuration. It&rsquo;s then that it
started to bother me that I couldn&rsquo;t simply say &ldquo;I want the Emacs
commands <code>rename-file</code> and <code>copy-file</code> as actions&rdquo;, I was forced to write
little wrappers for them. Like Helm, I think the Ivy/Swiper/Counsel
family is great software and was a happy user. I did however, as I did
with Helm, that it reinvented the wheel too much and that something
like it would be possible that took more advantage of existing Emacs
APIs and functions.
</p>
</div>
</div>
<div id="outline-container-org86fc519" class="outline-3">
<h3 id="org86fc519">Icomplete</h3>
<div class="outline-text-3" id="text-org86fc519">
<p>
This is another built-in option, which I think I only started using
after having used Helm and Ivy. I used it for a quite a while and
still think it is perfectly workable. One thing I like about it is
that, like the default completion UI, it only concerns itself with
displaying the completion candidates and leaves the important matter
of which candidates are considered to match the minibuffer input to
the current <i>completion styles</i>. There is no formal notion in Emacs of a
&ldquo;well-behaved&rdquo; completion UI, but in my head certainly such a UI
should limit itself to showing you the candidates and leave the user
to configure completion styles separately. This what I dislike about
<code>fido-mode</code>: it ignores your completion style configuration and makes
you use the <code>flex</code> completion style instead (you can change this but it
requires being sneaky, not simply setting <code>completion-styles</code>).
</p>

<p>
One difference between Icomplete and Helm or Ivy, is that it displays
the completion candidates in a compact horizontal list like Ido,
instead of one per line, like Helm or Ivy. When I was an Icomplete
user, I even wrote a package called <a href="https://github.com/oantolin/icomplete-vertical">icomplete-vertical</a> that would
configure Icomplete to display the candidates vertically, one per
line. Nowadays there is also a built-in package of the same name which
I did not write, nor does it use my code. I remember thinking the
built-in package had a bug mine lacked, triggered when you switched
from horizontal to vertical during a minibuffer completion session,
but I couldn&rsquo;t reproduce it now so either they fixed it, or I couldn&rsquo;t
remember exactly what the bug was, or my memory is playing tricks on
me.
</p>
</div>
</div>
<div id="outline-container-org9c4adfc" class="outline-3">
<h3 id="org9c4adfc">live-completions</h3>
<div class="outline-text-3" id="text-org9c4adfc">
<p>
The mention of icomplete-vertical above is the start of an
embarrassing parade of completion UIs I wrote myself, for myself and
which I don&rsquo;t think more than a handful people ever used. What marred
all of my feeble attempts, other than icomplete-vertical which is just
some configuration code on top of icomplete, was a distinct lack of
speed. The idea of these incremental, automatic completion UIs is to
show you how the candidate list changes in real time, but most of mine
struggled to do this fast enough.
</p>

<p>
My <a href="https://github.com/oantolin/live-completions">live-completions</a> package had a very simple idea: pop up the
<code>*Completions*</code> buffer that the default UI uses and just update it after
every key press. It let you format the completions in either a grid or
a single column, back before the default UI had the single column
view.
</p>

<p>
I think I used this for quite a while though it wasn&rsquo;t very good. I
believe that by the time I wrote this, I already had an initial
version of Embark that took care of acting on completion candidates
solving all of the complaints I had about actions in Ido, Helm or Ivy:
Embark lets you use any Emacs command directly as an action, there is
no need to write wrappers over existing commands; it endows every
single command that has a minibuffer prompt with actions on its
candidates, commands do not have to be written specially with Embark
in mind to acquire actions.
</p>
</div>
</div>
<div id="outline-container-orga50d338" class="outline-3">
<h3 id="orga50d338">grille</h3>
<div class="outline-text-3" id="text-orga50d338">
<p>
Another bad completion UI I wrote. Hey, <a href="https://github.com/oantolin/emacs-config/blob/master/experiments/grille.el">at least it&rsquo;s small</a>. I don&rsquo;t
think I used this for very long, maybe a couple of weeks. It&rsquo;s called
grille because it displays completions in a grid. I have nothing  else
to say about it.
</p>
</div>
</div>
<div id="outline-container-orgc5d7360" class="outline-3">
<h3 id="orgc5d7360">embark-completions</h3>
<div class="outline-text-3" id="text-orgc5d7360">
<p>
For a while Embark included its own completions UI! This is obviously
a bad idea, which I only did because it was easy, since Embark had
grown to have almost all the components necessary for this. It was
slow, but other than that I found it surprisingly good. It was
certainly featureful: it displayed the completions either one per line
or in a grid, the grid optionally with zebra stripes to guide the eye.
I stubbornly kept using it until I dropped it for Vertico and finally
removed it from Embark.
</p>
</div>
</div>
<div id="outline-container-orgf55462d" class="outline-3">
<h3 id="orgf55462d">Vertico</h3>
<div class="outline-text-3" id="text-orgf55462d">
<p>
The excellent Vertico package is what I use now as a completion UI.
The author, Daniel Mendler, and I have long worked together on a suite
of packages that provide a full completion experience for Emacs. I
wanted to switch from embark-completions to Vertico but held out until
Daniel added a grid display to Vertico. In retrospect this was silly
on my part, but I believe my stubbornness might have helped motivate
Daniel to add the grid feature. Of this suite of packages, Daniel
wrote Vertico, Corfu, Cape; I wrote Embark and Orderless (the latter
of which we now co-maintain); and we wrote Marginalia together after
noticing we were both writing something like it.
</p>

<dl class="org-dl">
<dt>Vertico</dt><dd>a highly flexible completion UI, that can display
completions one per line or in a grid, in the minibuffer or in a
dedicated buffer.</dd>
<dt>Orderless</dt><dd>a highly configurable completion style, whose main
feature is matching space-separated bits of the input in any order
against the completion candidates; so <code>op eww</code> matches <code>eww-open-file</code>.</dd>
<dt>Embark</dt><dd>lets you use any Emacs command as an action on any
minibuffer completion candidate or on a thing at point in a non-mini
buffer; it also comes with an extensive default configuration
assigning convenient keybindings to the most commonly used actions
(but you can always <code>M-x</code> to use whatever command you want as an
action!)</dd>
<dt>Marginalia</dt><dd>provides extra information about completion candidates
of common types, most completion UIs that display candidates as one
per line will shows this extra information to the right of the candidate.</dd>
<dt>Corfu</dt><dd>this is a completion UI for completion-at-point, which I
haven&rsquo;t talked about here at all ―it is the type of completion
that you get when writing code in a buffer, for example. Again here
I stubbornly held out a long time using my own contraption
(<code>consult-completion-in-region</code>, which I contributed to consult).</dd>
<dt>Cape</dt><dd>a suite of completion-at-point functions; again I stubbornly
held out using an embark-based substitute for this for a long time
―I&rsquo;m starting to notice an unflattering pattern.</dd>
</dl>
</div>
</div>
<div id="outline-container-org57be204" class="outline-3">
<h3 id="org57be204">Selectrum and MCT</h3>
<div class="outline-text-3" id="text-org57be204">
<p>
I already finished listing the completion UIs that I actually used for
a period of time, but there are a couple of others I tried and
probably some I did not try (maybe <a href="https://github.com/manateelazycat/snails">snails</a>, though I&rsquo;m not exactly sure
what it is, since I&rsquo;ve only every briefly skimmed its README). I tried
Selectrum once and, to my discredit, only complained about some minor
issues with it on reddit. At least I&rsquo;m focused thematically in my
complaints: I thought it wasn&rsquo;t Emacsy enough, that it disrespected
some Emacs variables it could easily respect. Well, that, and there
something I didn&rsquo;t like about its <code>completing-read-multiple</code> experience
(I think it was that you couldn&rsquo;t easily see what you had already
selected). I never used Prot&rsquo;s MCT package extensively, but I would
call it similar in idea to my live-completions package, and would hope
Prot does not disagree with this characterization. It somehow seemed
smoother than my live-completions, probably because Prot had more
patience tweaking the experience than I did.
</p>
</div>
</div>
