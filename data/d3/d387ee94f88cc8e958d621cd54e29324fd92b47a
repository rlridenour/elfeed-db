<p>Well this is quite a turn up for the books, I seem to have already quickly moved on from emacs <strong>ripgrep-regexp</strong>!  to something better and that is a package called <strong>deadgrep</strong></p>
<figure class="emacs-img"><img src="https://emacs.dyerdwelling.family/ox-hugo/20221207210603-emacs--RIP-ripgrep-regexp-Long-Live-DeadGrep.jpg">
</figure>

<p>Now why is this?  I hear you all ask, your new grepping workflow seemed perfect, a process of file searching that could last the ages. Well as it turns out that age was more of a collection of weeks.</p>
<p>I started to struggle with the compilation-mode output of <strong>ripgrep-regexp</strong> in that a next-error call would only take me to the requisite file if I entered a directory name.  I just wanted to spam F8/next-error my way through all resulted grepped files so I could get a general sense of which files contained my search as I don&rsquo;t always know what I am looking for.  The constant calling up of the directory to input was seriously disrupting my workflow and after some investigation I was struggling to find a way to resolve this.</p>
<p>The main issue seemed to be <strong>compilation-mode</strong></p>
<p><strong>compilation-mode</strong> seems to depend on <strong>compilation-search-path</strong> to locate a file automatically in a buffer.  This I suspect is generally ok when compilation-mode is tied into a build project as this path is built up automatically, for example building Ada files typically will parse a gpr file to construct search directories.  Maybe projectile or project.el could help me resolve this, but as mentioned in previous posts currently a project concept doesn&rsquo;t yet fit into my workflow.</p>
<p>Well I guess I could create a list of search directories and add it to the <strong>compilation-search-path</strong>, something like :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elisp" data-lang="elisp"><span style="display:flex;"><span>(setq my-search-directories (<span style="color:#a6e22e">append</span> <span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;-/bin&#34;</span> <span style="color:#e6db74">&#34;-/test&#34;</span>) <span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;-/content&#34;</span> <span style="color:#e6db74">&#34;~/content/hugo&#34;</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(setq compilation-search-path my-search-directories)
</span></span></code></pre></div><p>but this isn&rsquo;t really very flexible, I would have to keep modifying this search directory list as my disk directory hierarchy evolves.</p>
<p>What I need then is an emacs package that doesn&rsquo;t rely on compilation-mode for its output and will just leverage the ripgrep output to directly locate files.</p>
<p>This is where I found <strong>deadgrep</strong> and in fact the package text immediately applied half a pot of emollient to the skin of my current rash of irritations :</p>
<blockquote>
<p>Perform text searches with the speed of ripgrep and the comfort of Emacs. This is a bespoke mode that does not rely on compilation-mode, but tries to be a perfect fit for ripgrep.</p>
</blockquote>
<p>The out of the box behavior is to search for an input string entered in the minibuffer for all occurrences from the current directory. The output is a ripgrep output grouping grep finds together file by file.</p>
<p>Some options appear on the top of the output buffer to provide some quick configuration ripgrep options, such as:</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">Search term: &lt;search string input&gt; change
Search type: string words regexp
Case: smart sensitive ignore

Directory: &lt;search directory&gt;
Files: all type glob
</code></pre><p>and all the occurrences of the search string are highlighted.</p>
<p>So the next step (pun intended) is to step through these results and see if they open a window/buffer for each search result.</p>
<p>F8/next-error does the trick!, so a continual F8 opens the relevant grepped file result in a window/buffer and without the need to confirm a directory.</p>
<p>So out of the box deadgrep seems to work perfectly for me, it is lightning fast (well I guess it would be). I can step through the results quickly, it respects my <strong>.ignore</strong> file and as a bonus allows a quick changing of ripgrep configuration options!, what more could an emacs user want?!  (don&rsquo;t answer that!)</p>