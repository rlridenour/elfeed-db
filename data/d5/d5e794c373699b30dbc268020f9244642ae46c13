<p>I recently wrote an <a href="/blog/2025/02/03/debugging-emacs-commands/">article on debugging Emacs commands</a>.
In it I mentioned <code class="language-plaintext highlighter-rouge">M-x toggle-debug-on-error</code> and <code class="language-plaintext highlighter-rouge">debug-on-error</code> briefly, but after posting the
article I realized that many people probably don’t understand how
this works exactly.</p>

<p>The obvious thing that happens when <code class="language-plaintext highlighter-rouge">debug-on-error</code> is
enabled is that when an error happen you’re seeing its backtrace (or stacktrace, depending on the terminology you prefer).
What’s not so obvious (even, if it’s in the name) is that this buffer is
actually a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Debugger.html">debugger</a> buffer and you can do a lot with it. Here are a few examples:</p>

<ol>
  <li><strong>Navigate the Stack Trace</strong>: Move your cursor in the <code class="language-plaintext highlighter-rouge">*Backtrace*</code> buffer to different lines representing various stack frames.</li>
  <li><strong>Examine Local Variables</strong>: Press <code class="language-plaintext highlighter-rouge">v</code> (<code class="language-plaintext highlighter-rouge">debugger-toggle-locals</code>) while on a stack frame to display local variables for that frame.</li>
  <li><strong>Evaluate Expressions</strong>: Use <code class="language-plaintext highlighter-rouge">e</code> (<code class="language-plaintext highlighter-rouge">debugger-eval-expression</code>) to evaluate Lisp expressions in the context of the current frame.</li>
  <li><strong>Step Through Code</strong>: Use <code class="language-plaintext highlighter-rouge">d</code> to step into function calls and evaluate expressions one by one.</li>
  <li><strong>Continue Execution</strong>: Press <code class="language-plaintext highlighter-rouge">c</code> to continue normal execution. (note, that unless you change something, this will result in the error you’re trying to debug)</li>
  <li><strong>Quit Debugging</strong>: Enter <code class="language-plaintext highlighter-rouge">q</code> to exit the debugger and abort the current command.</li>
  <li><strong>View Help</strong>: Type <code class="language-plaintext highlighter-rouge">?</code> to see a list of available debugger commands.</li>
  <li><strong>Record Evaluations</strong>: Use <code class="language-plaintext highlighter-rouge">E</code> to evaluate an expression and save the result in the <em>Debugger-record</em> buffer.</li>
</ol>

<p>It’s important to understand that debugger runs in the environment of the error, allowing you to examine variable values precisely as they were at the time of the error.
This makes it a powerful tool for understanding and fixing issues in your Emacs Lisp code.</p>

<p>That debugging experience is one of the most powerful features of Lisps in general, and it’s one of the reasons
why developing and debugging Emacs packages is pretty pleasant and productive experience. Provided you’re
familiar with how to use the debugger in such cases that it.</p>

<p>You can more help inside Emacs by pressing <code class="language-plaintext highlighter-rouge">C-h m</code> while in a debugger buffer.</p>

<p>So, to recap - in case you run into some errors you should run the command <code class="language-plaintext highlighter-rouge">M-x toggle-debug-on-error</code>, re-run
whatever action caused the error and then navigate the stacktrace in the debugger to figure out what went wrong
exactly.</p>

<p>To debug an error that happens during loading of the init file, use the option
<code class="language-plaintext highlighter-rouge">--debug-init</code>. This binds <code class="language-plaintext highlighter-rouge">debug-on-error</code> to <code class="language-plaintext highlighter-rouge">t</code> while loading the init file, and
bypasses the <code class="language-plaintext highlighter-rouge">condition-case</code> which normally catches errors in the init file.</p>

<p>That’s all I have for you today. I hope you’ve learned something useful today and next time you run into some error you’ll be able to
fix it in no time!</p>