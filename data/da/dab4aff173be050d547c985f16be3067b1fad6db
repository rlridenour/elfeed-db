<p>We&rsquo;ve all been there, your code was working perfectly from a clean checkout, but after making a bunch of changes across multiple files, something has broken. The dreaded question arises! which change caused the break? This is the story of how a debugging session led me to discover gaps in Emacs&rsquo; VC mode and ultimately create a custom solution.</p>
<figure><img src="https://emacs.dyerdwelling.family/ox-hugo/20250826103741-emacs--Debugging-Software-Breakage-with-Git-Stash-and-Emacs.jpg" width="100%">
</figure>

<p>I started with a clean, working codebase. After implementing several features across different files, my software suddenly stopped working. The classic debugging nightmare, multiple changes, one (or more) breaking changes, and no clear path to the culprit.</p>
<p>My debugging strategy as always is methodical. Over many years of software engineering I have learnt that you just need to figure out a systematic approach and then just get on with it!</p>
<ol>
<li>Start from the known-good base version</li>
<li>Gradually reintroduce changes from my working set</li>
<li>Test after each addition to identify the breaking point</li>
</ol>
<p>Git stash turned out to be perfect for this workflow. Firstly I stashed all my changes, giving me a clean working directory to start from. My plan was to selectively apply portions of the stash, testing after each addition.</p>
<p>Using Emacs&rsquo; built-in VC mode, I could use <code>vc-git-stash-show</code> to display my stashed changes in a diff buffer. From there, I could navigate through the files and selectively apply hunks using Emacs&rsquo; diff mode commands. This gave me fine-grained control over which changes to reintroduce.</p>
<p>As I progressed through applying changes, I realised that I would really like to keep an eye on what changes remained in my stash compared to my current working directory, basically like a dynamic diff to be regenerated after each application (like typically on an individual file using ediff). This would allow me to keep an eye on likely culprits as I move through the hunking process.</p>
<p>In pure Git, this is straightforward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git diff stash@<span style="color:#f92672">{</span>0<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>But Emacs&rsquo; VC mode doesn&rsquo;t provide a command for this specific operation (I have found this not to be uncommon for Emacs vc-mode, but I still like it anyways!)</p>
<p>Generally I think, Emacs&rsquo; VC interface is designed to be VCS agnostic, which is both a strength and a limitation. While it provides excellent abstractions for common operations like <code>vc-diff</code>, it doesn&rsquo;t expose Git specific features like comparing against stash references.</p>
<p>The available VC commands were:</p>
<ul>
<li><code>vc-diff</code> - compares working directory with HEAD or between revisions</li>
<li><code>vc-git-stash-show</code> - shows the diff of a stash</li>
</ul>
<p>But no &ldquo;diff working directory against stash&rdquo; command</p>
<p>Now, it&rsquo;s worth noting that Magit, does apparently provide this functionality, but I prefer to run on air-gapped systems (yes, that again!) where installing external packages isn&rsquo;t always practical or desired. In such environments, I lean heavily on Emacs&rsquo; built-in functionality and augment it with custom elisp when needed which is probably something I suspect I am likely to do in this case.</p>
<p>I had an initial eshell idea on how to accomplish this!, for example you can redirect command line output to Emacs buffers using the <code>#&lt;buffer name&gt;</code> syntax, so lets try that!</p>
<p>I tried:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git diff stash@<span style="color:#f92672">{</span>0<span style="color:#f92672">}</span> &gt; <span style="color:#75715e">#&lt;buffer *git-diff*&gt; &amp;&amp; diff-mode</span>
</span></span></code></pre></div><p>This almost worked, but I encountered a timer error related to eshell&rsquo;s command chaining.</p>
<p>and then I tried:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git diff stash@<span style="color:#f92672">{</span>0<span style="color:#f92672">}</span> &gt; <span style="color:#75715e">#&lt;buffer *git-stash-diff*&gt; ; diff-mode</span>
</span></span></code></pre></div><p>After some experimentation, I still couldn&rsquo;t quite get eshell to generate a buffer from a command and then initiate a mode.  Of course I could just jump to the buffer and run it myself, but generally I wanted a solution to be easily repeatable.</p>
<p>Right, lets scrap the eshell idea and lets fall back on my tried and tested method of writing a defun in elisp!:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elisp" data-lang="elisp"><span style="display:flex;"><span>(defun my-git-diff-stash (stash-ref)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Diff working directory against specified stash&#34;</span>
</span></span><span style="display:flex;"><span>  (interactive <span style="color:#e6db74">&#34;sStash reference (e.g., 0, 1, 2): &#34;</span>)
</span></span><span style="display:flex;"><span>  (let ((buffer (<span style="color:#a6e22e">get-buffer-create</span> <span style="color:#e6db74">&#34;*git-stash-diff*&#34;</span>)))
</span></span><span style="display:flex;"><span>    (with-current-buffer buffer
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">erase-buffer</span>)
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">call-process</span> <span style="color:#e6db74">&#34;git&#34;</span> <span style="color:#66d9ef">nil</span> buffer <span style="color:#66d9ef">t</span> <span style="color:#e6db74">&#34;diff&#34;</span> (<span style="color:#a6e22e">format</span> <span style="color:#e6db74">&#34;stash@{%s}&#34;</span> stash-ref))
</span></span><span style="display:flex;"><span>      (diff-mode)
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">goto-char</span> (<span style="color:#a6e22e">point-min</span>)))
</span></span><span style="display:flex;"><span>    (switch-to-buffer buffer)))
</span></span></code></pre></div><p>This function:</p>
<ul>
<li>Prompts for a stash reference (defaulting to numeric input like 0, 1, 2)</li>
<li>Creates a dedicated buffer for the diff</li>
<li>Runs <code>git diff</code> against the specified stash</li>
<li>Automatically applies <code>diff-mode</code> for syntax highlighting</li>
<li>Opens the buffer and positions the cursor at the beginning</li>
</ul>
<p>The final step was to bind this command to the VC prefix map:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elisp" data-lang="elisp"><span style="display:flex;"><span>(<span style="color:#a6e22e">define-key</span> vc-prefix-map (kbd <span style="color:#e6db74">&#34;S&#34;</span>) <span style="color:#e6db74">&#39;my-git-diff-stash</span>)
</span></span></code></pre></div><p>&ldquo;S&rdquo; is currently used for a regex search of some kind which I currently don&rsquo;t understand and hence am not using.</p>
<p>Now I can use <code>C-x v S</code> to quickly diff my working directory against any stash (although who knows when I will need this again!)</p>
<p>With this in place, my debugging workflow became smoother</p>
<ol>
<li>Stash all changes</li>
<li>Apply changes incrementally using <code>vc-git-stash-show</code></li>
<li>Test the software after each addition</li>
<li>When it still works, check what remains <code>C-x v S</code></li>
<li>Continue applying changes from the remaining diff</li>
<li>When it breaks, I have a good idea of the breaking issue</li>
</ol>
<p>This experience taught me several valuable lessons:</p>
<ol>
<li>
<p><strong>VC mode&rsquo;s limitations</strong>: While Emacs&rsquo; VC interface is excellent for common operations, specialized Git workflows sometimes require custom solutions.</p>
</li>
<li>
<p><strong>The value of built-in solutions</strong>: Working in air-gapped environments has taught me to maximize Emacs&rsquo; built-in capabilities before reaching for external packages. While Magit would have solved this problem out of the box, building the solution myself using VC mode and custom elisp keeps dependencies minimal and increases my understanding of both Git and Emacs internals.</p>
</li>
<li>
<p><strong>Eshell&rsquo;s power</strong>: The ability to redirect command output directly to Emacs buffers is incredibly useful, even if it has some quirks with command chaining and in the end I never really got it to work, but it is in my brain more concretely now as this blog post now exists!</p>
</li>
<li>
<p><strong>Integration matters</strong>: Binding custom functions to standard keymaps makes them feel like native features.</p>
</li>
</ol>