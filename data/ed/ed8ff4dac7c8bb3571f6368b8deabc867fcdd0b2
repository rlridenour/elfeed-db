<p>In addition to including user content, <a href="https://journelly.com/">Journelly</a> entries typically bundle a few extra details like timestamp, location, and weather information, which look a little something like this:</p>
<p><img src="https://xenodium.github.io/images/a-richer-journelly-org-capture-template/rice-guys.jpg" alt=""></p>
<p>Behind the scenes, Journelly entries follow a fairly simple org structure:</p>
<pre><code class="language-org">* [2025-04-23 Wed 13:24] @ Waterside House
:PROPERTIES:
:LATITUDE: 51.518714352892665
:LONGITUDE: -0.17575820941499262
:WEATHER_TEMPERATURE: 11.4¬∞C
:WEATHER_CONDITION: Mostly Cloudy
:WEATHER_SYMBOL: cloud
:END:
Try out Rice Guys #food #london on Wednesdays in Paddington

[[file:Journelly.org.assets/images/C5890C25-5575-4F52-80D9-CE0087E9986C.jpg]]
</code></pre>
<p>While out and capturing entries from my iPhone, I rely on Journelly to leverages iOS location and weather APIs to include relevant information. On the other hand, when capturing from my Macbook, I rely on a basic Emacs org capture template (very similar to <a href="https://baty.net/posts/2025/04/journelly-org-mode-backed-journaling-for-i-os/">Jack Baty's</a>):</p>
<pre><code class="language-{.commonlisp">(setq org-capture-templates
      '((&quot;j&quot; &quot;Journelly&quot; entry (file &quot;path/to/Journelly.org&quot;)
         &quot;* %U @ Home\n%?&quot; :prepend t)))
</code></pre>
<p>These templates yield straightforward entries like:</p>
<pre><code class="language-org">* [2025-05-16 Fri 12:42] @ Home
A simple entry from my Macbook.
</code></pre>
<p>I've been using this capture template for some time. It does a fine job, though you'd notice location and weather info aren't captured. No biggie, since the location of my laptop isn't typically relevant, but hey today seemed like a perfect day to get <a href="https://xkcd.com/356/">nerd snipped</a> by <a href="https://bsky.app/profile/natharari.bsky.social/post/3lpbkzcduo223">@natharari</a>.</p>
<p>And so, off I went, to look for a utility to capture location from the command line. I found <a href="https://github.com/fulldecent/corelocationcli">CoreLocationCLI</a>, which leverages the equivalent macOS location APIs. As a bonus, the project seemed active (modified only a few days ago).</p>
<p>Installing CoreLocationCLI via <a href="https://brew.sh/">Homebrew</a> was a breeze:</p>
<pre><code class="language-{.bash">brew install corelocationcli
</code></pre>
<p>The first time you run corelocationcli, you'll get an message like:</p>
<pre><code>&quot;CoreLocationCLI&quot; can't be opened because it is from an unidentified developer...
</code></pre>
<p>You'll need to follow <a href="https://github.com/fulldecent/corelocationcli">CoreLocationCLI</a>'s instructions:</p>
<pre><code>To approve the process and allow CoreLocationCLI to run, go to System Settings ‚û°Ô∏è Privacy &amp; Security ‚û°Ô∏è General, and look in the bottom right corner for a button to click.
</code></pre>
<p>After approving the process, I ran into a snag:</p>
<pre><code class="language-{.bash">$ CoreLocationCLI
CoreLocationCLI: ‚ùå The operation couldn‚Äôt be completed. (kCLErrorDomain error 0.)
</code></pre>
<p>Lucky for me, the <a href="https://github.com/fulldecent/corelocationcli">README</a> had the solution:</p>
<pre><code class="language-{.bash">Note for Mac users: make sure Wi-Fi is turned on. Otherwise you will see kCLErrorDomain error 0.
</code></pre>
<p>Oddly, my WiFi was turned on, so I went ahead and toggled it. Success:</p>
<pre><code class="language-{.bash">$ CoreLocationCLI
51.51871 -0.17575
</code></pre>
<p>We can start by wrapping this command-line utility to return coordinates along with reverse geolocation (ie. description):</p>
<pre><code class="language-{.commonlisp">(defun journelly-get-location ()
  &quot;Get current location.

Return in the form:

`((lat . 51.51871)
  (lon . -0.17575)
  (description . \&quot;Sunny House\&quot;))

Signals an error if the location cannot be retrieved.&quot;
  (unless (executable-find &quot;CoreLocationCLI&quot;)
    (error &quot;Needs CoreLocationCLI (try brew install corelocationcli)&quot;))
  (with-temp-buffer
    (if-let ((exit-code (call-process &quot;CoreLocationCLI&quot; nil t nil
                                      &quot;--format&quot; &quot;%latitude\t%longitude\t%thoroughfare&quot;))
             (success (eq exit-code 0))
             (parts (split-string (buffer-string) &quot;\t&quot;)))
        `((lat . ,(string-to-number (nth 0 parts)))
          (lon . ,(string-to-number (nth 1 parts)))
          (description . ,(string-trim (nth 2 parts))))
      (error &quot;No location available&quot;))))
</code></pre>
<p>A quick check shows it's working as expected.</p>
<pre><code class="language-{.commonlisp">(journelly-get-location)
</code></pre>
<pre><code class="language-{.commonlisp">'((lat . 51.51871)
  (lon . -0.17575)
  (description . &quot;Waterside House&quot;))
</code></pre>
<p>Now that we're able to get the current location, we need a way to fetch weather info. I discarded using WeatherKit on macOS for its dependence on a developer account and obtaining an API key. No worries, I found the great <a href="https://api.met.no/">MET Norway API</a> which is freely available without the need for keys.</p>
<pre><code class="language-{.commonlisp">(defun journelly-fetch-weather (lat lon)
  &quot;Fetch weather data from MET Norway API for LAT and LON.

Return the parsed JSON object.&quot;
  (let* ((url (format &quot;https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=%s&amp;lon=%s&quot; lat lon))
         (args (list &quot;-s&quot; url)))
    (with-temp-buffer
      (apply #'call-process &quot;curl&quot; nil t nil args)
      (goto-char (point-min))
      (json-parse-buffer :object-type 'alist))))
</code></pre>
<p>We can take it for a spin with:</p>
<pre><code class="language-{.commonlisp">(journelly-fetch-weather 51.51871 -0.17575)
</code></pre>
<p>We get a nice object with a chunky time series (cropped for readability):</p>
<pre><code class="language-{.commonlisp">((type . &quot;Feature&quot;)
 (geometry (type . &quot;Point&quot;) (coordinates . [-0.1758 51.5187 30]))
 (properties
  (meta (updated_at . &quot;2025-05-16T11:17:44Z&quot;)
        (units (air_pressure_at_sea_level . &quot;hPa&quot;)
               (air_temperature . &quot;celsius&quot;)
               (cloud_area_fraction . &quot;%&quot;)
               (precipitation_amount . &quot;mm&quot;) (relative_humidity . &quot;%&quot;)
               (wind_from_direction . &quot;degrees&quot;) (wind_speed . &quot;m/s&quot;)))
  (timeseries
   . [((time . &quot;2025-05-16T12:00:00Z&quot;)
       (data
        (instant
         (details (air_pressure_at_sea_level . 1025.6)
                  (air_temperature . 18.0) (cloud_area_fraction . 4.7)
                  (relative_humidity . 44.2)
                  (wind_from_direction . 17.6) (wind_speed . 3.6)))
        (next_12_hours (summary (symbol_code . &quot;fair_day&quot;)) (details))
        (next_1_hours (summary (symbol_code . &quot;clearsky_day&quot;))
                      (details (precipitation_amount . 0.0)))
        (next_6_hours (summary (symbol_code . &quot;clearsky_day&quot;))
                      (details (precipitation_amount . 0.0)))))

      ...


     ((time . &quot;2025-05-26T00:00:00Z&quot;)
       (data
        (instant
         (details (air_pressure_at_sea_level . 1007.3)
                  (air_temperature . 12.6)
                  (cloud_area_fraction . 28.1)
                  (relative_humidity . 91.3)
                  (wind_from_direction . 258.7) (wind_speed . 3.5)))))])))

</code></pre>
<p>Journelly entries need only a tiny subset of the returned object, so let's add a helper to extract and format as preferred.</p>
<pre><code class="language-{.commonlisp">(defun journelly-fetch-weather-summary (lat lon)
  &quot;Fetch weather data from MET Norway API for LAT and LON.

Return in the form:

 '((temperature . \&quot;16.9¬∞C\&quot;)
   (symbol . \&quot;cloudy\&quot;)).&quot;
  (let* ((data (journelly-fetch-weather lat lon))
         (now (current-time))
         (entry (seq-find
                 (lambda (entry)
                   (let-alist entry
                     (time-less-p now (date-to-time .time))))
                 (let-alist data
                   .properties.timeseries)))
         (unit (let-alist data
                 .properties.meta.units.air_temperature)))
    (unless entry
      (error &quot;Couldn't fetch weather data&quot;))
    (let-alist entry
      `((temperature . ,(format &quot;%.1f%s&quot;
                                .data.instant.details.air_temperature
                                (cond
                                 ((string= unit &quot;celsius&quot;) &quot;¬∞C&quot;)
                                 ((string= unit &quot;fahrenheit&quot;) &quot;¬∞F&quot;)
                                 (t (concat &quot; &quot; unit)))))
        (symbol . ,(alist-get 'symbol_code .data.next_1_hours.summary))))))
</code></pre>
<p>We can take it for a spin with:</p>
<pre><code class="language-{.commonlisp">(journelly-fetch-weather-summary 51.51871 -0.17575)
</code></pre>
<p>Nice! Look at that weather, it's a sign I should finish writing and go outside!</p>
<pre><code class="language-{.commonlisp">'((temperature . &quot;19.0¬∞C&quot;)
  (symbol . &quot;clearsky_day&quot;))
</code></pre>
<p>I really should go outside, but I'm just so close now‚Ä¶ Or so I thought! That symbol (ie. &quot;clearsky_day&quot;) isn't recognizable by Journelly, which relies on <a href="https://developer.apple.com/sf-symbols/">SF Symbols</a> returned by <a href="https://developer.apple.com/weatherkit/">WeatherKit</a>. I need a mapping of sorts between these symbols. Gosh, I do need to go outside. Let's speed things along. This is a perfect task for a robot! Whipped <a href="https://github.com/xenodium/chatgpt-shell">chatgpt-shell</a> out and asked the LLM robots to take on this grunt work, who gave me:</p>
<pre><code class="language-json">{
  &quot;clearsky_day&quot;: &quot;sun.max&quot;,
  &quot;clearsky_night&quot;: &quot;moon.stars&quot;,
  &quot;clearsky_polartwilight&quot;: &quot;sun.horizon&quot;,
  ...
  &quot;snowshowers_and_thunder_day&quot;: &quot;cloud.sun.bolt.snow&quot;,
  &quot;snowshowers_and_thunder_night&quot;: &quot;cloud.moon.bolt.snow&quot;,
  &quot;thunderstorm&quot;: &quot;cloud.bolt&quot;
}
</code></pre>
<p>We're in elisp land so who wants json? Hey robot, I need an alist:</p>
<p><img src="https://xenodium.github.io/images/a-richer-journelly-org-capture-template/chatgpt-shell.png" alt=""></p>
<p>Won't the LLM make mapping errors? Most certainly! But for now, I'm just getting a rough prototype and I need to get moving if I want to go outside!</p>
<p>We plug our mapping into an elisp function</p>
<pre><code class="language-{.commonlisp">(defun journelly-resolve-metno-to-sf-symbol (symbol)
  &quot;Resolve Met.no weather SYMBOL strings to a corresponding SF Symbols.&quot;
  (let ((symbols '((&quot;clearsky_day&quot; . &quot;sun.max&quot;)
                   (&quot;clearsky_night&quot; . &quot;moon.stars&quot;)
                   (&quot;clearsky_polartwilight&quot; . &quot;sun.horizon&quot;)
                   ...
                   (&quot;snowshowers_and_thunder_day&quot; . &quot;cloud.sun.bolt.snow&quot;)
                   (&quot;snowshowers_and_thunder_night&quot; . &quot;cloud.moon.bolt.snow&quot;)
                   (&quot;thunderstorm&quot; . &quot;cloud.bolt&quot;))))
    (map-elt symbols symbol)))
</code></pre>
<p>Does it work? Kinda seems like it.</p>
<pre><code class="language-{.commonlisp">(journelly-resolve-metno-to-sf-symbol
 (map-elt (journelly-fetch-weather-summary 51.51871 -0.17575) 'symbol))
</code></pre>
<pre><code class="language-{.commonlisp">&quot;sun.max&quot;
</code></pre>
<p>We got everything we need now, let's put the bits together:</p>
<pre><code class="language-{.commonlisp">(defun journelly-generate-metadata ()
  (let* ((location (journelly-get-location))
         (weather (journelly-fetch-weather-summary
                   (map-elt location 'lat)
                   (map-elt location 'lon))))
    (format &quot;%s
:PROPERTIES:
:LATITUDE: %s
:LONGITUDE: %s
:WEATHER_TEMPERATURE: %s
:WEATHER_SYMBOL: %s
:END:&quot;
            (or (map-elt location 'description) &quot;-&quot;)
            (map-elt location 'lat)
            (map-elt location 'lon)
            (alist-get 'temperature weather)
            (journelly-resolve-metno-to-sf-symbol
             (alist-get 'symbol weather)))))
</code></pre>
<p>Lovely, we now get the metadata we need in the expected format.</p>
<pre><code class="language-{.commonlisp">Waterside House
:PROPERTIES:
:LATITUDE: 51.51871
:LONGITUDE: -0.17575
:WEATHER_TEMPERATURE: 18.5¬∞C
:WEATHER_SYMBOL: sun.max
:END:
</code></pre>
<p>Damn, the temperature is dropping. I really do need to go outside. So close now!</p>
<p>All we have to do is plug our <code>journelly-generate-metadata</code> function into our org template and‚Ä¶ Bob's your uncle!</p>
<pre><code class="language-{.commonlisp">(setq org-capture-templates
      '((&quot;j&quot; &quot;Journelly&quot; entry (file &quot;path/to/Journelly.org&quot;)
         &quot;* %U @ %(journelly-generate-metadata)\n%?&quot; :prepend t)))
</code></pre>
<p>We can now invoke our trusty <code>M-x org-capture</code> and off we go‚Ä¶</p>
<p><img src="https://xenodium.github.io/images/a-richer-journelly-org-capture-template/capture.gif" alt=""></p>
<p><img src="https://xenodium.github.io/images/a-richer-journelly-org-capture-template/journelly.jpeg" alt=""></p>
<p>While the code currently lives in my Emacs config, it's <a href="https://github.com/xenodium/dotsies/blob/main/emacs/ar/journelly.el">available on GitHub</a>. If you do take it for a spin, it may crash and burn. I blame the weather. In the UK, when sunny, you rush to go outside! üåûüèÉ‚Äç‚ôÇÔ∏èüí®</p>
