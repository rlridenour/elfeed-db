<p>Hi, I’m the problem, it’s me.</p>
<p>Some people can leave well enough alone, but not us nerds! You may recall a few years ago, I detailed <a href="https://sixcolors.com/post/2022/11/creating-a-smart-on-air-sign-with-an-e-ink-display/">my creation of a smart On Air sign</a> using a color e-ink display.</p>
<figure><img data-recalc-dims="1" decoding="async" src="https://i0.wp.com/sixcolors.com/wp-content/uploads/2025/04/onair-sign-2025-6c.jpg?ssl=1" alt="" data-image-w="" data-image-h="" class=" jetpack-broken-image"><figcaption></figcaption></figure>
<p>While I feel that project was largely a success, one major obstacle has kept it from being as useful as I’d hoped: the long battery life.</p>
<p>What? How is <em>long</em> battery life a problem, I can hear you asking.<sup id="fnref-34439-microphone"><a href="https://sixcolors.com#fn-34439-microphone" class="jetpack-footnote" title="Read footnote.">1</a></sup> The issue is that the battery life is just long enough that I forget to recharge it until I happen to check and see that it’s dead, invariably right before I start recording a podcast.</p>
<p>Now, I could just set a reminder to go off every few days to plug in the sign and recharge it, but simple solutions aren’t how we ended up here in the first place, are they? Time for some OverEngineering™!</p>
<p>The idea that came to me one day was sheer elegance in its simplicity: what if I built a system that let me know what the current battery level was so that I could charge it when it was getting low but before it had died?</p>
<p>Yep: here we go again.</p>

<h2>Easy as Python</h2>
<p>As long as I was about to embark upon revising my code, I figured I might as well go whole hog. Back when I first set up my Inkplate e-ink display, I opted to use the standard firmware and write my code in the Arduino IDE. As I noted at the time, my expertise with the language wasn’t high, but I figured I could muddle through with some help.</p>
<p>However, I knew that the other available option was to flash the  board with the MicroPython firmware and I have spent more time working with Python in recent months, so it seemed like a good opportunity to take a crack at that as well. Fortunately, the instructions for installing the firmware on the Inkplate are <a href="https://github.com/SolderedElectronics/Inkplate-micropython">fairly straightforward</a>, though I did have to do the usual amount of tweaking and looking up details to get it working.</p>
<p>The switch to MicroPython also meant I would be relying on command line tools instead of Arduino’s GUI IDE, but as someone who’s spent a fair amount of his life in Terminal, this wasn’t really a drawback.<sup id="fnref-34439-ide"><a href="https://sixcolors.com#fn-34439-ide" class="jetpack-footnote" title="Read footnote.">2</a></sup></p>
<p>The next step was translating my existing code to run in Python. And while I probably could have done so myself, checking references as I went like I was moving text from English to French, it struck me that this is exactly the kind of task where an AI actually excels.</p>
<p>Enter ChatGPT. I fed it my Arduino script and asked it to convert it to Python, making sure to specify I was using MicroPython. That’s important because, though MicroPython <em>is</em> Python, it is more limited in the availability of modules and has some of its own particular quirks. I was even able to point the AI directly to Inkplate’s MicroPython GitHub repository so it could see exactly what it was working with. And, of course, I made sure to read it all through to make sure everything seemed correct. But my code was pretty simple, so it was quick work to confirm that it did what I wanted; I was even able to remove a few little quirks that had been required by the strictures of the Arduino code.</p>
<p>The one big challenge I had to duplicate my existing functionality was in encoding of the images. As I mentioned in my previous piece, Inkplate provided a handy online tool to convert bitmap images to bytecode so the display could render them, but it turns out that Python’s formatting of bytecode wasn’t close enough that I could easily just reuse the existing versions. Instead, I spent quite some time working with ChatGPT to try and create a script that would convert bitmaps into compatible images—this is one of those places where I quickly ran up against my own knowledge and limitations.<sup id="fnref-34439-drdrang"><a href="https://sixcolors.com#fn-34439-drdrang" class="jetpack-footnote" title="Read footnote.">3</a></sup></p>
<p>Much of that happened later in the process, but the important point was that I basically had the display up and running on MicroPython and doing everything it did before. Now for the fun part: adding new functionality.</p>
<h2>Battery of tests</h2>
<p>My idea to monitor battery life meant having the charge level available online somewhere, which in turn required the board to send that information periodically. Good news: it’s basic functionality already involved waking up every five minutes to check if it needed to change the graphic; I figured I could just piggyback on that cycle and have it send out the battery level when finished.</p>
<figure><img data-recalc-dims="1" decoding="async" src="https://i0.wp.com/sixcolors.com/wp-content/uploads/2025/04/onair-php-battery-6c.png?ssl=1" alt="" data-image-w="" data-image-h="" class=" jetpack-broken-image"><figcaption>I store the battery info in a .json file on my server.</figcaption></figure>
<p>The first step, though, was figuring out the battery level, which is itself more art than science as the Inkplate doesn’t calculate its own battery percentage. But thanks to the Inkplate code examples I knew that I could access the current level of battery <em>voltage</em>, and based on checking the voltage both when the display was dead as well as after it had been charging long enough to presumably be full, I could come up with a very rough calculation of its current percentage—enough to handle my situation of simply needing to know when it was getting low enough that I should charge it.</p>
<p>Once I had a way to calculate the battery level on device, I had to send it to my server. For this I turned to a different technology entirely: PHP. As a language that’s designed to interact with a web server, this turned out to be the best option for collecting the information sent by the Inkplate. I had it send a small payload to my server with the current voltage, calculated percentage, and timestamp as a JSON file.</p>
<p>Now I just had to read it.</p>
<h2>Swiftly now</h2>
<p>If I needed to display some arbitrary data in my menu bar, <a href="https://github.com/swiftbar">SwiftBar</a> was, of course, my first stop. I ran into a challenge, though, when I tried to use Python to build a plugin for it: due to macOS’s handling of Python versions, it’s a pain to use anything that requires modules <em>or</em> to use virtual environments. I debated using PHP for this as well, but then stumbled across a simpler solution: SwiftBar recently added support for running plugins created in Shortcuts.</p>
<figure class="pull-right"><img data-recalc-dims="1" decoding="async" src="https://i0.wp.com/sixcolors.com/wp-content/uploads/2025/04/onair-swiftbar-plugin-6c.png?ssl=1" alt="" data-image-w="" data-image-h="" class=" jetpack-broken-image"><figcaption></figcaption></figure>
<p>This actually turned out to be ideal for my solution. I wrote a simple Shortcut that grabbed the JSON file from my server and piped it out. I even went ahead and used SwiftBar’s support for SF Symbols to add some a battery icon, complete with color coding: a full green battery for 50% and above, a yellow partially full battery for below that, and a red empty battery when it dropped beneath 10%.</p>
<p>I also added the calculated percentage and timestamp in the dropdown part of the plugin so I could get more information if I needed it.</p>
<h2>It’s all in the timing</h2>
<p>As long as I was making changes, I dabbled with some other possible enhancements.</p>
<p>The biggest weakness of my On Air sign is that it only refreshes every five minutes. Ideally, I’d like it to be instant, which would require some way to essentially ping it when to update. Unfortunately, my attempts along this line have remained fruitless.</p>
<p>While it is possible to connect wirelessly to the Inkplate and issue commands via a feature called <a href="https://github.com/micropython/webrepl">webrepl</a>, there are two issues here: one, the Wi-Fi support in the ESP32 chip at the heart of the Inkplate can be finicky, taking a long time to connect or occasionally not connecting at all. Second, and more importantly, there appears to be no way to put the device to sleep and have it wake via the network, which means that it would have to be on all the time, drastically reducing the overall battery life.</p>
<p>I also experimented with having it sleep for just a minute between checks, but that proved so short an interval as to still take a big toll on the battery. It then occurred to me that I could have it sleep longer at times when I knew I wouldn’t need it—say, overnight.</p>
<p>Unfortunately, determining what “overnight” is turns out to be a fraught pursuit. The Inkplate itself does not innately know the current time, so I have to use the <code>ntptime</code> package baked into the MicroPython firmware to sync with a network time server.<sup id="fnref-34439-request"><a href="https://sixcolors.com#fn-34439-request" class="jetpack-footnote" title="Read footnote.">4</a></sup></p>
<p>That’s not without its own problems. For one thing, the package’s functionality is basic. Most critically, it has no way to account for daylight saving time which means, yes, I had to write my own function for figuring out whether it’s DST or not, since the difference does impact when it’s “overnight.”<sup id="fnref-34439-simpler"><a href="https://sixcolors.com#fn-34439-simpler" class="jetpack-footnote" title="Read footnote.">5</a></sup></p>
<p>Moreover, the default <code>ntptime</code> package can fail with a timeout that kills the entire running program. There is the option to <a href="https://github.com/peterhinch/micropython-samples/blob/master/README.md#414-ntp-time">drop in a replacement package</a> which allows for more graceful failures, but I was unable to get that package to work with the NTP server that I deployed on my Synology.<sup id="fnref-34439-ntpsynology"><a href="https://sixcolors.com#fn-34439-ntpsynology" class="jetpack-footnote" title="Read footnote.">6</a></sup></p>
<p>So, for the moment, I’ve stuck with using the built-in <code>ntptime</code> functionality to add in long sleeps overnight in addition to checking every five minutes. I also updated my SwiftBar plugin to throw an alert if it’s been more than 10 minutes since the battery status has been updated, which will help me track how often timeout errors become a problem. If it ends up recurring too often, I can always revert back to just the five minute check or figure out how to use that replacement module.</p>
<p>The battery life in this mode continues to be outstanding, and now that I have the information in the menu bar of my Mac, I can more easily track when I need to plug in the sign to charge it. While it may be a little ways off from my ideal version of this project, it’s taken a small step forward that at least makes it more usable.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn-34439-microphone">
No, I’m not listening to you, but I can’t believe you would say that, Greg. <a href="https://sixcolors.com#fnref-34439-microphone" title="Return to main content.">↩</a>
</li>
<li id="fn-34439-ide">
Arduino’s IDE is also slow and clunky, so no real loss there. <a href="https://sixcolors.com#fnref-34439-ide" title="Return to main content.">↩</a>
</li>
<li id="fn-34439-drdrang">
I got <em>very</em> close to having to reach out to our pal Dr. Drang, but ended up figuring it out before I threw myself on his mercy. <a href="https://sixcolors.com#fnref-34439-drdrang" title="Return to main content.">↩</a>
</li>
<li id="fn-34439-request">
My initial—and I thought brilliant—idea was to have the code simply grab the time from my webserver when it requested the details of the “on air” status. After all, it’s already making the request and the server is on my local time. Alas, the <code>urequest</code> module that’s included in the firmware only retrieves a limited number of headers from the server, date not among them. <a href="https://sixcolors.com#fnref-34439-request" title="Return to main content.">↩</a>
</li>
<li id="fn-34439-simpler">
Would it maybe have been simpler to ignore DST and have it sleep for a shorter time, assuming that it would go to sleep at, say, 1AM, no matter what? Sure. But it would also be simpler to close my door when I’m podcasting and have that tell people if I’m on air or not. I’m clearly not here for simple solutions. <a href="https://sixcolors.com#fnref-34439-simpler" title="Return to main content.">↩</a>
</li>
<li id="fn-34439-ntpsynology">
Even using macOS’s built in <code>sntp</code> tool to query that server yielded a lot of errors including timeouts and “Server not synchronized”, suggesting to me that Synology’s implementation of <code>ntp</code> may itself be unreliable. <a href="https://sixcolors.com#fnref-34439-ntpsynology" title="Return to main content.">↩</a>
</li>
</ol>
</div>
