<p>Window management in Emacs gets a bad rap.</p>
<p>Some of this is deserved, but mostly this is a consequence of combining a very flexible and granular layout system with rather coarse controls.  This leaves the door open to creating and using tools for handling windows that employ and provide better metaphors and affordances.</p>
<p>As someone who&rsquo;s spent an unnecessary amount of time trying different approaches to window management in Emacs over the decades, I decided to summarize them here.  Almanac might be overstating it a bit &ndash; this is a primer to and a collection of window management resources and tips.</p>
<p>Window management in Emacs bleeds into buffer, state, workspace and frame management, so it&rsquo;s difficult to contain the scope of any article that aims to be comprehensive.  To that end,</p>
<ul>
<li>this write-up assumes that you&rsquo;ve finished at least the Emacs tutorial and are familiar with basic Emacs terminology (what&rsquo;s a buffer, window and a frame) and with window actions: splitting windows, deleting them or deleting other windows, and switching focus.</li>
<li>There are only a few brief mentions of tabs, as they are primarily a tool for workspace management, as opposed to window management.</li>
<li>I&rsquo;m focusing on window/buffer management within an Emacs frame.  Many of the below tools work across frames just as well, but you&rsquo;ll have to find the right switches to flip to enable cross-frame support.</li>
<li>Finally, this is more <em>my</em> almanac than a wiki: It covers only tools or ideas I&rsquo;ve personally explored over the years, with brief mentions of potentially useful packages that I haven&rsquo;t tried.  Any omissions are not value judgments, please let me know if I miss something useful.</li>
</ul>
<p>At some point this transitions from listing well known tools to tips, then hacks, and finally unvarnished opinions.  It&rsquo;s front-loaded: the first chunk of the write-up gives you a 70% solution.  If you are new to Emacs, feel free to stop at 30%.  If you are an old hand, feel free to skip the first 30%.  It also lists substitutes: several ways to do the same things, <strong>so you can pick just one method</strong> and ignore the rest.   Things get progressively more opinionated and idiosyncratic in the second half.</p>
<p>If you are reading this in the future, this write-up is probably out of date.  The Emacs core is very stable, but the package ecosystem tends to drift around as packages are developed and abandoned.  The built-in solutions will still be around, but there are no guarantees on the third-party packages!  That said, the longer a package has been around the more likely it&rsquo;s going to stick around in a functional state &ndash;  even if only as a frozen entry in the <a href="https://github.com/emacsorphanage">Emacs Orphanage</a>.</p>
<p>As new ideas emerge, there will be new approaches to window management that aren&rsquo;t covered here.  These innovations don&rsquo;t need to happen in the Emacs sphere &ndash; Emacs likes to <del>steal</del> reinvent ideas that originate elsewhere, much as other applications rediscover ideas that Emacs introduced in the 1990s.  So this topic might be worth revisiting afresh in a few years.</p>
<h2 id="what-we-mean-by-window-management">What we mean by &ldquo;window management&rdquo;</h2>
<figure><img src="https://karthinks.com/img/emacs-window-buffer-frame.png"/>
</figure>

<p>Emacs separates the idea of a <strong>window</strong> (a &ldquo;viewport&rdquo; or &ldquo;pane&rdquo; in the frame) from the <strong>buffer</strong>, a contiguous chunk of text that may or may not be the contents of a file.  These concepts are usually fused in IDEs and text editors &ndash; this reduces the cognitive load of using the application, but closes the door on more flexible behavior and free-form arrangments.  For example, many editors don&rsquo;t let you have two views of the same file, which is trivial in Emacs.  They&rsquo;re often uncomfortable even with the idea of a dissociated buffer &ndash; a buffer that does not represent the (possibly edited) contents of a file.  Reified concepts like Emacs&rsquo; <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Indirect-Buffers.html">indirect buffers</a> are completely foreign to them
<span class="sidenote-number"><small class="sidenote">
Unfortunately for Emacs, its current design rules out some clever ideas that other editors have implemented.  One example of this is the <a href="https://github.com/perky/4coder_loco">4coder&rsquo;s yeetsheet</a> or <a href="https://www.youtube.com/watch?v=GB_oTjVVgDc">Dion systems&rsquo; views</a>: You can have buffers whose contents are &ldquo;live&rdquo; substrings of multiple other buffers, <em>i.e.</em> you can mix and match <em>pieces</em> of buffers.  In Emacs the most you can have is indirect buffers, <em>i.e.</em> full &ldquo;live&rdquo; copies of a buffer.
</small></span>
.</p>
<p>Emacs allows you to do a lot more, but users have to contend with this cognitive cost.  New users pay thrice: they have to deal with getting windows into the right places in the frame, getting buffers into the right windows, <em>and</em> they miss out on the upside because they don&rsquo;t yet realize what this decoupling makes possible.  Hopefully this write-up can address two of these costs.</p>
<p>For reference in the rest of this article, here&rsquo;s a non-exploded schematic of an Emacs frame, with the left window selected:</p>
<figure><img src="https://karthinks.com/img/emacs-window-chart.png"/>
</figure>

<ul>
<li>Each colored block is a window, the numbers represent buffers being shown in them.</li>
<li>The active window is the one with a black border.</li>
</ul>
<style>
.detail-icon {
float: right;
width: 25px;
}
</style>
<h3 id="this-article-is-not-about">This article is <strong>not</strong> about…</h3>
<p>Since actions with or on windows in Emacs are primitive, common and unavoidable operations at any level of Emacs usage, this topic is suprisingly subtle, broad and deep, and there&rsquo;s only so much I can explore in 15,000 words.  So we begin with some disambiguation and a narrowing of focus.  This article is <strong>not</strong> about the following things.</p>
<details open>
<summary>Rules for displaying buffers</summary>
<div class="details">
<blockquote>
<p>Emacs keeps popping up windows in the wrong places and destroying my window arrangement!</p>
</blockquote>
<p>The situation is&hellip; less than ideal.  Displaying buffers in the right windows <em>automagically</em> is generally possible but this configuration is involved and requires knowledge of minutiae of the Emacs API, like <code>window-parameters</code>, slots and dedicated windows.  the <code>display-buffer</code> API is so involved that describing it takes up a big chunk of the Elisp manual, and even that concludes by saying &ldquo;<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/The-Zen-of-Buffer-Display.html">just go with it</a>&rdquo;.
<span class="sidenote-number"><small class="sidenote">
And this is the one aimed at developers using elisp.  It&rsquo;s not even the Emacs user manual!
</small></span>
I mention automatic window management <a href="#deal-with-windows-so-we-don-t-have-to-deal-with-windows">briefly towards the end</a>, but this article is <strong>not</strong> about reining in the behavior of <code>display-buffer</code>.  I recommend <a href="https://www.masteringemacs.org/article/demystifying-emacs-window-manager">Mickey Peterson&rsquo;s article</a> on demystifying the window manager for this, this <a href="https://protesilaos.com/codelog/2024-02-08-emacs-window-rules-display-buffer-alist/">video by Protesilaos Stavrou</a>, or <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Displaying-Buffers.html">the manual</a> if you&rsquo;ve got the stomach for it.</p>
</div>
</details>
<p><span class="org-target" id="org-target--window-configuration-persistence"></span></p>
<details open>
<summary>Window configuration persistence, workspaces or buffer isolation</summary>
<div class="details">
<blockquote>
<p>I want Emacs to group together windows for a given task and persist them across sessions!</p>
</blockquote>
<p>Two common factors affecting Emacs use:</p>
<ul>
<li>Emacs sessions tend to be long lasting, and</li>
<li>its gravity pulls users into using it for an increasing number of tasks.</li>
</ul>
<p>The result is that you end up with hundreds of buffers and start looking for ways to group them, isolate the groups and then preserve them.  This is tied to window management, but only in the sense that your arrangement of windows is part of the state you want to preserve.  This is a finicky and complex subject, and well beyond the scope of this write-up.  Take your pick: between  <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html">tab-bar</a>, <a href="https://github.com/mclear-tools/tabspaces">tabspaces</a>, <a href="https://depp.brause.cc/eyebrowse/">eyebrowse</a>, <a href="https://github.com/minad/tab-bookmark">tab-bookmark</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Desktop-Save-Mode.html">desktop.el</a>, <a href="https://github.com/Bad-ptr/persp-mode.el">persp-mode.el</a>, <a href="https://github.com/nex3/perspective-el">perspective</a>, <a href="https://github.com/fritzgrabo/project-tab-groups">project-tab-groups</a>, <a href="https://gitlab.com/protesilaos/beframe">beframe</a> and <a href="https://github.com/alphapapa/activities.el">activities.el</a> there is no paucity of projects to help you do this.</p>
</div>
</details>
<details open>
<summary>Paradigmatic changes to window behavior in Emacs</summary>
<div class="details">
<blockquote>
<p>Why is window placement in Emacs so capricious? Tiling window managers solved this problem ages ago!</p>
</blockquote>
<p>Some packages provide all-encompassing, radical solutions to window arrangment and management &ndash; essentially, they are <em>window managers</em> for Emacs.  For example, <a href="https://gitlab.com/ajgrf/edwina">Edwina</a> modifies Emacs&rsquo; manual window-tree based behavior to enforce a master-and-stack <a href="https://dwm.suckless.org/tutorial/">DWM-style auto-tiling layout</a>, with a complete suite of accompanying window management commands.  <a href="https://www.gnu.org/software/hyperbole/man/hyperbole.html#HyControl">HyControl</a> provides a control panel for window layout actions and can display windows in a uniform grid on the frame, among other features.
<span class="sidenote-number"><small class="sidenote">
Apologies for the terse and possibly inaccurate descriptions, I have only brief experience with these.
</small></span>
.</p>
<p>In my experience &ldquo;complete&rdquo; solutions like these are great when you start using them, but eventually cause more friction than elation.  This is the case the more you customize Emacs, as the abstractions they build on top of the Emacs API end up limiting, as opposed to liberating you in the long run.</p>
</div>
</details>
<hr>
<p>So what&rsquo;s left?  In this article, <strong>we mean window management in the manual and mundane sense</strong>: switching window focus, moving buffers around windows, splitting or closing them and so on.  Even if you&rsquo;ve got <code>display-buffer</code> all sorted out and your windows grouped into workspaces, these are the kinds of things you <em>have</em> to do with windows &ndash; repeatedly and often &ndash; in the course of minute-to-minute, regular editing.</p>
<p>Let&rsquo;s address a couple of common concerns and dismissals before we get started in earnest.</p>
<details open>
<summary>The two-window perspective</summary>
<div class="details">
<blockquote>
<p>This palaver is pointless, I need two windows at most.</p>
</blockquote>
<p>Correction: You need at most two windows <em>at a time</em>.  And that&rsquo;s partly because corralling windows is a mess in Emacs.  Except during bursts of writing or coding, chances are you need easy access to more than one buffer &ndash; for reference material or look-ups, search and compilation results, file access, shells and REPLs, table of contents and so on.  Whether these are on screen in windows all the time or easily displayed on demand is a matter of screen size and preference, but both involve interacting with windows and buffers <em>manually</em>.  Both approaches are thus under the purview of &ldquo;window management&rdquo;, and addressed in this article.</p>
</div>
</details>
<details open>
<summary>The pointer prescription</summary>
<div class="details">
<blockquote>
<p>Just use the mouse?  This isn&rsquo;t even an issue in most software.</p>
</blockquote>
<p>The mouse is indeed the most natural way to navigate windows.  Without stepping into contentious discussions on economy of motion, RSI trouble or personal preferences, the main problem with the mouse approach is that the lack of a learning curve (relative to the keyboard) is balanced by the lack of expressivity (relative to the keyboard).</p>
<p>Even so, you can <a href="https://karthinks.com/software/different-strokes-for-different-folks/">squeeze a lot more expressivity</a> out of the mouse in Emacs than you can in most other applications
<span class="sidenote-number"><small class="sidenote">
The <a href="https://en.wikipedia.org/wiki/Acme_(text_editor)">ACME editor</a> might be the most notable exception.
</small></span>
.  I use the mouse for managing windows in Emacs often &ndash; but only in certain contexts, see <a href="#mousing-around--built-in">Mousing around</a>.</p>
</div>
</details>
<h2 id="warming-up">Warming up</h2>
<p>Our appetizer: a short run-through of the most popular and commonly recommended window management options.  These cover changing the focused window, moving windows around and undoing oopsies, with a side of buffer management and bespoke window actions
<span class="sidenote-number"><small class="sidenote">
This is the part you can skip if you&rsquo;ve been around the block a few times.  Jump ahead to <a href="#digging-in">digging in</a>.
</small></span>
.</p>
<h3 id="other-window-and-the-next-window--built-in"><code>other-window</code> and the &ldquo;next window&rdquo; (built-in)</h3>
<p><code>other-window</code> offers: selecting windows</p>
<p>The <code>other-window</code> (<code>C-x o</code>) command is the baseline window switching experience.  It&rsquo;s what the Emacs tutorial teaches you, and it works well enough when you have a small number of windows:</p>
<figure><img src="https://karthinks.com/img/other-window-chart.png"/>
</figure>

<p>The window selection cycles (roughly) clockwise across the frame.  The advantage of this approach is simplicity &ndash; it&rsquo;s a single command and keybinding.  As you might expect or have experienced, it takes progressively more invocations to get somewhere as you accumulate more windows, and works best if you rarely have more than two windows showing at once.</p>
<details class="details apinote" open>
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> Basic <code>other-window</code> tips and tweaks</summary>
<div class="details">
<ol>
<li>It&rsquo;s possibly one of the most used Emacs commands &ndash; bind it to a more convenient key like <code>M-o</code>.</li>
<li>You can use digit arguments to skip windows or to cycle windows backwards.  <code>M-3 M-o</code> will select three windows ahead, and <code>M-- M-2 M-o</code> two windows back.  Unfortunately this requires a visual understanding of the order in which the cycling happens.  It&rsquo;s not obvious which window is three windows away in more complex window layouts.</li>
<li>Turn on <code>repeat-mode</code> (<code>M-x repeat-mode</code>) to continue switching windows with just <code>o</code> and (backwards) <code>O</code>.  <code>C-x o o o o...</code> or <code>M-o o o o...</code> is faster than <code>C-x o C-x o C-x o...</code>.</li>
</ol>
</div>
</details>
<details class="details implementation">
<summary><span><img src="https://karthinks.com/img/lisp-icon.png" class=detail-icon></span>  <code>other-window</code> hacks</summary>
<div class="details">
<p>You can make <code>other-window</code> skip over a window by setting its <code>no-other-window</code> window parameter.  A window parameter is a property of Emacs&rsquo; window data structure, and there are Elisp functions to set them.  This is usually something you&rsquo;d specify in advance for certain classes of buffers in <code>display-buffer-alist</code>, not a manual toggle.  If you&rsquo;ve ever wondered why <code>other-window</code> does not select the windows of fancy file-manager listings (like dired-sidebar or dirvish-side), this is it.</p>
</div>
</details>
<p>If you only ever have two windows showing in Emacs, or if you don&rsquo;t mind punching <code>o</code> a few extra times, you can stop here.  The rest is just varying degrees of optimization applied to a problem that you probably (and perhaps realistically) don&rsquo;t believe needs solving!</p>
<p><span class="org-target" id="org-target--window-management-next-window"></span></p>
<details open>
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> Understanding the &ldquo;next window&rdquo;</summary>
<div class="details">
<p>The &ldquo;next window&rdquo; is the window that <code>other-window</code> selects, usually clockwise from the current one.  You can access it in elisp by calling the <code>next-window</code> function.  With daily usage, you automatically develop intuition for the clockwise ordering of windows in an Emacs frame &ndash; in the sense that you <em>know</em> instead of <em>think</em>.  This is handy, because the notion of the next window is useful for more than just window selection.  There are better ways to select windows, or there wouldn&rsquo;t be much to this write-up!  The next window is the default window for commands that operate in another window, like <code>scroll-other-window</code>.  See <a href="#do-you-need-to-switch-windows">Do you need to switch windows?</a></p>
</div>
</details>
<h3 id="windmove--built-in"><code>windmove</code> (built-in)</h3>
<p><code>windmove</code> offers: selecting windows, swapping buffers in windows, deleting them</p>
<p>Windmove is a built-in Emacs library for moving the focus across windows &ndash; and for moving buffers across windows &ndash; by direction.  Vim users, this is what you expected.  <code>evil-mode</code> users, you already use Windmove, you just don&rsquo;t know it.</p>
<p>If <code>other-window</code> is the alt-tab of Emacs, Windmove is the tiling window manager equivalent.  It makes the spatial arrangement of windows in the frame relevant to the selection, which I imagine is the most natural way to do it short of using the mouse.</p>
<p>Using Windmove is simple: bind <code>windmove-left</code> (resp <code>-right</code>, <code>-up</code> and <code>-down</code>) to a modifier or leader key plus whatever keys you associate with directions: <code>WASD</code>, <code>HJKL</code> or the arrow keys perhaps.</p>
<figure><img src="https://karthinks.com/img/windmove-chart.png"/>
</figure>

<p>The fork: movement to the right in this schematic depends on what window is exactly to the right of the cursor.  Calling <code>windmove-right</code> from near the top of buffer 1 moves the focus to buffer 2, starting near the bottom moves the focus to 3.</p>
<p>You can also swap the buffers of windows directionally with Windmove, a handy way of rearranging windows on the frame
<span class="sidenote-number"><small class="sidenote">
Again, Windmove is how <code>evil-mode</code> does this.
</small></span>
.  The relevant commands are <code>windmove-swap-states-left</code>, <code>-right</code>, <code>-up</code> and <code>-down</code>.</p>
<figure><img src="https://karthinks.com/img/windmove-swap-chart.png"/>
</figure>

<p>Note that the focus moves along with the buffer when you do this.</p>
<p>There&rsquo;s more yet to Windmove, you can delete the window next along any direction with <code>windmove-delete-*</code>, for example.  But we cover better ways to do this below.</p>
<details class="details apinote" open>
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> Tiling manager integration</summary>
<div class="details">
<p>If you use Emacs in a tiling environment, you&rsquo;ve got a nested tiling window manager situation &ndash; it might be desirable to integrate the two so you can (wind)move seamlessly across Emacs windows and OS windows with the same keys.  (Vim+tmux users should be familiar with this.)  It takes a bit of work but is quite doable: Pavel Korytov has an <a href="https://sqrtminusone.xyz/posts/2021-10-04-emacs-i3/">i3 integration</a> description for Emacs+i3wm (and possibly Sway), and I wrote one for the <a href="https://github.com/karthink/.emacs.d/blob/master/plugins/emacs-wm.el">qtile</a> window manager.  I discuss this project in <a href="#the-tiling-wm-integrator">more detail below</a>.</p>
</div>
</details>
<h3 id="frames-only-mode">frames-only-mode</h3>
<p><a href="https://github.com/davidshepherd7/frames-only-mode">frames-only-mode</a> offers: to leave Emacs window handling to the OS.</p>
<figure class="alignright"><img src="https://karthinks.com/img/frames-only-mode.png"/>
</figure>

<p>While we&rsquo;re on the subject of tiling, another resolution to the nested window manager situation &ndash; Emacs inside a tiling WM &ndash; is to simply not bother with Emacs&rsquo; window management.  Opening every buffer in a new frame instead of window makes corralling them the window manager&rsquo;s job.  This puts Emacs buffers on par with OS windows, and you can manage both with the same keys.</p>
<p>Most other commands described in this write-up (such as Avy, <code>winum</code>, <code>ace-window</code> or <code>scroll-other-window</code>) can work across frames just as easily as windows, meaning that you can have the best of both approaches.  There are bound to be edge cases with other Emacs commands though &ndash; many of them make assumptions about being able to split the frame at will
<span class="sidenote-number"><small class="sidenote">
This is especially true of org-mode commands!  Thankfully the Org situation is slowly improving.
</small></span>
.</p>
<div class="warning">
<p>For Linux users:
I haven&rsquo;t tried <code>frames-only-mode</code> with Wayland compositors yet.</p>
</div>
<h3 id="winum-mode"><code>winum-mode</code></h3>
<p><a href="https://github.com/deb0ch/emacs-winum">winum</a> offers: Selecting and deleting windows</p>
<p>Winum is next in the natural progression of the effort to switch between n windows: From O(n) (<code>other-window</code>) to O(√n) (<code>windmove</code>) to O(1).  It adds window numbers to the mode-line so you can select windows by number:</p>
<figure><img src="https://karthinks.com/img/winum-chart.png"/>
</figure>

<p>There are two convenient bonus features:</p>
<ul>
<li>Invoking the command to switch to a window with a negative prefix argument deletes the window, and</li>
<li>when the minibuffer is active, it is always assigned the number 0.</li>
</ul>
<p>It&rsquo;s simple and short, and works across Emacs frames.  <code>winum-mode</code> is the method I use the most for switching windows.</p>
<details class="details apinote" open>
<summary><span><img src="https://karthinks.com/img/lisp-icon.png" class=detail-icon></span> Speeding up window access with winum</summary>
<div class="details">
<p>The default keybinding (<code>C-x w &lt;n&gt;</code> to select window <code>n</code>) is too verbose for my liking, as is any other two step keybinding.  If you don&rsquo;t mind losing access to digit arguments with <code>M-0</code> through <code>M-9</code>, you can use them to select windows instead:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#963">defvar-keymap</span> <span style="color:#963">winum-keymap</span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020">:doc</span> <span style="background-color:#fff0f0">&#34;Keymap for winum-mode actions.&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-0&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-0-or-10</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-1&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-1</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-2&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-2</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-3&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-3</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-4&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-4</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-5&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-5</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-6&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-6</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-7&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-7</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-8&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-8</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;M-9&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum-select-window-9</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#007020">require</span> <span style="color:#a60;background-color:#fff0f0">&#39;winum</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#963">winum-mode</span>)
</span></span></code></pre></div></div>
</details>
<p>While it is possible to extend <code>winum-mode</code> to include other actions on windows (or on buffers displayed in them) besides switching to or deleting them, there&rsquo;s little reason to, thanks to the existence of&hellip;</p>
<h3 id="ace-window"><code>ace-window</code></h3>
<p>Offers: <em>Any</em> window or buffer management action</p>
<p><a href="https://github.com/abo-abo/ace-window">ace-window</a> is the endgame for keyboard-driven Emacs window control.</p>
<p>The <code>ace-window</code> command places &ldquo;hints&rdquo; at the top of each window, and typing in the key switches focus to the corresponding one:</p>
<figure><img src="https://karthinks.com/img/ace-window-chart.png"/>
</figure>

<p>So far it&rsquo;s a slightly slower, two-stage version of winum.  You can turn on <code>ace-window-display-mode</code> to have the hints always showing in the mode-line like winum&rsquo;s window numbers, which speeds up the process a bit:</p>
<figure><img src="https://karthinks.com/img/ace-window-display-mode.png"/>
</figure>

<p>ace-window is to windows what Avy is to characters on screen
<span class="sidenote-number"><small class="sidenote">
The similar design is not a coincidence.  They&rsquo;re both authored by <a href="https://oremacs.com/">Oleh Krehel</a>.
</small></span>
.  But jumping to a character on screen is the least useful of the many <a href="https://karthinks.com/software/avy-can-do-anything/">things you can do with Avy</a>.  Similarly, if all ace-window could do was switch windows, there wouldn&rsquo;t be much to recommend it.  Instead, it offers a generic method to &ldquo;pick&rdquo; a window, across all visible Emacs frames if necessary.  What you do with this window is up to you.  Similar to Avy, ace-window can dispatch actions on any window on the screen.  So you can delete windows, move or swap them around, split them, show buffers in them and more &ndash; without moving away from your selected window.  These are just the built-in actions, provided as part of ace-window:
<span class="org-target" id="org-target--ace-window-default-actions"></span></p>
<figure class="wide"><img src="https://karthinks.com/img/ace-dispatch-chart.png"/>
</figure>

<p>Pressing <code>?</code> when using <code>ace-window</code> brings up the dispatch menu
<span class="sidenote-number"><small class="sidenote">
See <a href="https://karthinks.com/software/fifteen-ways-to-use-embark/">Fifteen ways to use Embark</a> for further explorations of this idea.
</small></span>
.</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/7OFRShA.mp4" type="video/mp4">
<a href="https://karthinks.com/img/ace-dispatch-demo.mp4">[VIDEO: ace-window dispatch demo]</a>
</video>
<details>
<summary>Play by play</summary>
<div class="details">
<ol>
<li>With two or more windows open, call <code>ace-window</code>.  (For two windows or fewer, you will need to ensure that the variable <code>aw-dispatch-always</code> is set to <code>t</code>.)</li>
<li>Press <code>?</code> to bring up the dispatch menu.</li>
<li>Press the dispatch key to split a window horizontally (<code>v</code> in my video)</li>
<li>Press the ace-window key corresponding to the buffer you want to split (<code>e</code> in my video)</li>
<li>Repeat steps 1 and 2</li>
<li>Press the dispatch key to split a window vertically (<code>s</code> in my video)</li>
<li>Press the ace-window key corresponding to the buffer you want to split (<code>w</code> in my video)</li>
</ol>
</div>
</details>
<h3 id="mousing-around--built-in">Mousing around (built-in)</h3>
<p>The mouse offers: Any window or buffer management action</p>
<p>So, the pointer.  Finally.</p>
<p>The advantanges of using the mouse for window management are immediate and obvious.  Window selection is a natural extension of basic mouse usage.  Resizing windows is a snap.  Context (right-click) menus and drag and drop support, which improve with each new Emacs release, are very intuitive
<span class="sidenote-number"><small class="sidenote">
See <code>context-menu-mode</code>.  Also, while not limited to window management, discoverability via Emacs&rsquo; menu-bar is surprisingly good.
</small></span>
.  Unfortunately, I have to address the rodent in the room before we can talk about mitigating the disadvantages, since Emacs users tend to be very opinionated about mouse usage.</p>
<p>I never use the mouse in Emacs&hellip; until I&rsquo;m already using the mouse for something else.  Then driving Emacs with the mouse is actually the <a href="https://karthinks.com/software/different-strokes-for-different-folks/">path of least resistance</a>.  If your hand&rsquo;s already off the keyboard, it&rsquo;s pretty easy to drive Emacs with the mouse:</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/3G9Nk4p.mp4" type="video/mp4">
<a href=https://karthinks.com/img/strokes-window-handling.mp4">[VIDEO: strokes window handling demo]</a>
</video>
<details>
<summary>Play by play</summary>
<div class="details">
<p>This demo showcases the use of mouse gestures to do the following:</p>
<ul>
<li>Split the frame vertically and horizontally</li>
<li>Delete windows</li>
<li>Cycle through buffers in windows</li>
<li>Swap windows to the right and left</li>
<li>Toggle between the last two buffers shown in a window</li>
</ul>
</div>
</details>
<p>You may want to turn on focus-follows-mouse behavior:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span><span style="color:#888">;; Consider setting this to a negative number</span>
</span></span><span style="display:flex;"><span>(<span style="color:#007020">setq</span> <span style="color:#963">mouse-autoselect-window</span> <span style="color:#036;font-weight:bold">t</span>)
</span></span></code></pre></div><h3 id="transpose-frame--rotation-flip-and-flop"><code>transpose-frame</code> (rotation, flip and flop)</h3>
<p><a href="https://github.com/emacsorphanage/transpose-frame">transpose-frame</a> offers: easy window layout transformations.</p>
<p>What it says on the tin: transpose-frame offers commands to rotate or mirror the window layout on the frame.  I found myself using these often enough to bind <code>rotate-frame</code>, <code>flip-frame</code> and <code>flop-frame</code> to suitable keys.  Ironically, the <code>transpose-frame</code> command itself is rarely useful &ndash; it transposes along the main diagonal of the frame.</p>
<h4 id="rotate-frame"><code>rotate-frame</code></h4>
<figure><img src="https://karthinks.com/img/rotate-frame-chart.png"/>
</figure>

<h4 id="flip-frame"><code>flip-frame</code></h4>
<figure><img src="https://karthinks.com/img/flop-frame-chart.png"/>
</figure>

<h4 id="flop-frame"><code>flop-frame</code></h4>
<figure><img src="https://karthinks.com/img/flip-frame-chart.png"/>
</figure>

<h3 id="the-window-prefix-map--built-in">The <code>window-prefix-map</code> (built-in)</h3>
<p><code>window-prefix-map</code> offers: Bespoke window management commands</p>
<p>The <code>window-prefix-map</code>, bound to <code>C-x w</code> by default in Emacs, collects a few useful window-management commands:</p>
<h4 id="split-root-window-right-and-split-root-window-below"><code>split-root-window-right</code> and <code>split-root-window-below</code></h4>
<p>Split the root window of the frame.  Better illustrated than explained:</p>
<figure><img src="https://karthinks.com/img/emacs-window-root-frame-split.png"/>
</figure>

<p>These are bound to <code>C-x w 3</code> and <code>C-x w 2</code> respectively.</p>
<details open>
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> The window tree</summary>
<div class="details">
<p>This is a good time to mention that windows in Emacs are arranged in a tree, with all &ldquo;real&rdquo; windows as leaves.  Each splitting action turns a leaf node into a parent of two windows: the window that was split and the new one.  This is very similar to the window arrangement in manual tiling window managers like <code>i3</code> or <code>bspwm</code>, leading to a redundancy we <a href="#the-tiling-wm-integrator">seek to patch over</a>.</p>
</div>
</details>
<p>These are the only built-in Emacs commands, to my knowledge, that allow you to modify the tree structure at a non-leaf level that doesn&rsquo;t just clear the whole tree (as <code>delete-other-windows</code> does).  Practically speaking, these are often useful to create a space for a logically separate task in the frame &ndash; the default splitting commands only further dice up existing windows.</p>
<p>Getting to grips with the tree arrangment should make a lot more fine-grained control available, but the tooling isn&rsquo;t there yet &ndash; <a href="#window-tree">see below</a> for a proposal.</p>
<h4 id="tab-window-detach-and-tear-off-window"><code>tab-window-detach</code> and <code>tear-off-window</code></h4>
<p>Handy commands to move a window into a new tab or a new frame.</p>
<figure><img src="https://karthinks.com/img/emacs-window-tear-off.png"/>
</figure>

<p>Like splitting the root window, these are quite handy for logical window management: grab a window and move it into a new tab or frame to start a new task.</p>
<p>These are bound to <code>C-x w ^ t</code> and <code>C-x w ^ f</code>, which <em>sheesh</em>.  You can do these as ace-window dispatch actions instead, since you can do <em>anything</em> with ace-window.  Alternatively you can rebind these to the slightly saner <code>C-x w t</code> and <code>C-x w f</code>, which are currently unbound.  I prefer to just use the mouse when I need to tear off a window:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span><span style="color:#888">;; mouse-9 is the &#34;forward&#34; button on my mousee</span>
</span></span><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;M-&lt;mouse-9&gt;&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;tear-off-window</span>)
</span></span></code></pre></div><h3 id="the-other-window-prefix--built-in">The <code>other-window-prefix</code> (built-in)</h3>
<p><code>other-window-prefix</code> offers a method to decouple window selection from buffer display, and solves <strong>three</strong> window-related annoyances.</p>
<p><strong>Annoyance I</strong></p>
<p>Many Emacs commands tightly couple a primary action, a buffer and a window.  For example, running <code>find-file</code> involves selecting a file, creating a buffer and displaying it in the current window.  If you want to decouple the choice of window from the command, you have to pick one of several alternate commands: <code>find-file-other-window</code>, <code>find-file-other-tab</code> or <code>find-file-other-frame</code>, each with its own keybinding.  If you want to open the file in read-only mode, you&rsquo;ve got <code>find-file-read-only</code>, <code>find-file-read-only-other-window</code>, <code>find-file-read-only-other-tab</code> and <code>find-file-read-only-other-frame</code>.  More keybindings.</p>
<p>Want the same choices when selecting a buffer?  You&rsquo;ve got <code>switch-to-buffer-⋆</code>, another constellation of commands.  Opening a bookmark with <code>bookmark-jump</code>? Pick one of several <code>bookmark-jump-*</code> commands. This is the road to <em>insanity</em>.</p>
<p>The problem is the coupling: picking a window to display a buffer should be a separable action from the command&rsquo;s primary function: opening a file, in this example.  The solution is to call <code>other-window-prefix</code>, bound to (<code>C-x 4 4</code>).  This makes it so that the next command &ndash; <em>any</em> command that involves displaying a buffer in a window &ndash; is shown in the <a href="#org-target--window-management-next-window">next window</a>, creating one if necessary.  Now you only need <code>find-file</code>, <code>find-file-read-only</code> and <code>switch-to-buffer</code>, and can use the prefix to redirect the resulting buffer to another window when required:</p>
<ol>
<li>Call <code>other-window-prefix</code> (<code>C-x 4 4</code>)</li>
<li>Call <code>find-file</code>, <code>find-file-read-only</code>, <code>switch-to-buffer</code>, <code>bookmark-jump</code>, or <em>any</em> command that shows a buffer.</li>
<li><em>Result</em>: the buffer is shown in the next window.</li>
</ol>
<p>In a past write-up I&rsquo;ve <a href="https://karthinks.com/software/fifteen-ways-to-use-embark/#open-any-buffer-by-splitting-any-window">mentioned Embark</a> as <em>the way</em>.  Indeed, Embark solves this problem more elegantly than the built-in <code>other-window-prefix</code>.  But avoiding command proliferation is only the first of three problems <code>other-window-prefix</code> solves.</p>
<p><strong>Annoyance II</strong></p>
<p>In the above examples, we at least have the choice of calling <code>*command*-other-window</code> instead of <code>*command*</code>.  There are just too many options.  More often there are <em>none</em>, and we&rsquo;re at the mercy of fixed, undesirable behavior.  This is typically the case when activating a link-like object.  In this example (from the <a href="https://github.com/magit/forge/">Forge</a> package), pressing <code>RET</code> on an issue title opens the issue in the current buffer:</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/sKmFQh0.mp4" type="video/mp4">
<a href=https://karthinks.com/img/other-window-prefix-without.mp4">[VIDEO: Forge without other-window-prefix]</a></video>
<details>
<summary>Play by play</summary>
<div class="details">
<p>This is a list of issues from a code repository, as displayed by the Forge package.</p>
<ol>
<li>Press <code>RET</code> on an issue.</li>
<li>It opens in the current window, denying us <a href="#the-back-and-forth-method">the <strong>Listing &amp; Item</strong> pattern</a>: a simultaneous view of the full listing and the selected issue.</li>
</ol>
</div>
</details>
<p>Forge provides no way, as of this writing, to &ldquo;open a link&rdquo; in another window.  <code>other-window-prefix</code> to the rescue:
<span class="org-target" id="org-target--window-management-forge-video"></span></p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/lz32LBD.mp4" type="video/mp4">
<a href=https://karthinks.com/img/other-window-prefix-with.mp4">[VIDEO: Forge with other-window-prefix]</a></video>
<details>
<summary>Play by play</summary>
<div class="details">
<ol>
<li>Call <code>other-window-prefix</code>, via <code>C-x 4 4</code></li>
<li>Press <code>RET</code> on the issue.  It opens in the &ldquo;next window&rdquo; &ndash; there isn&rsquo;t one so a new window is created.</li>
</ol>
</div>
</details>
<p><strong>Annoyance III</strong></p>
<p>The third problem it solves is the combination of the first two.  Consider: Magit, the sibling package to Forge, <em>does</em> provide a way to do this.  It generally opens &ldquo;links&rdquo; in the next window if you use a universal arg (<code>C-u</code>) before <code>RET</code>.  Org mode, Notmuch, Elfeed and EWW all provide either no way or mutually distinct ways of opening links in a different window.  If Forge did provide a way, it would actually make things worse in a sense.  With <code>other-window-prefix</code>, you&rsquo;re blessedly free from having to customize or conform to each package author&rsquo;s idea of how this should work.  Run <code>other-window-prefix</code>, then activate the &ldquo;link&rdquo; object &ndash; click on it with the mouse if you&rsquo;d like.  It&rsquo;s going to <em>uniformly</em> open in the next window.</p>
<p>See also: <code>same-window-prefix</code> (<code>C-x 4 1</code>), which forces the next command&rsquo;s buffer (if there is one) to use the current window, and <code>other-frame-prefix</code> (<code>C-x 5 5</code>) and <code>other-tab-prefix</code> (<code>C-x t t</code>), which open the next command&rsquo;s buffer in a new frame and tab respectively.</p>
<details>
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> What&rsquo;s with these keybindings?</summary>
<div class="details">
<p>There is a method to the seeming madness of keybindings like <code>C-x 4 4</code>,  <code>C-x 4 1</code> and <code>C-x 5 5</code>.</p>
<p>Keybindings involving specific window actions are grouped into prefixes, like a menu. <code>C-x 4</code>, the <code>ctl-x-4-map</code> broadly contains commands that use the <code>other-window</code>.  For instance, <code>C-x 4 .</code> jumps to the definition of the thing at point (like the default <code>M-.</code>), but in the <code>other-window</code>.  Most commands in the <code>ctl-x-5-map</code> create a new frame.  Tab-bar actions are grouped under <code>C-x t</code>.</p>
<p>The final &ldquo;base&rdquo; key in each map follows a consistent pattern: <code>f</code> opens files, <code>r</code> opens things in read-only mode, <code>b</code> switches to buffers and so on.  The final <code>4</code>,  <code>5</code> and <code>t</code> in <code>C-x 4 4</code>,  <code>C-x 5 5</code> and <code>C-x t t</code> reinforce the idea that the next buffer action is going to be redirected to another window, a new frame and tab respectively.</p>
</div>
</details>
<p>Further below we take <a href="#a-window-prefix-command-for-ace-window">this approach to its logical extreme</a> with (what else) ace-window, redirecting the next command&rsquo;s buffer to any window, including ones we create just-in-time.</p>
<h3 id="saving-and-restoring-window-configurations">Saving and restoring window configurations</h3>
<p><code>window-configuration-to-register</code> is a bit of a blunt instrument, but perfect as a big red reset button, especially if you&rsquo;re new to Emacs.  At any point, you can save the current window configuration to a register
<span class="sidenote-number"><small class="sidenote">
A register is a named bucket that can hold many kinds of data.  Each register is assigned to a character (like <code>a</code> through <code>z</code>), and operations on register are available under the <code>C-x r</code> prefix.
</small></span>
with this command, bound to <code>C-x r w</code> by default.  After Emacs predictably messes up the frame, you can restore your saved configuration with <code>jump-to-register</code> (<code>C-x r j</code>).  That&rsquo;s it.</p>
<details>
<summary><span><img src="https://karthinks.com/img/lisp-icon.png" class=detail-icon></span> Persisting window configurations across restarts</summary>
<div class="details">
<p>The elisp version of <code>window-configuration-to-register</code> is the function <code>current-window-configuration</code>, whose return value you can bind to a variable, and apply to the frame with <code>set-window-configuration</code>.  Coupled with a way to persist this lisp object data to disk, such as with <code>prin1</code> or via a library like <code>persist</code> or <code>multisession</code>, we have the seed of a state restoration feature that works across Emacs sessions.  Needless to say, this approach is rudimentary and you&rsquo;re better off using one of the many packages listed above in <a href="#org-target--window-configuration-persistence">window configuration persistence</a>.</p>
</div>
</details>
<p>One issue with this method is that it restores the window arrangement down to each window&rsquo;s cursor position, which is rarely what you want.</p>
<p>Another problem is that it requires an unreasonable level of foresight to remember to save window configurations at appropriate times.  If only Emacs could do this automatically for us every time the window configuration changed&hellip;</p>
<h3 id="the-oops-options">The &ldquo;oops&rdquo; options</h3>
<p>&hellip;which of course it can.  You can ask Emacs to maintain a stack of your past window arrangements, and cycle through them as you would through changes in a buffer with undo/redo.  You&rsquo;ve got three minor-modes depending on how you use Emacs, and you can turn them on independently.</p>
<dl>
<dt><code>winner-mode</code></dt>
<dd>If you don&rsquo;t use tabs.  Call <code>winner-undo</code> and <code>winner-redo</code> to undo/redo window configuration changes.  It maintains a separate window configuration history for each frame.</dd>
<dt><code>tab-bar-history-mode</code></dt>
<dd>If you use tabs.  Each tab gets its own history stack.  The relevant commands are <code>tab-bar-history-back</code> and <code>tab-bar-history-forward</code>.</dd>
<dt><code>undelete-frame-mode</code> and <code>tab-undo</code></dt>
<dd>If you use create and delete frames or tabs all the time.  If you close a frame by accident, you can call <code>undelete-frame</code>, bound to <code>C-x 5 u</code>.  Ditto <code>tab-undo</code>, bound to <code>C-x t u</code>.</dd>
</dl>
<p>These options are handy for going on excursions, such as when you want to maximize the selected window temporarily before reverting to the previous arrangement.</p>
<p>But <code>winner-mode</code> &amp; co are also frequently recommended as a band-aid for when <em>Emacs messes up</em> your careful manual window arrangement, for instance by popping up windows in the wrong places, or resizing your window splits.  I think of this as an antipattern.  If you find yourself using <code>winner-undo</code> (or equivalent) all the time to fix Emacs&rsquo; behavior, the problem is Emacs displaying buffers in the wrong windows in the first place, a result of frustrating defaults.  See <a href="#deal-with-windows-so-we-don-t-have-to-deal-with-windows">the whack-a-mole problem</a>.</p>
<h2 id="digging-in">Digging in</h2>
<p>With our appetite whetted, we can move onto our main course: Tweaks, customization and variations of the above tools that I&rsquo;ve found to work better.</p>
<p>Emacs can be frustrating on two levels.  It&rsquo;s frustrating at first because you don&rsquo;t know your way around the place, the keybindings and terminology are obtuse, and nothing works the way it does in other software.  Your attempts at mitigating its perceived shortcomings by installing packages leads to mysterious, cryptic errors.  The single-threadedness makes it too easy to accidentally slow things down to a crawl.  The garbage collector fires at the worst times.  Things that should just work, don&rsquo;t.  The perceived shortcomings of Emacs are frustrating: <strong>Window management shouldn&rsquo;t be this complicated!</strong></p>
<p>Over time (years, decades?) you can develop a better mental model of what&rsquo;s happening under the hood: how Emacs&rsquo; event loop works, the anatomy of buffers, windows, keymaps, text properties and overlays &ndash; the data structures Emacs is built on.  Perhaps you even steal some sneaking glances at the lumbering behemoth that is <em>redisplay</em>.  You&rsquo;re familiar with common Elisp idioms and macros, as well as the common traps.  Now the <em>actual</em> shortcomings of Emacs&rsquo; API are frustrating: <strong>Window management shouldn&rsquo;t be this complicated!</strong></p>
<p>Oops.</p>
<p>So here we are.  The rest of this write-up is aimed at someone in between these two kinds of frustration.  It&rsquo;s mostly me throwing out suggestions, many of them mutually exclusive, that might give you ideas of your own to work with windows.  Implementing these ideas will require a little tweaking, copying code verbatim might not give you the results you expect.  For this reason, I suggest coming back here with a little more Emacs mileage if you&rsquo;re new to Emacs.</p>
<h3 id="the-back-and-forth-method">The back-and-forth method</h3>
<p>Offers: Quick window selection</p>
<p>An observation: no matter how many simultaneous windows you have or require on screen, most of the time you only need to switch between two of them.  Examples include the <strong>Code &amp; REPL</strong> setup, the <strong>Code &amp; Grep</strong> (search results) setup, and the <strong>Prose &amp; Notes</strong> setup.  The <strong>Listing &amp; Item</strong> pattern is an example outside of programming or prose: this includes a calendar or agenda window with an expanded entry window, or an email inbox window with an opened email.</p>
<p>The other windows on screen usually show useful information &ndash; documentation, debugging info, messages, logs or command output, table of contents, a file explorer, document previews &ndash; things you glance at often but switch to rarely.</p>
<p>Usually major-modes provide semi-consistent keybindings to switch back and forth between two associated windows &ndash; a common example is <code>C-c C-z</code>, used by several programming modes in Emacs to switch between a code window and an associated REPL
<span class="sidenote-number"><small class="sidenote">
This works for Org-babel blocks too via <code>org-babel-switch-to-session</code>, bound via <code>org-babel-map</code> to the slightly different <code>C-c C-v C-z</code>.
</small></span>
.</p>
<p>But we can generalize the idea and provide a command to switch between any pair of windows:</p>
<figure><img src="https://karthinks.com/img/window-back-and-forth.png"/>
</figure>

<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">other-window-mru</span> ()
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Select the most recently used window on this frame.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">when-let</span> ((<span style="color:#963">mru-window</span>
</span></span><span style="display:flex;"><span>              (<span style="color:#963">get-mru-window</span>
</span></span><span style="display:flex;"><span>               <span style="color:#036;font-weight:bold">nil</span> <span style="color:#036;font-weight:bold">nil</span> <span style="color:#a60;background-color:#fff0f0">&#39;not-this-one-dummy</span>)))
</span></span><span style="display:flex;"><span>    (<span style="color:#06b;font-weight:bold">select-window</span> <span style="color:#963">mru-window</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;M-o&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window-mru</span>)
</span></span></code></pre></div><p>It doesn&rsquo;t matter how you select the second window for the back-and-forth &ndash; you could use the <a href="#mousing-around--built-in">mouse</a>, <a href="#ace-window">ace-window</a>, <a href="#winum-mode">winum</a> or any other method.  <code>other-window-mru</code>&rsquo;s got you covered from then on.</p>
<h3 id="improving-other-window">Improving <code>other-window</code></h3>
<p>We can retain the basic idea of <code>other-window</code> &ndash; move between windows in the frame in some cyclic ordering &ndash; but improve the ordering to be more of a DWIM affair
<span class="sidenote-number"><small class="sidenote">
Do-What-I-Mean
</small></span>
.</p>
<p><code>other-window</code> is a simple idea &ndash; the simplest you&rsquo;ll find in this write-up &ndash; but you can play around with the order in which windows are selected to better fit how you work.</p>
<h4 id="double-duty">Double duty</h4>
<p>First, you could make <code>other-window</code> split the frame when there&rsquo;s only one window, giving the command a use when it has none.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#963">advice-add</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window</span> <span style="color:#007020">:before</span>
</span></span><span style="display:flex;"><span>            (<span style="color:#007020">defun</span> <span style="color:#963">other-window-split-if-single</span> (<span style="color:#038;font-weight:bold">&amp;rest</span> <span style="color:#963">_</span>)
</span></span><span style="display:flex;"><span>              <span style="background-color:#fff0f0">&#34;Split the frame if there is a single window.&#34;</span>
</span></span><span style="display:flex;"><span>              (<span style="color:#007020">when</span> (<span style="color:#963">one-window-p</span>) (<span style="color:#963">split-window-sensibly</span>))))
</span></span></code></pre></div><h4 id="switchy-window"><code>switchy-window</code></h4>
<figure class="alignright"><img src="https://karthinks.com/img/switchy-window-order.png" width="300px"/>
</figure>

<p>Another modification that you might find intuitive is to cycle through windows in order of last use instead of in clockwise spatial order, similar to alt-tab or how some web browsers cycle through tabs.  This is possible with some elbow grease, but this work has been done for us by the <a href="https://elpa.gnu.org/packages/switchy-window.html">switchy-window</a> package, which provides a <code>switchy-window</code> substitute command for <code>other-window</code>.</p>
<p>When cycling through windows, switchy-window waits for a window to stay selected for a couple of seconds before marking it as used and updating the recency list.  In practice this works quite seamlessly &ndash; calling <code>switchy-window</code> moves you to to where you need to be most of the time.</p>
<p>That said, I usually prefer the simpler variant described in <a href="#the-back-and-forth-method">the back-and-forth method</a>.</p>
<h4 id="other-window-alternating"><code>other-window-alternating</code></h4>
<p>And speaking of back-and-forth, here&rsquo;s another <code>other-window</code> variant &ndash; it might sound confusing at first, but turns out to be a pleasingly DWIM affair.  Except when chaining <code>other-window</code>, reverse the window-switching direction after each call.  With just two windows, this makes no difference.  With more, this makes alternating between two windows natural, even when the windows are not adjacent in the cyclic ordering.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defalias</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window-alternating</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#007020">let</span> ((<span style="color:#963">direction</span> <span style="color:#00d;font-weight:bold">1</span>))
</span></span><span style="display:flex;"><span>      (<span style="color:#007020">lambda</span> (<span style="color:#038;font-weight:bold">&amp;optional</span> <span style="color:#963">arg</span>)
</span></span><span style="display:flex;"><span>        <span style="background-color:#fff0f0">&#34;Call </span><span style="color:#a60;background-color:#fff0f0">`other-window&#39;</span><span style="background-color:#fff0f0">, switching directions each time.&#34;</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#007020">interactive</span>)
</span></span><span style="display:flex;"><span>        (<span style="color:#007020">if</span> (<span style="color:#06b;font-weight:bold">equal</span> <span style="color:#963">last-command</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window-alternating</span>)
</span></span><span style="display:flex;"><span>            (<span style="color:#963">other-window</span> (<span style="color:#06b;font-weight:bold">*</span> <span style="color:#963">direction</span> (<span style="color:#007020">or</span> <span style="color:#963">arg</span> <span style="color:#00d;font-weight:bold">1</span>)))
</span></span><span style="display:flex;"><span>          (<span style="color:#007020">setq</span> <span style="color:#963">direction</span> (<span style="color:#06b;font-weight:bold">-</span> <span style="color:#963">direction</span>))
</span></span><span style="display:flex;"><span>          (<span style="color:#963">other-window</span> (<span style="color:#06b;font-weight:bold">*</span> <span style="color:#963">direction</span> (<span style="color:#007020">or</span> <span style="color:#963">arg</span> <span style="color:#00d;font-weight:bold">1</span>)))))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;M-o&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window-alternating</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888">;; repeat-mode integration</span>
</span></span><span style="display:flex;"><span>(<span style="color:#06b;font-weight:bold">put</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window-alternating</span> <span style="color:#a60;background-color:#fff0f0">&#39;repeat-map</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window-repeat-map</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#963">keymap-set</span> <span style="color:#963">other-window-repeat-map</span> <span style="background-color:#fff0f0">&#34;o&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;other-window-alternating</span>)
</span></span></code></pre></div><h3 id="window-magic-with-ace-window-dispatch">Window magic with <code>ace-window</code> dispatch</h3>
<p><code>ace-window</code> is to windows what <code>completing-read</code> is to lists of strings, or Avy to characters on screen.  This makes it ideal as the first two of a three-step process to invoke <em>any</em> action on <em>any</em> window: the <span class="Purple">filter</span> and <span class="Orange">selection</span> steps:</p>
<figure><img src="https://karthinks.com/img/emacs-window-selection-pattern.png"/>
</figure>

<h4 id="aw-select-the-completing-read-for-emacs-windows"><code>aw-select</code>, the <code>completing-read</code> for Emacs windows</h4>
<p>The way ace-window is designed to be extended is by defining an &ldquo;ace-window action&rdquo; and adding a binding for it in <code>aw-dispatch-alist</code>
<span class="sidenote-number"><small class="sidenote">
It ships with several predefined actions, captured in <a href="#org-target--ace-window-default-actions">this schematic above</a>.
</small></span>
.  This function accepts a window and does something useful with it.  The <code>ace-window</code> command acts as the entry point:</p>
<figure><img src="https://karthinks.com/img/emacs-window-selection-via-ace.png"/>
</figure>

<p>This control flow is generally similar to how Avy works.  But as a <code>completing-read</code> alternative, this is somewhat lacking &ndash; we&rsquo;d like to flip the pattern around and use <code>ace-window</code>&rsquo;s selection method in <em>our</em> commands.  Conveniently, <code>aw-select</code> does exactly that.</p>
<figure class="alignright"><img src="https://karthinks.com/img/emacs-window-selection-ace-inside.png"/>
</figure>

<p>The basic pattern is very simple: the call <code>(aw-select nil)</code>
<span class="sidenote-number"><small class="sidenote">
The argument to <code>aw-select</code> is for adding a message to the mode-line during the selection process, we don&rsquo;t bother with that.
</small></span>
returns the window we select, which we can use for our task.  One example of such a task is to <a href="#scroll-other-window--built-in">set the window</a> that <code>scroll-other-window</code> should scroll.  Here are a couple more, but don&rsquo;t try them just yet!  We&rsquo;re going to generalize the idea a little further below.</p>
<p><strong><code>tear-off-window</code> or <code>tab-window-detach</code></strong></p>
<p>Every interactive window command in Emacs acts on the current window.  Here we make a couple of commands in the <a href="#the-window-prefix-map--built-in"><code>window-prefix-map</code> (<code>C-x w</code>)</a> something you can apply interactively to any window.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">ace-tear-off-window</span> ()
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Select a window with ace-window and tear it off the frame.
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">This displays the window in a new frame, see </span><span style="color:#a60;background-color:#fff0f0">`tear-off-window&#39;</span><span style="background-color:#fff0f0">.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">when-let</span> ((<span style="color:#963">win</span> (<span style="color:#963">aw-select</span> <span style="background-color:#fff0f0">&#34; ACE&#34;</span>))
</span></span><span style="display:flex;"><span>             (<span style="color:#963">buf</span> (<span style="color:#06b;font-weight:bold">window-buffer</span> <span style="color:#963">win</span>))
</span></span><span style="display:flex;"><span>             (<span style="color:#963">frame</span> (<span style="color:#963">make-frame</span>)))
</span></span><span style="display:flex;"><span>    (<span style="color:#06b;font-weight:bold">select-frame</span> <span style="color:#963">frame</span>)
</span></span><span style="display:flex;"><span>    (<span style="color:#963">pop-to-buffer-same-window</span> <span style="color:#963">buf</span>)
</span></span><span style="display:flex;"><span>    (<span style="color:#963">delete-window</span> <span style="color:#963">win</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">ace-tab-window-detach</span> ()
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Select a window with ace-window and move it to a new tab.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">when-let</span> ((<span style="color:#963">win</span> (<span style="color:#963">aw-select</span> <span style="background-color:#fff0f0">&#34; ACE&#34;</span>)))
</span></span><span style="display:flex;"><span>    (<span style="color:#007020">with-selected-window</span> <span style="color:#963">win</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#963">tab-window-detach</span>))))
</span></span></code></pre></div><p>Of course, defining one ace-window-based command for each action isn&rsquo;t a scalable or useful way to go about this.  It would be preferable to decouple the window selection step from the action step and generalize the latter.  We explore two distinct approaches to do this, starting with&hellip;</p>
<h4 id="ace-window-one-command-any-command-with-ace-window"><code>ace-window-one-command</code>: Any command with ace-window</h4>
<p>Generalizing the above examples gives us a pretty good idea of what the flipped <code>ace-window</code> pattern should look like.  The most general and composable version would be the following:</p>
<ol>
<li>Call <code>aw-select</code> to pick a window (the <code>completing-read</code> step)</li>
<li>Run any action in this window</li>
<li>Switch back to the original window.</li>
</ol>
<p>We can do this by simulating Emacs&rsquo; event loop, but in the chosen window: Switch windows, then read any key sequence and execute it before switching back.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">ace-window-one-command</span> ()
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">let</span> ((<span style="color:#963">win</span> (<span style="color:#963">aw-select</span> <span style="background-color:#fff0f0">&#34; ACE&#34;</span>)))
</span></span><span style="display:flex;"><span>    (<span style="color:#007020">when</span> (<span style="color:#06b;font-weight:bold">windowp</span> <span style="color:#963">win</span>)
</span></span><span style="display:flex;"><span>      (<span style="color:#007020">with-selected-window</span> <span style="color:#963">win</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#007020">let*</span> ((<span style="color:#963">command</span> (<span style="color:#06b;font-weight:bold">key-binding</span>
</span></span><span style="display:flex;"><span>                         (<span style="color:#06b;font-weight:bold">read-key-sequence</span>
</span></span><span style="display:flex;"><span>                          (<span style="color:#06b;font-weight:bold">format</span> <span style="background-color:#fff0f0">&#34;Run in %s...&#34;</span> (<span style="color:#06b;font-weight:bold">buffer-name</span>)))))
</span></span><span style="display:flex;"><span>               (<span style="color:#963">this-command</span> <span style="color:#963">command</span>))
</span></span><span style="display:flex;"><span>          (<span style="color:#06b;font-weight:bold">call-interactively</span> <span style="color:#963">command</span>))))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;C-x O&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;ace-window-one-command</span>)
</span></span></code></pre></div><p>In a demo, this looks the same as <code>ace-window</code>, except that you select the window before executing the action.  The win here is the action: it works with <em>any</em> simple command, there is no need to pre-configure actions in <code>aw-dispatch-alist</code>.  There&rsquo;s nothing to set up or memorize.  In this demo I use <code>ace-window-run-command</code> to shrink an unselected window with <code>C-x -</code> (the descriptively named <code>shrink-window-if-larger-than-buffer</code>)</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/ov2rxst.mp4" type="video/mp4">
<a href=https://karthinks.com/img/ace-window-one-command-demo.mp4">[VIDEO: ace-window-one-command demo]</a></video>
<details>
<summary>Play by play</summary>
<div class="details">
<ol>
<li>Pulse the line to show which window is active.</li>
<li>Call <code>ace-window-one-action</code> and select the Occur buffer to the top left.  Emacs waits for you to execute any single command.</li>
<li>Run <code>shrink-window-if-larger-than-buffer</code>, using <code>C-x -</code>.  This shrinks the Occur buffer, our cursor position and window is unchanged.</li>
</ol>
</div>
</details>
<p><code>ace-window-one-command</code> is a convenient way to quickly run any command in a different window, an idea we explore in <a href="#switch-and-return-actions-in-other-windows">more detail below</a>.</p>
<details class="implementation">
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> Embark much?</summary>
<div class="details">
<p>This reversal of Emacs&rsquo; (and ace-window&rsquo;s) usual paradigm of <span class="Green">action</span> → <span class="Orange">selection</span> is at the heart of Embark, as covered in my write-up on <a href="https://karthinks.com/software/fifteen-ways-to-use-embark/">ways to use Embark</a>.  Of course, this &ldquo;object-first&rdquo; approach is only one way to look at it &ndash; Embark has many hearts.</p>
</div>
</details>
<h4 id="a-window-prefix-command-for-ace-window">A window-prefix command for <code>ace-window</code></h4>
<p>Handy as it is, the <a href="#the-other-window-prefix--built-in"><code>other-window-prefix</code> system</a> has the same problem as the <code>other-window</code> command: it enforces a rigid cyclic ordering on the window it will pick, and about the most we can consistently expect is that the active window will not be taken over by the next command.  We can do better.</p>
<p><code>aw-select</code> gives us a bespoke solution with more control: we select the window that should be used if the next command involves displaying a buffer in a window.  In this example, we explicitly pick a window to show a man page in, since the &ldquo;next window&rdquo; is not where we want it:</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/2dHJZAP.mp4" type="video/mp4">
<a href=https://karthinks.com/img/ace-window-prefix-demo-alt.mp4">[VIDEO ace-window-prefix Man demo]</a></video>
<details>
<summary>Play by play</summary>
<div class="details">
<ol>
<li>Pulse the line to indicate the active window (lower left)</li>
<li>Run <code>ace-window-dispatch</code> (<code>C-x 4 o</code>), then <code>M-x man</code> and choose <code>curl(1)</code>.  Emacs waits for us to pick a window.</li>
<li>Pick the window on the right with &ldquo;e&rdquo;.  The Man page is displayed in that window.</li>
</ol>
<p>Note that the Man elisp library actually offers a suite of options to customize where it should be displayed, in the fiddly way typical of all things Emacs.  We can sidestep that whole undertaking here.</p>
</div>
</details>
<p>Here&rsquo;s the <a href="#org-target--window-management-forge-video">example from above</a> of viewing a Forge link in a busy frame with many windows.  We compare the result of using <code>other-window-prefix</code>, where a random window is chosen, to using <code>ace-window-prefix</code>, where we can pick a specific window:</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/BBa6AJu.mp4" type="video/mp4">
<a href=https://karthinks.com/img/ace-window-prefix-demo.mp4">[VIDEO ace-window-prefix Forge demo]</a></video>
<details>
<summary>Play by play</summary>
<div class="details">
<p>In this frame, the window &ldquo;next&rdquo; to the Forge topics window (the bottome one) is the one window at the top left.</p>
<ol>
<li>Move down to the last listed topic and pulse the line (so you can find the active window)</li>
<li>Call <code>other-window-prefix</code> (<code>C-x 4 4</code>) and press <code>RET</code> on the &ldquo;link&rdquo;.  It opens in the top left window, not where we&rsquo;d like to see it.</li>
<li>Call <code>tab-bar-history-back</code> to restore the previous window configuration.</li>
<li>Call <code>ace-window-prefix</code> (<code>C-x 4 o</code>) instead, and press <code>RET</code>.  Emacs waits for us to pick a window to show the resulting buffer in.</li>
<li>Pick the window on the right with &ldquo;r&rdquo;.  Forge shows the link contents in that window.</li>
</ol>
</div>
</details>
<p><code>ace-window</code> works across visible frames, so we can pick any Emacs window on our screen.  Even better, we can use <code>ace-window</code> actions to create new windows on the fly and use them instead.  Here I use an <code>ace-window</code> action to create a new window to be used by the next command:</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/DFNqQyC.mp4" type="video/mp4">
<a href=https://karthinks.com/img/ace-window-prefix-demo-2.mp4">[VIDEO: ace-window-prefix demo 2]</a></video>
<details>
<summary>Play by play</summary>
<div class="details">
<p>Normally, activating an Org mode link opens it in the current window or the next one, depending on your Org settings.  We want something different.</p>
<ol>
<li>Press <code>RET</code> on the link to open the image in the next window.</li>
<li>Press <code>q</code> to quit and return to the Org buffer.</li>
<li>Call <code>ace-window-prefix</code> and press <code>RET</code> on the link.  Emacs waits for us to pick a window to show the linked file in.</li>
<li>Use an <code>ace-window</code> action to split a window and select the split.  The action now finishes and the linked image is shown in that window.</li>
</ol>
</div>
</details>
<p>The implementation of <code>ace-window-prefix</code> is actually simpler than <code>other-window-prefix</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">ace-window-prefix</span> ()
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Use </span><span style="color:#a60;background-color:#fff0f0">`ace-window&#39;</span><span style="background-color:#fff0f0"> to display the buffer of the next command.
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">The next buffer is the buffer displayed by the next command invoked
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">immediately after this command (ignoring reading from the minibuffer).
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">Creates a new window before displaying the buffer.
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">When </span><span style="color:#a60;background-color:#fff0f0">`switch-to-buffer-obey-display-actions&#39;</span><span style="background-color:#fff0f0"> is non-nil,
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0"></span><span style="color:#a60;background-color:#fff0f0">`switch-to-buffer&#39;</span><span style="background-color:#fff0f0"> commands are also supported.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">display-buffer-override-next-command</span>
</span></span><span style="display:flex;"><span>   (<span style="color:#007020">lambda</span> (<span style="color:#963">buffer</span> <span style="color:#963">_</span>)
</span></span><span style="display:flex;"><span>     (<span style="color:#007020">let</span> (<span style="color:#963">window</span> <span style="color:#963">type</span>)
</span></span><span style="display:flex;"><span>       (<span style="color:#007020">setq</span>
</span></span><span style="display:flex;"><span>        <span style="color:#963">window</span> (<span style="color:#963">aw-select</span> (<span style="color:#06b;font-weight:bold">propertize</span> <span style="background-color:#fff0f0">&#34; ACE&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;face</span> <span style="color:#a60;background-color:#fff0f0">&#39;mode-line-highlight</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#963">type</span> <span style="color:#a60;background-color:#fff0f0">&#39;reuse</span>)
</span></span><span style="display:flex;"><span>       (<span style="color:#06b;font-weight:bold">cons</span> <span style="color:#963">window</span> <span style="color:#963">type</span>)))
</span></span><span style="display:flex;"><span>   <span style="color:#036;font-weight:bold">nil</span> <span style="background-color:#fff0f0">&#34;[ace-window]&#34;</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#06b;font-weight:bold">message</span> <span style="background-color:#fff0f0">&#34;Use </span><span style="color:#a60;background-color:#fff0f0">`ace-window&#39;</span><span style="background-color:#fff0f0"> to display next command buffer...&#34;</span>))
</span></span></code></pre></div><p>In keeping with the keybinding pattern for the <code>⋆-window-prefix</code> commands, we bind it to <code>C-x 4 o</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;C-x 4 o&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;ace-window-prefix</span>)
</span></span></code></pre></div><h2 id="do-you-need-to-switch-windows"><em>Do</em> you need to switch windows?</h2>
<p>Let&rsquo;s pause for a moment to ask a basic question:  <em>why</em> do you need to switch windows in the first place?  A little reductive thinking distills the answer down to two &ndash; and only two &ndash; possibilities:</p>
<ol>
<li><strong>Switch and stay</strong>: To work persistently in the destination window, for some measure of &ldquo;work&rdquo;: this covers text editing in all its forms.  In this event the window we switch to becomes our primary work area.</li>
<li><strong>Switch and return</strong>: To interact with the window or its contents briefly.  Perhaps we want to scroll through, or copy some text before moving back, or to delete the window.  In this event the window is a temporary destination, for auxiliary purposes.</li>
</ol>
<p>In either case, switching windows is a cost, not our objective.  Ideally this should happen automatically as part of our editing process.  So why not just &ldquo;fold&rdquo; this little chore into our primary editing action?</p>
<h3 id="switch-and-stay-avy-as-a-window-switcher">Switch and stay: Avy as a window switcher</h3>
<p>Eventually any kind of navigation in Emacs <a href="https://karthinks.com/software/avy-can-do-anything/">comes down to Avy</a>.  If you are switching windows to edit (or select) text, you intend to move to a specific point on the screen.  Getting the cursor there is a two step process: switch windows, move the cursor to the right location.  Avy short-circuits this process into a single action.  It treats the frame as a single pool of jump locations: in helping you jump to any character(s) on the screen, it moves you across windows seamlessly:</p>
<video style="center" width="700" controls>
<source src="https://i.imgur.com/6DP2Rnx.mp4" type="video/mp4">
<a href="https://karthinks.com/img/avy-basic-demo.mp4">[VIDEO: Jumping with Avy]</a>
</video>
<details>
<summary>Play by play</summary>
<div class="details">
<ol>
<li>Call <code>avy-goto-char-timer</code></li>
<li>Type in &ldquo;se&rdquo;. This shows hints for all matches with &ldquo;se&rdquo;, including &ldquo;sentence&rdquo;.</li>
<li>Type in the hint char corresponding to &ldquo;sentence&rdquo;, which is <code>g</code> here.</li>
</ol>
</div>
</details>
<p>With a slight mental shift you can stop thinking of windows as distinct objects entirely, at least for the purposes of navigation.  Any character(s) &ndash; across all visible Emacs windows and frames &ndash; is a couple of keypresses away.  And it&rsquo;s not the only way to jump across windows: you can jump back to your starting point (switching windows in the process) with <code>pop-global-mark</code>, for instance:</p>
<video style="center" width="700" controls>
<source src="https://i.imgur.com/W4uUzso.mp4" type="video/mp4">
<a href="https://karthinks.com/img/avy-jump-back-demo-2.mp4">[VIDEO: Jumping with Avy and pop-global-mark]</a>
</video>
<details>
<summary>Play by play</summary>
<div class="details">
<ol>
<li>Call <code>avy-goto-char-timer</code></li>
<li>Type in &ldquo;demo&rdquo;. There is only one candidate for this string, so Avy jumps to the other window.</li>
<li>Type in &ldquo;jump&rdquo;. This shows hints for all matches with &ldquo;jump&rdquo;.</li>
<li>Pick one of the matches. Avy jumps again, this time to the third window.</li>
<li>Call <code>pop-global-mark</code> (<code>C-x C-SPC</code>) to jump back to the previous location. (<a href="#org-target--pop-global-mark-advice">Details below</a>)</li>
<li>Call <code>pop-global-mark</code> (<code>C-x C-SPC</code>) again to jump back to the previous location.</li>
</ol>
</div>
</details>
<details>
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> Making Avy window-agnostic</summary>
<div class="details">
<p>If Avy does not move you across windows and frames, you probably need to customize <code>avy-all-windows</code>.</p>
<p>While we&rsquo;re here, consider customizing <code>avy-style</code>, there&rsquo;s more than one way to jump with Avy!</p>
</div>
</details>
<p>Of course, this only scratches the surface of what you can do with Avy, but that&rsquo;s well tread ground at this point.</p>
<h3 id="switch-and-return-actions-in-other-windows">Switch and return: Actions in other windows</h3>
<p>And here&rsquo;s the other case.  Often the reason you switch windows is to run a single logical action &ndash; perhaps a compound action like isearching to focus the view somewhere, before switching back to your main buffer.  This is the switch → act → switch-back dance.</p>
<p>We&rsquo;re going to automate this dance away in steps, working through solutions obvious and specific, through to repeatable and general, ending at the abstract and generic.</p>
<p>The obvious first: if you find yourself performing this dance repeatedly, you can automate it with a keyboard macro (left as an exercise for the reader).  If the action is something you do all the time, you can go a step further and write a general-purpose command. <a href="#ace-window-one-command-any-command-with-ace-window"><code>ace-window-one-command</code> above</a> would be one way to do it.  Emacs paves the way for us with&hellip;</p>
<h3 id="scroll-other-window--built-in"><code>scroll-other-window</code> (built-in)</h3>
<p><code>scroll-other-window</code> and <code>scroll-other-window-down</code> have been part of Emacs for ages, perhaps because it fits neatly into the two-window paradigm that Emacs&rsquo; default settings are suited for: editing in one window while using the contents of the other one as a reference.  You can scroll up and down in the other window without leaving this one.  Note that this works with any number of windows: the window that is scrolled is the &ldquo;<a href="#other-window-and-the-next-window--built-in">next window</a>&rdquo;, clockwise from the current one.  In this schematic, the selected window is the one with the border, the one that <code>scroll-other-window</code> scrolls is the one with the arrows:</p>
<figure><img src="https://karthinks.com/img/scroll-other-window.png"/>
</figure>

<p>With more than two windows this requires careful placement of windows to work as expected.  For instance, you cannot have three side-by-side buffers (1-3 above) and use 1 as a reference when working in both 2 and 3, since <code>scroll-other-window</code> in 2 will scroll 3.  Thankfully, we can specify the rule by which to select the window for scrolling.  One option is</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">setq</span> <span style="color:#963">other-window-scroll-default</span> <span style="color:#06b;font-weight:bold">#&#39;</span><span style="color:#963">get-lru-window</span>)
</span></span></code></pre></div><p>which will always scroll the least-recently-used window, since you won&rsquo;t be wading into buffer 1 &ndash; the reference &ndash; often.  Alternatively, you might want <code>scroll-other-window</code> in buffers 2 and 3 to scroll each other as you switch between them and ignore buffer 1.  You&rsquo;d then use the most-recently-used window:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">setq</span> <span style="color:#963">other-window-scroll-default</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#007020">lambda</span> ()
</span></span><span style="display:flex;"><span>        (<span style="color:#007020">or</span> (<span style="color:#963">get-mru-window</span> <span style="color:#036;font-weight:bold">nil</span> <span style="color:#036;font-weight:bold">nil</span> <span style="color:#a60;background-color:#fff0f0">&#39;not-this-one-dummy</span>)
</span></span><span style="display:flex;"><span>            (<span style="color:#06b;font-weight:bold">next-window</span>)               <span style="color:#888">;fall back to next window</span>
</span></span><span style="display:flex;"><span>            (<span style="color:#06b;font-weight:bold">next-window</span> <span style="color:#036;font-weight:bold">nil</span> <span style="color:#036;font-weight:bold">nil</span> <span style="color:#a60;background-color:#fff0f0">&#39;visible</span>))))
</span></span></code></pre></div><p>This works great with <a href="#the-back-and-forth-method">The back-and-forth method</a>.</p>
<details class="details implementation">
<summary><span><img src="https://karthinks.com/img/lisp-icon.png" class=detail-icon></span> Setting the window to scroll</summary>
<div class="details">
<p>There is another way to change the window that is scrolled instead: by setting a variable (<code>other-window-scroll-buffer</code>), you can specify the buffer whose window should be scrolled instead of the next window.  But this is mostly an option for package authors.  To do it on the fly, we&rsquo;d need to write another elisp command, something like</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">ace-set-other-window</span> ()
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Select a window with ace-window and set it as the \&#34;other
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">window\&#34; for the current one.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#963">when-let*</span> ((<span style="color:#963">win</span> (<span style="color:#963">aw-select</span> <span style="background-color:#fff0f0">&#34; ACE&#34;</span>))
</span></span><span style="display:flex;"><span>              (<span style="color:#963">buf</span> (<span style="color:#06b;font-weight:bold">window-buffer</span> <span style="color:#963">buf</span>)))
</span></span><span style="display:flex;"><span>    (<span style="color:#007020">setq-local</span> <span style="color:#963">other-window-scroll-buffer</span> <span style="color:#963">buf</span>)))
</span></span></code></pre></div><p>This is only useful if we want this association to be persistent.  Otherwise the LRU/MRU method does what we need most of the time.  See also <a href="#master-mode-and-scroll-all-mode">master-mode</a> below.</p>
</div>
</details>
<details class="details apinote" open>
<summary><span><img src="https://karthinks.com/img/emacs-icon.png" class=detail-icon></span> Scrolling other windows: minutiae</summary>
<div class="details">
<ol>
<li>
<p>The viability of the default bindings for <code>scroll-other-window</code> (<code>C-M-v</code> and <code>C-M-S-v</code>) depends on your tolerance for modifiers.  A good candidate for remapping, especially if you use a modal input method.  <code>C-M-v</code> can be invoked as <code>ESC C-v</code> already, I bind the other one to <code>ESC M-v</code>.</p>
</li>
<li>
<p><code>scroll-other-window</code> works from the minibuffer too.  The window scrolled is usually the one that the minibuffer-using command was invoked from, and can be set explicitly as the value of <code>minibuffer-scroll-window</code>.</p>
</li>
<li>
<p>From Emacs 29 onwards, <code>scroll-other-window</code> is better at handling non-text buffers like PDFs, where scrolling is handled by special functions.  It now calls whatever the standard scrolling commands (<code>scroll-up-command</code> and <code>scroll-down-command</code>) are bound to.  To scroll PDF buffers managed by the pdf-tools package in the &ldquo;next window&rdquo; position, for instance:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>   (<span style="color:#007020">with-eval-after-load</span> <span style="color:#a60;background-color:#fff0f0">&#39;pdf-tools</span>
</span></span><span style="display:flex;"><span>     (<span style="color:#963">keymap-set</span> <span style="color:#963">pdf-view-mode-map</span> <span style="background-color:#fff0f0">&#34;&lt;remap&gt; &lt;scroll-up-command&gt;&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#06b;font-weight:bold">#&#39;</span><span style="color:#963">pdf-view-scroll-up-or-next-page</span>)
</span></span><span style="display:flex;"><span>     (<span style="color:#963">keymap-set</span> <span style="color:#963">pdf-view-mode-map</span> <span style="background-color:#fff0f0">&#34;&lt;remap&gt; &lt;scroll-down-command&gt;&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#06b;font-weight:bold">#&#39;</span><span style="color:#963">pdf-view-scroll-down-or-previous-page</span>))
</span></span></code></pre></div><p>Another example: after rebinding the regular paging commands via <code>pixel-scroll-precision-mode</code>, <code>scroll-other-window</code> will smooth-scroll the other window:</p>
<video preload="metadata" style="center" width="600" controls>
<source src="https://i.imgur.com/24MKcsv.mp4" type="video/mp4">
<a href=https://karthinks.com/img/scroll-other-window-precision-demo.mp4">[VIDEO: smooth-scrolling with scroll-other-window]</a></video>
</li>
</ol>
</div>
</details>
<h3 id="isearch-other-window"><code>isearch-other-window</code></h3>
<p>Continuing with the idea of using a buffer in another window as a reference, a straightforward extension of <code>scroll-other-window</code> is to search the &ldquo;next window&rdquo; instead
<span class="sidenote-number"><small class="sidenote">
<code>isearch</code> is a fantastic navigational tool.
</small></span>
.  We make sure to search in the same window that we&rsquo;ve configured to scroll with <code>scroll-other-window</code> above.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">isearch-other-window</span> (<span style="color:#963">regexp-p</span>)
</span></span><span style="display:flex;"><span>    <span style="background-color:#fff0f0">&#34;Function to isearch-forward in the next window.
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">With prefix arg REGEXP-P, perform a regular expression search.&#34;</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#007020">interactive</span> <span style="background-color:#fff0f0">&#34;P&#34;</span>)
</span></span><span style="display:flex;"><span>    (<span style="color:#007020">unless</span> (<span style="color:#963">one-window-p</span>)
</span></span><span style="display:flex;"><span>      (<span style="color:#007020">with-selected-window</span> (<span style="color:#06b;font-weight:bold">other-window-for-scrolling</span>)
</span></span><span style="display:flex;"><span>        (<span style="color:#963">isearch-forward</span> <span style="color:#963">regexp-p</span>))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;C-M-s&#34;</span> <span style="color:#06b;font-weight:bold">#&#39;</span><span style="color:#963">isearch-other-window</span>)
</span></span></code></pre></div><p>The function <code>other-window-for-scrolling</code> returns a suitable window, respecting our choice of <code>other-window-scroll-default</code> above.</p>
<p>Here&rsquo;s an example of using <code>isearch-other-window</code> to work in a shell and a documentation (Man) buffer together:</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/5BDYIsk.mp4" type="video/mp4">
<a href=https://karthinks.com/img/isearch-other-window-demo.mp4">[VIDEO: isearch-other-window demo]</a></video>
<details>
<summary>Play by play</summary>
<div class="details">
<ol>
<li>Type in a partial Curl command</li>
<li>Invoke <code>isearch-other-window</code> (<code>C-M-s</code> here), which starts searching the Man buffer</li>
<li>Search for <code>--ssl revoke</code>, which finds the option we&rsquo;re looking for.  (This special matching behavior is from setting <code>isearch-whitespace-regexp</code>.)</li>
<li>Pressing <code>RET</code> ends isearch and we&rsquo;re back in the shell.</li>
<li>Scroll the other window with <code>scroll-other-window</code>, then use <code>hippie-expand</code> to type in the argument we want.</li>
</ol>
</div>
</details>
<p>The keybinding <code>C-M-s</code> is already bound to <code>isearch-forward-regexp</code>, but there are many other ways to call that command: via a prefix arg to <code>isearch-forward</code> (<code>C-u C-s</code>), or by toggling regexp search with <code>M-r</code> when isearching, for instance.</p>
<details class="details implementation">
<summary><span><img src="https://karthinks.com/img/lisp-icon.png" class=detail-icon></span> Performing actions in other windows</summary>
<div class="details">
<p>There are two simple ways to temporarily switch to another window in elisp: <code>(save-window-excursion (select-window somewin) ...)</code> and <code>(with-selected-window somewin ...)</code>.</p>
<p>For our purposes, the difference between them is that the former restores the window configuration at the time it was executed, which includes the buffer positions relative to the windows and the values of <code>(point)</code> in the buffer.  The latter persists changes across the frame, and is typically what we want.  If the changes were not persistent, there would be no point to this exercise!</p>
</div>
</details>
<h3 id="switch-buffers-in-the-next-window-dot">Switch buffers in the next window.</h3>
<p>You can have hundreds of buffers in Emacs but only a handful of windows.  This is, in fact, the source of the window management problem.  So any comprehensive solution has to involve changing buffers shown in existing windows.  The ace-window <a href="#ace-window">dispatch system</a> is one solution.  But the built-in <code>next-buffer</code> and <code>previous-buffer</code> commands offer another easy 80% solution to changing buffers shown in other windows: we just automate away the window switching dance.  We don&rsquo;t need a dedicated <code>next-buffer-other-window</code> command for this &ndash; we can just replace <code>next-buffer</code> with the new function.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">my/next-buffer</span> (<span style="color:#038;font-weight:bold">&amp;optional</span> <span style="color:#963">arg</span>)
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Switch to the next ARGth buffer.
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">With a universal prefix arg, run in the next window.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span> <span style="background-color:#fff0f0">&#34;P&#34;</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">if-let</span> (((<span style="color:#06b;font-weight:bold">equal</span> <span style="color:#963">arg</span> <span style="color:#333">&#39;</span>(<span style="color:#00d;font-weight:bold">4</span>)))
</span></span><span style="display:flex;"><span>           (<span style="color:#963">win</span> (<span style="color:#06b;font-weight:bold">other-window-for-scrolling</span>)))
</span></span><span style="display:flex;"><span>      (<span style="color:#007020">with-selected-window</span> <span style="color:#963">win</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#963">next-buffer</span>)
</span></span><span style="display:flex;"><span>        (<span style="color:#007020">setq</span> <span style="color:#963">prefix-arg</span> <span style="color:#963">current-prefix-arg</span>))
</span></span><span style="display:flex;"><span>    (<span style="color:#963">next-buffer</span> <span style="color:#963">arg</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">my/previous-buffer</span> (<span style="color:#038;font-weight:bold">&amp;optional</span> <span style="color:#963">arg</span>)
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Switch to the previous ARGth buffer.
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">With a universal prefix arg, run in the next window.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span> <span style="background-color:#fff0f0">&#34;P&#34;</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">if-let</span> (((<span style="color:#06b;font-weight:bold">equal</span> <span style="color:#963">arg</span> <span style="color:#333">&#39;</span>(<span style="color:#00d;font-weight:bold">4</span>)))
</span></span><span style="display:flex;"><span>           (<span style="color:#963">win</span> (<span style="color:#06b;font-weight:bold">other-window-for-scrolling</span>)))
</span></span><span style="display:flex;"><span>      (<span style="color:#007020">with-selected-window</span> <span style="color:#963">win</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#963">previous-buffer</span>)
</span></span><span style="display:flex;"><span>        (<span style="color:#007020">setq</span> <span style="color:#963">prefix-arg</span> <span style="color:#963">current-prefix-arg</span>))
</span></span><span style="display:flex;"><span>    (<span style="color:#963">previous-buffer</span> <span style="color:#963">arg</span>)))
</span></span></code></pre></div><p>And we can take over <code>next-buffer</code> and <code>previous-buffer</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;&lt;remap&gt; &lt;next-buffer&gt;&#34;</span>     <span style="color:#a60;background-color:#fff0f0">&#39;my/next-buffer</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#963">keymap-global-set</span> <span style="background-color:#fff0f0">&#34;&lt;remap&gt; &lt;previous-buffer&gt;&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;my/previous-buffer</span>)
</span></span></code></pre></div><p>Finally, we define a fallback version of <code>switch-to-buffer</code> and shove all of these into a repeat-map so we can call them consecutively with <code>n</code>, <code>p</code> and <code>b</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span><span style="color:#888">;; switch-to-buffer, but possibly in the next window</span>
</span></span><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">my/switch-buffer</span> (<span style="color:#038;font-weight:bold">&amp;optional</span> <span style="color:#963">arg</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span> <span style="background-color:#fff0f0">&#34;P&#34;</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">run-at-time</span>
</span></span><span style="display:flex;"><span>   <span style="color:#00d;font-weight:bold">0</span> <span style="color:#036;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>   (<span style="color:#007020">lambda</span> (<span style="color:#038;font-weight:bold">&amp;optional</span> <span style="color:#963">arg</span>)
</span></span><span style="display:flex;"><span>     (<span style="color:#963">if-let</span> (((<span style="color:#06b;font-weight:bold">equal</span> <span style="color:#963">arg</span> <span style="color:#333">&#39;</span>(<span style="color:#00d;font-weight:bold">4</span>)))
</span></span><span style="display:flex;"><span>              (<span style="color:#963">win</span> (<span style="color:#06b;font-weight:bold">other-window-for-scrolling</span>)))
</span></span><span style="display:flex;"><span>         (<span style="color:#007020">with-selected-window</span> <span style="color:#963">win</span>
</span></span><span style="display:flex;"><span>           (<span style="color:#963">switch-to-buffer</span>
</span></span><span style="display:flex;"><span>            (<span style="color:#963">read-buffer-to-switch</span>
</span></span><span style="display:flex;"><span>             (<span style="color:#06b;font-weight:bold">format</span> <span style="background-color:#fff0f0">&#34;Switch to buffer (%S)&#34;</span> <span style="color:#963">win</span>))))
</span></span><span style="display:flex;"><span>       (<span style="color:#06b;font-weight:bold">call-interactively</span> <span style="color:#06b;font-weight:bold">#&#39;</span><span style="color:#963">switch-to-buffer</span>)))
</span></span><span style="display:flex;"><span>   <span style="color:#963">arg</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#963">defvar-keymap</span> <span style="color:#963">buffer-cycle-map</span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020">:doc</span> <span style="background-color:#fff0f0">&#34;Keymap for cycling through buffers, intended for </span><span style="color:#a60;background-color:#fff0f0">`repeat-mode&#39;</span><span style="background-color:#fff0f0">.&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020">:repeat</span> <span style="color:#036;font-weight:bold">t</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;n&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;my/next-buffer</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;p&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;my/previous-buffer</span>
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;b&#34;</span> <span style="color:#a60;background-color:#fff0f0">&#39;my/switch-buffer</span>)
</span></span></code></pre></div><p>The result of this keymap gymnastics, with key descriptions in the top right:</p>
<video preload="metadata" style="center" width="700" controls>
<source src="https://i.imgur.com/kfZiyqZ.mp4" type="video/mp4">
<a href=https://karthinks.com/img/next-buffer-with-repeat.mp4">[VIDEO: next-buffer with repeat]</a></video>
<details open>
<summary>Play by play</summary>
<div class="details">
<ul>
<li>Call <code>my/next-buffer</code> or <code>my/previous-buffer</code> (I&rsquo;ve bound them to <code>C-x C-n</code> and <code>C-x C-p</code> instead of remapping the default <code>next-buffer</code> binding <code>C-x &lt;right&gt;</code>).</li>
<li>This activates the repeat-map <code>buffer-cycle-map</code>, so I can continue cycling through buffers with <code>n</code> and <code>p</code>.</li>
<li>Exit the repeat-map by pressing any other key.</li>
<li>Call <code>my/next-buffer</code> with a prefix argument (<code>C-u C-x C-n</code>).  This activates the <code>buffer-cycle-map</code>, but in the <em>other</em> window, so you can cycle buffers in the other window with <code>n</code> and <code>p</code>.</li>
<li>Pressing <code>b</code> when the repeat map is active calls <code>switch-to-buffer</code> in the window that is selected.  This is a fallback when the buffer you need is not one or two away in the window&rsquo;s buffer history.</li>
</ul>
</div>
</details>
<p>Using <code>b</code> to display a buffer in another window is consistent with how <code>ace-window</code>&rsquo;s dispatch version works.</p>
<h3 id="master-mode-and-scroll-all-mode"><code>master-mode</code> and <code>scroll-all-mode</code></h3>
<p>A passing note: Emacs provides <code>master-mode</code>, a bespoke solution for performing actions in other windows without leaving this one.  You can designate a buffer as the &ldquo;slave&rdquo; buffer of the current buffer (the &ldquo;master&rdquo;).  This opens up a keymap for scrolling the slave buffer without leaving the current one.  By itself, this is a worse alternative to the more transparent and immediate solutions involving <code>other-window-scroll-default</code> above.  But you can add to this keymap with the plumbing command <code>master-says</code>, which helps you set up keys to do predefined actions in the slave buffer.  This built-in action, for example, recenters the slave buffer:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">master-says-recenter</span> (<span style="color:#038;font-weight:bold">&amp;optional</span> <span style="color:#963">arg</span>)
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Recenter the slave buffer.
</span></span></span><span style="display:flex;"><span><span style="background-color:#fff0f0">See </span><span style="color:#a60;background-color:#fff0f0">`recenter&#39;</span><span style="background-color:#fff0f0">.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">master-says</span> <span style="color:#a60;background-color:#fff0f0">&#39;recenter</span> <span style="color:#963">arg</span>))
</span></span></code></pre></div><p>But this can be <em>any</em> action: you could set a shell or compilation buffer as the slave buffer of every project buffer, and use <code>master-mode</code> to page through them, copy the latest output, send commands and so on.</p>
<p>And while we&rsquo;re focused on scrolling, <code>scroll-all-mode</code> is a simple way of tying together scroll actions in all windows on the frame.  On occasions where you want to keep two more more window views in sync, this is a handier method than scrolling the active window and then the other window.</p>
<h3 id="with-other-window-an-elisp-helper"><code>with-other-window</code>: An elisp helper</h3>
<p>What&rsquo;s better than writing a general-purpose command to automate one switch → act → switch-back dance?  A general-purpose macro to automate writing the general-purpose command!  We can decouple the action from the switching with a macro:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defmacro</span> <span style="color:#963">with-other-window</span> (<span style="color:#038;font-weight:bold">&amp;rest</span> <span style="color:#963">body</span>)
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Execute forms in BODY in the other-window.&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#333">`</span>(<span style="color:#007020">unless</span> (<span style="color:#963">one-window-p</span>)
</span></span><span style="display:flex;"><span>    (<span style="color:#007020">with-selected-window</span> (<span style="color:#06b;font-weight:bold">other-window-for-scrolling</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#333">,@</span><span style="color:#963">body</span>)))
</span></span></code></pre></div><p>The above examples become straightforward applications of this macro</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">isearch-other-window</span> (<span style="color:#963">regexp-p</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span> <span style="background-color:#fff0f0">&#34;P&#34;</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">with-other-window</span> (<span style="color:#963">isearch-forward</span> <span style="color:#963">regexp-p</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#007020">defun</span> <span style="color:#963">isearch-other-window-backwards</span> (<span style="color:#963">regexp-p</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">interactive</span> <span style="background-color:#fff0f0">&#34;P&#34;</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#963">with-other-window</span> (<span style="color:#963">isearch-backward</span> <span style="color:#963">regexp-p</span>)))
</span></span></code></pre></div><p>This is the elisp counterpart to the interactive <code>ace-window-one-command</code>.</p>
<h2 id="do-you-need-many-windows">Do you <em>need</em> many windows?</h2>
<p>The world seems to have converged on a single UI for editors: one main window, a tab bar at the top (with one window per tab), a directory or contents sidebar on the left, an optional doodad on the right, and a terminal emulator below.</p>
<figure class="wide"><img src="https://karthinks.com/img/modern-editor-layouts.jpeg"
         alt="Modern text and code editor window layouts.  Clockwise from top left -- Zed, Neovim, Obsidian, VSCode."/>
</figure>

<p>Every editor got the memo&hellip; except Emacs, it appears.  You could recreate this window layout and workflow in Emacs.  Or any other, for that matter.  But all this furious window management behooves us to ask an even more basic question:  <em>Why even have more than one window?</em></p>
<p>There&rsquo;s some merit to this: the screen could be devoted to one buffer at a time, with buffer-switching taking the place of window switching.  There&rsquo;s no need to worry about resizing windows, and anything that pops up in the course of introspection or regular editing (like documentation windows) can be dismissed with a keypress, typically <code>q</code>.  Special buffers like the file browser are accessible via dedicated commands like <code>dired-jump</code>.</p>
<p>Relaxing this requirement to two-windows-at-a-time helps retain most of the hassle-free behavior while adding the benefits of using the second window as a live reference.  By default, Emacs is set up to do this well, as evidenced by <code>scroll-other-window</code> and other commands.  No rigid layout imposed via decree from on high, but no chaotic structureless and windows popping up like weeds either.</p>
<p>Effectively, we&rsquo;ve circled our way back to <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/The-Zen-of-Buffer-Display.html">The Zen of Buffer Display</a>.  While it would be ironic if the window management freedom Emacs provides causes us to reject it, we <em>can</em> route around the problem and not deal with windows at all, irrespective of how many we&rsquo;d like to have on screen simultaneously.</p>
<p>So here are two more strategies for window management, both of which involve minimizing dealing with windows.  The first one is &ldquo;window management&rdquo; in the loosest sense of the term:</p>
<h3 id="windows-are-made-up-let-s-ignore-them">Windows are made up, let&rsquo;s ignore them</h3>
<p><a href="#switch-and-stay-avy-as-a-window-switcher">Window-agnostic jumping with Avy</a> is a special case of a general idea: when using Emacs, we are primarily concerned with text.  As a container for text, a window can be an unnecessary abstraction.  This framing is natural when a destination is outside the screen contents, such as when jumping to definitions with <code>xref-find-definitions</code>.</p>
<p>But there are several other ways to apply this window-agnosticism.  The <code>mark-ring</code> and <code>global-mark-ring</code> keep track of locations we jump from, letting us jump back with <code>pop-to-mark-command</code> (<code>C-u C-SPC</code>) and <code>pop-global-mark</code> (<code>C-x C-SPC</code>), the latter of which can jump across windows if necessary.  A package like <a href="https://github.com/alphapapa/dogears.el">dogears</a> can provide more granular control and a nicer UI to retrace your steps.</p>
<p><span class="org-target" id="org-target--pop-global-mark-advice"></span></p>
<details>
<summary><span><img src="https://karthinks.com/img/lisp-icon.png" class=detail-icon></span> Making <code>pop-to-buffer</code> jump across windows.</summary>
<div class="details">
<p>By default, <code>pop-global-mark</code> always switches buffers (if required) in the current window.  We&rsquo;d like it to double as a window-switcher, which requires a little advice:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span style="display:flex;"><span>(<span style="color:#007020">define-advice</span> <span style="color:#963">pop-global-mark</span> (<span style="color:#007020">:around</span> (<span style="color:#963">pgm</span>) <span style="color:#963">use-display-buffer</span>)
</span></span><span style="display:flex;"><span>  <span style="background-color:#fff0f0">&#34;Make </span><span style="color:#a60;background-color:#fff0f0">`pop-to-buffer&#39;</span><span style="background-color:#fff0f0"> jump buffers via </span><span style="color:#a60;background-color:#fff0f0">`display-buffer&#39;</span><span style="background-color:#fff0f0">.&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#007020">cl-letf</span> (((<span style="color:#06b;font-weight:bold">symbol-function</span> <span style="color:#a60;background-color:#fff0f0">&#39;switch-to-buffer</span>)
</span></span><span style="display:flex;"><span>                         <span style="color:#06b;font-weight:bold">#&#39;</span><span style="color:#963">pop-to-buffer</span>))
</span></span><span style="display:flex;"><span>                (<span style="color:#06b;font-weight:bold">funcall</span> <span style="color:#963">pgm</span>)))
</span></span></code></pre></div></div>
</details>
<p>To manually pin a position to jump back to later, there is <code>point-to-register</code> (<code>C-x r SPC</code>) and <code>jump-to-register</code> (<code>C-x r j</code>).  Again, this switches windows as a side-effect.</p>
<p>For more permanent records, you can create and jump to bookmarks with <code>bookmark-set</code> (<code>C-x r m</code>) and <code>bookmark-jump</code> (<code>C-x r b</code>).</p>
<p>Between these, you have plenty of options for navigating across windows to locations that are meaningful, as ascertained by either Emacs or you.  These work just as well with a single window in an Emacs frame as they do with the canonical twenty-first century IDE window layout.</p>
<h3 id="deal-with-windows-so-we-don-t-have-to-deal-with-windows">Deal with windows so we don&rsquo;t have to deal with windows</h3>
<p><em>i.e.</em> Fixing the Whack-A-Mole window problem.</p>
<p>As much as this write-up is about manual actions involving Emacs windows, it was unavoidable: at some point I was going to have to mention <code>display-buffer-alist</code> and automatic window behavior.  The idea is simple.  Every time elisp code wants to show you a buffer, it tries to match the buffer it is displaying against a list of rules in this variable.  The matching entry specifies how it should be displayed.</p>
<p>If we set up rules &ndash; specifying window sizes, positions, roles, focus &ndash; for every kind of buffer we see in our daily Emacs use, that&rsquo;s most window management sorted&hellip; right?</p>
<p>Right, actually.  The reality hews close to the aspiration.  The problem with <code>display-buffer-alist</code> is not that it <em>doesn&rsquo;t</em> work, but that it&rsquo;s a <em>lot</em> of work.  Creating rules for displaying buffers involves understanding many more aspects of Emacs&rsquo; API than is reasonable for most users: buffer and mode predicates, window types and slots, display-buffer action functions, window parameters, and a whole lot more gibberish.  And at the end of this expedition into the elisp manual, there is no easy way to express a simple intention, like &ldquo;do <em>not</em> disturb my window arrangement&rdquo;
<span class="sidenote-number"><small class="sidenote">
Specifying overreaching and overriding display-buffer preferences can do this, but they lead to dozens of edge cases and unintended behavior.
</small></span>
.  As such, it&rsquo;s a tool primarily used by package authors to surface a more approachable interface to specifying automatic window behaviors for their package.</p>
<p>But in the spirit of the almanac, let&rsquo;s not leave this topic empty handed.</p>
<ul>
<li>
<p>The <a href="https://depp.brause.cc/shackle/">Shackle</a> package papers over the <code>display-buffer-alist</code> oddness and presents a simplified elisp interface for specifying window rules.  If you want to corral a couple of pesky buffer types that always ruin your window arrangement and have you reaching for <code>winner-undo</code>, this is your best bet.</p>
</li>
<li>
<p>Emacs distributions usually provide a simple interface for specifying these preferences.
<span class="sidenote-number"><small class="sidenote">
Doom Emacs provides a convenient <code>set-popup-rule!</code> command for this.
</small></span>
If you&rsquo;re using one, you&rsquo;re probably covered.</p>
</li>
<li>
<p>And if you&rsquo;ve got a hankering for tinkering, <a href="https://www.masteringemacs.org/article/demystifying-emacs-window-manager">Mickey Peterson&rsquo;s article</a> on demystifying the window manager, this <a href="https://protesilaos.com/codelog/2024-02-08-emacs-window-rules-display-buffer-alist/">video by Protesilaos Stavrou</a> and <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Displaying-Buffers.html">the elisp manual</a> are all fine resources, as alluded to in the preface.</p>
</li>
</ul>
<h3 id="popper-popwin-shell-pop-and-vterm-toggle">Popper, Popwin, shell-pop and vterm-toggle</h3>
<p>While we&rsquo;re aiming at the ideal of the minimal workspace uncluttered by windows, a popup manager is another helpful tool.</p>
<p><a href="https://github.com/emacsorphanage/popwin">Popwin</a> and <a href="https://github.com/karthink/popper">Popper</a> are Emacs packages based on the observation that not all buffers are created equal.  There are (primary) buffers we spend most of our time in, and (popup) buffers we&rsquo;d like to access temporarily &ndash; to use as a reference, page through documentation, run shell commands, check a task or compilation status, access search results, read messages, and so on.  Using <code>display-buffer-alist</code> or an equivalent method, you can make these buffers use smaller, auxiliary windows and not grab the cursor when they appear.  But that doesn&rsquo;t solve the access problem: what we&rsquo;d like is one key access to summon these popup buffers, and easy ways to dismiss their windows, cycle through or kill them.</p>
<p>Popper provides this for all kinds of buffers you choose to (pre-)designate as popups, helping you stick to the one (or two) window paradigm, raising and dismissing these auxiliary windows as needed.  This image shows popups available in the current context as a line of tabs that can be accessed or cycled through with one key:</p>
<figure><img src="https://karthinks.com/img/popper-tab-line-demo.png"/>
</figure>

<p>Popwin is an older and more comprehensive implementation of this idea, but it bundles together quick key access and its own bespoke display-buffer configuration, which may not be what you want.  If you only want one key-access to summon and dismiss shell buffers, <a href="https://github.com/kyagi/shell-pop-el">shell-pop</a> or <a href="https://github.com/jixiuf/vterm-toggle">vterm-toggle</a> might be all you need instead.</p>
<h2 id="the-missing-pieces">The Missing Pieces</h2>
<p>We conclude with window management options that should exist&hellip; but don&rsquo;t.</p>
<h3 id="window-tree">window-tree</h3>
<p>There is a fundamental disconnect between how Emacs represents windows and how we manipulate them using the approaches discussed above.</p>
<p>Windows in a frame in Emacs are arranged in a tree: the leaf nodes are &ldquo;live&rdquo; (real) windows, and the rest are &ldquo;internal&rdquo; (virtual) windows
<span class="sidenote-number"><small class="sidenote">
The minibuffer is technically not part of this tree, although it can be reached by traversing it.  (See the <code>window-tree</code> function.)
</small></span>
.</p>
<figure><img src="https://karthinks.com/img/emacs-window-tree-illustration.png"/>
</figure>

<p>Most user-facing operations on windows, such as moving between them with <code>other-window</code> or Windmove, ignore the tree structure and work by examining their spatial positions instead.  This often causes unexpected and unintuitive behavior when splitting or deleting windows, or imposes confusing constraints on what splits you can create.  For example, there is no way to perform these transformations:</p>
<figure><img src="https://karthinks.com/img/emacs-window-tree-deficit.png"/>
</figure>

<p>The window that needs to be split here is neither the frame root nor a leaf window &ndash; it&rsquo;s some internal node in the tree.</p>
<p>Adding commands for window-tree operations opens the door to many new possibilities.  Frame transformations like splitting, transposing, mirroring and so on are elementary operations on window-tree branches.  Multiple window selection is possible via &ldquo;selecting&rdquo; internal windows, and <em>partial</em> window configurations can then be operated on, handed off to other tabs or frames, duplicated or persisted.  Tree branches can be protected from being mangled by <code>display-buffer</code> and friends
<span class="sidenote-number"><small class="sidenote">
This kind of all-or-nothing window behavior is currently enabled via Elisp&rsquo;s atomic windows API, which is a significantly more restrictive approach.
</small></span>
, and you can have sections of a frame devoted to one task, with the sibling branch tolerating flexible, looser behavior.</p>
<p>How do we write this hypothetical wintree package?</p>
<ol>
<li>Elisp already provides functions to query the window tree: <code>window-tree</code> returns the tree itself.  <code>frame-root-window</code> returns the tree root, and <code>window-parent</code>, <code>window-child</code>, <code>window-*-sibling</code> do what you&rsquo;d expect.</li>
<li>There is some support for tree traversal via <code>walk-window-tree</code> and <code>walk-windows</code>.</li>
<li>There are no elementary functions for mutating the tree, except via splitting and deleting live windows the usual way.</li>
<li>There is no concept of &ldquo;selecting&rdquo; an internal window, so this will have to be simulated via the UI, perhaps by <a href="https://github.com/captainflasmr/selected-window-accent-mode">adding a border</a> inside each window in the sub-tree.</li>
</ol>
<p>So some of the required elements are present.  The missing ingredient is a motivated Emacs user (perhaps you) stepping into <code>window.el</code> and getting their hands dirty!</p>
<h3 id="the-tiling-wm-integrator">The tiling-wm integrator</h3>
<p>Emacs&rsquo; window-tree model is almost exactly that of manual tiling window managers like i3 or bspwm, sans some affordances like i3&rsquo;s tabbed windows.  This leads us to a natural question: why use a tiling window manager inside of another one?
<span class="sidenote-number"><small class="sidenote">
Yo dawg, I heard you like tiling&hellip;
</small></span>
If you use i3, bspwm or Emacs inside tmux, it&rsquo;s natural to want to be able to navigate both seamlessly, with the same keybindings.  There are a couple of Emacs packages for this: Pavel Korytov&rsquo;s <a href="https://sqrtminusone.xyz/posts/2021-10-04-emacs-i3/">i3-integration</a>, and something I hacked up for <a href="https://github.com/karthink/.emacs.d/blob/master/plugins/emacs-wm.el">qtile</a>.  But providing a cleaner and more unified interface for this from Emacs can make integrating with all window managers much easier.  Again, most elements we need are already present:</p>
<ol>
<li>The window manager should provide some way to identify the active window class, and to move across and manipulate windows programmatically.  This can be via a shell command, socket or server-based IPC, or (on Linux) via D-Bus methods.  This covers most window managers and terminal multiplexers.</li>
<li>On the Emacs side, we need a communication method-agnostic interface for window operations that mimics how most window managers do them, supporting a common subset of operations or (more ambitiously) their union.</li>
<li>When switching windows in the window manager, we check if the active window is Emacs, and yield control to it if required.  Emacs then performs the window operation within or without the Emacs frame as required.</li>
</ol>
<p>As before, the missing ingredient is you!</p>
<h2 id="the-view-from-here">The view from here</h2>
<p>Believe it or not, this was the short version.  To keep the scope of this piece under check, there are several window management strategies I had to exclude, such as anything involving <code>tab-line-mode</code>, or window types and properties like atomic, dedicated or side windows.  And we are all safer for skirting around the issue of <code>display-buffer</code>.</p>
<p>Where does that leave us?  With about a dozen ways to switch, move, jump around, create, delete and otherwise manipulate windows and window configurations in Emacs, many ways to control window display on the fly when invoking commands, and half a dozen ways to work across windows and avoid thinking about them at all.  Once again, this collection is colored and limited by my experience with window wrangling in Emacs, and thus it&rsquo;s not an exhaustive list.  If I&rsquo;ve missed something simple and useful please let me know!</p>
<p>For better or worse, window management in Emacs is not so much complicated as it is open-ended.  Emacs provides the ingredients and some instructions, and the ingredients can work as basic meals by themselves.</p>
<p>But with a little cooking we can make something delicious.  Bon appétit.</p>
<hr>
<details class="implementation" open style="font-size:0.8rem">
<summary>Updates and Corrections</summary>
<div class="details">
<p>Thanks to the following folks for corrections and suggestions:</p>
<ul>
<li><a href="https://old.reddit.com/r/planetemacs/comments/1cp4hfg/karthik_chikmagalur_the_emacs_window_management/l3kthnq/">JD Smith for pointing out</a> that <code>winner-mode</code> maintains separate window configuration history per Emacs frame, so it remains viable if you use multiple frames.</li>
<li>Grant Rosson for reminding me that <code>pop-global-mark</code> does <em>not</em> work across Emacs windows by default, and needs a little advice.</li>
<li><a href="https://old.reddit.com/r/planetemacs/comments/1cp4hfg/karthik_chikmagalur_the_emacs_window_management/l3kthnq/">u/simplex5d for corrections</a> to the <code>winum-keymap</code> definition.</li>
<li>kotatsuyaki mentions that <code>aw-dispatch-always</code> needs to be set for <code>ace-window</code> actions to be available when there are two or fewer windows on the screen.</li>
</ul>
</div>
</details>
